   

## 12.5　分析归并排序算法

归并排序算法看起来比选择排序算法复杂很多，似乎会需要更多时间来执行这些重复的拆分。然而，时间分析结果显示归并排序比选择排序好多了。

图12-2显示了包含两组性能数据的一个表和一个图。如你所见，归并排序的性能提高是惊人的。为了理解其中的原因，我们来估计一下使用归并排序算法对列表进行排序时需要的列表元素访问次数。首先，我们先来处理前后两半都排好序之后的合并过程。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07773.jpeg)

图12-2　选择排序需要的时间

合并过程中每一步会在values中增加一个新元素。那个元素可能会来自first，也可能会来自second，大多数情况下需要比较一下两个子列表中的元素来决定取哪一个。我们为每个元素记3次访问（values一次，first和second各一次），或者说总共3n次访问，其中n表示values列表的长度。另外，在开始的时候，我们必须把数据从values复制到first和second，这需要另外的2n次访问，这样的话总共需要5n次访问。

如果我们使用T(n)表示使用归并排序对包含n个元素的列表进行排序所需要的访问次数，那么有：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07774.jpeg)

因为对每一半排序需要T(n/2)次访问。实际上，如果n不是偶数的话，我们切分后的列表长度一个是(n-1)/2而另一个是(n+1)/2。尽管已经证明这个细节不影响计算的结果，我们现在还是假设n是2的幂，比如n=2m。那样的话，所有的子列表都可以被均匀地分为两部分。

不幸的是，下面公式：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07775.jpeg)

并不能清晰地告诉我们n和T(n)的关系。为了理解这个关系，使用同样的公式估计一下T(n/2)：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07776.jpeg)

因此

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07777.jpeg)

重复这个步骤：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07778.jpeg)

所以

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07779.jpeg)

从2、4、8一般化到2的任意次幂：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07780.jpeg)

前面我们假设n=2m，因此，对于k=m，

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07781.jpeg)

因为n=2m，我们有m=log2(n)。

为了确定增长的阶，我们丢弃n的低阶项，只留下5nlog2(n)。把常数因子5也丢弃，按惯例把对数函数的底也丢弃，因为所有对数函数之间只差一个常数因子。例如，

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07782.jpeg)

因此，我们说归并排序是一个O(nlog(n))算法。

O(nlog(n))的归并排序算法比O(n2)的选择排序算法好吗？确实是这样的。还记得使用O(n2)算法对一百万条记录进行排序所需要的时间是10 000条记录的102=10 000倍。使用O(nlog(n))算法的话，这个比值是：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07783.jpeg)

现在假设对10 000条记录的话，归并排序使用的时间和选择排序是一样的，也就是在作者测试机上使用9秒时间。（实际上要比这个时间快得多。）那么对一百万条记录进行排序的话，它大概需要9×150秒，也就是大概23分钟。而选择排序执行同样的任务则需要一天多。如你所见，即使花上几个小时的时间来学习一个好的算法，这个时间花得也是值得的。

在本章中，我们只是蜻蜓点水般地介绍了一下这个有意思的话题。还有很多排序算法，甚至有一些比归并排序算法的性能还好，并且这些算法的分析也是相当具有挑战性的。这些重要的话题通常会在后续的计算机科学课程中进行讲解。在配套源码可以找到测试归并排序算法执行时间的程序ch12/sec05/mergetimer.py。

自测题

16.已知本节开头表格中归并排序算法的运行时间数据，那么对包含100 000个值的列表进行排序需要多长时间？

17.如果把列表的大小变为两倍，归并排序算法对新列表进行排序需要多长时间？

练习它　现在你可以尝试本章最后的练习：R12.5，R12.14，R12.16。

专题12.3　快速排序算法

快速排序是一种常用的算法，和归并排序算法相比，快速排序算法不需要排序的临时列表，也不需要对中间生成的部分结果进行合并。

和归并排序一样，快速排序算法也是基于分治法的策略。为了对列表values中的元素values[start]…values[to]进行排序，首先重新排列这个范围内的元素使得values[start]…values[p]这个范围内没有元素大于values[p+1]…values[to]这个范围内的任何元素。这个步骤叫作切分。

例如，假设我们要处理下面的范围：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07784.jpeg)

下面是这个范围的切分，注意这个切分的结果不是排好序的。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07785.jpeg)

后面你会看到如何得到这样一个切分。接下来，对每个切分进行排序，在两部分上递归使用同样的算法。那样就会对整个范围进行排序，因为第一部分中的最大元素最多也就是和第二部分中的最小元素一样大。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07786.jpeg)

快速排序是使用下面的递归来实现的：

![](../Images/image07787.gif)

让我们回到对一个范围进行切分的问题上。从这个范围中选择一个元素，把它叫作枢点。快速排序算法有好几种变型。其中最简单的一种，是选择这个范围的第一个元素values[start]作为枢点。

现在构成了两个区域，values[start]…values[i]包含那些至多和枢点一样大的值，而values[j]…values[to]包含那些至少和枢点一样大的值。区域values[i+1]…values[j-1]中包含那些还没有分析的值。在最开始的时候，左右两个区域都是空的，也就是说i=start-1并且j=to+1。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07788.jpeg)

对一个范围进行切分

然后，如果values[i]<；pivot就一直增加i，如果values[j]>；pivot就一直减少j。下图显示了这个过程结束时i和j的值。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07789.jpeg)

对切分进行扩展

现在交换位置i和j上的元素，再一次增加两个区域。当i<；j时重复这个过程。下面是partition函数的代码：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07790.jpeg)

平均而言，快速排序算法是O(nlog(n))算法。快速排序算法只有一个不太好的方面，就是在最坏情况下退化为O(n2)算法。如果选择区域内第一个元素作为枢点，并且输入的数据集是已经排好序的，就出现了最坏情况——实际应用中经常发生的一种情况。如果使用更聪明的方法选择枢点，我们可以极大降低最坏情况出现的概率。这样改良过的快速排序算法是最常使用的，因为它们的性能通常都非常好。

在实际应用中常做的另一个改进是列表较短时切换为插入排序，因为对于短列表而言使用插入排序需要的操作总数量要少一些。在配套源码文件ch12/special_topic_3/quickdemo.py中可以找到演示快速排序算法的程序。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07791.jpeg)

在快速排序中，把所有元素切分为两组，分别存储较小元素和较大元素，然后对每一组进行排序