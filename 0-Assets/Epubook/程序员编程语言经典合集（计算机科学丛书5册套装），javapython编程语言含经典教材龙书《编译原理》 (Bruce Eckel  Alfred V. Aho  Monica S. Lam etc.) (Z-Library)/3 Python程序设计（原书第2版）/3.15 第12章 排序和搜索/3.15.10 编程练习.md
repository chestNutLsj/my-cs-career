   

## 编程练习

■P12.1　修改选择排序算法，对一个包含整数的列表进行降序排列。

■■P12.2　编写一个程序自动生成选择排序算法的运行时间采样表。程序应该要求输入n的最小值和最大值，以及测量的数量，然后运行所有采样。

■P12.3　修改归并排序算法，对一个列表进行降序排序。

■P12.4　编写一个电话号码簿查询程序。从包含随机排序电话号码的文件中读取1000个姓名和电话号码。按姓名进行查询并按电话号码反向遍历。对两个查询都使用二分搜索。

■■P12.5　实现一个测量专题12.2中描述的插入排序算法性能的程序。

■P12.6　实现练习R12.19中描述的冒泡排序算法。

■■P12.7　实现12.7.4节描述的算法，但是只记录目前位置出现频率最高的值：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07860.jpeg)

■■P12.8　根据Bentley和McIlroy，实现下面对快速排序算法的改进。不使用第一个元素作为枢点，而是使用中值的近似值。（使用真实的中值会得到O(nlog(n))算法，但是我们不知道如何足够快地计算。）

如果n≤7，使用中间位置上的元素。如果n≤40，使用第一个、中间和最后一个元素的中值。否则，计算九个元素values[i*(n-1)//8]的“伪中值”，其中i的取值范围是从0到8。9个值的伪中值为med(med(v0，v1，v2)，med(v3，v4，v5)，med(v6，v7，v8))。

把这个修改的运行时间和原始算法进行比较，分别使用几乎已经排好序的或者几乎已经反序排序的或者有很多相等元素的列表。你有什么发现？

■■■P12.9　对于包含很多重复元素的数据集，Bentley和McIlroy提出了对快速排序算法的修改。

不使用

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07861.jpeg)

进行切分（其中≤表示那些≤枢点的元素），使用下面的运算进行切分更好：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07862.jpeg)

然而，那很难直接实现。他们建议使用下面的运算进行切分：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07863.jpeg)

然后在中间交换两个=区域。实现这个修改，检查对于有很多重复元素的数据集这个算法是否能够提高性能。

■P12.10　使用练习R12.20中描述的基数排序算法对包含0到999之间数字的列表进行排序。

■P12.11　使用练习R12.20中描述的基数排序算法对包含0到999之间数字的列表进行排序，只使用1个辅助列表，而不是使用10个。

■■P12.12　使用练习R12.20中描述的基数排序算法对包含任意整数（正数或负数）的列表进行排序。

■■■P12.13　编写程序对包含Country对象的降序排列的列表进行排序，使得人口最多的国家排在列表的前面。

■P12.14　实现12.6.2节的binarySearch函数，不使用递归。

■■P12.15　考虑12.6.2节的二分搜索算法。如果没有找到匹配项，binarySearch函数返回-1。修改算法，如果没有找到target就返回-k-1，其中k是元素应该插入的位置。

■■P12.16　实现归并排序算法，不使用递归，其中列表的长度是2的幂。首先合并大小为1的相邻区域，然后合并相邻的大小为2的区域，然后是大小为4的相邻区域，以此类推。

■■■P12.17　实现归并排序算法，不使用递归，其中列表长度是任意数字。持续合并大小为2的幂的相邻区域，并且考虑最后一个小的区域。

■■■P12.18　使用插入排序和练习P12.15的二分搜索函数，对练习R12.18中描述的列表进行排序。实现这个算法并测量它的性能。

■P12.19　提供一个类Person实现比较运算符。按名字比较多个Person对象。要求用户输入10个名字并生成10个Person对象。确定并输出第一个和最后一个人。

■■P12.20　按长度对一个包含字符串的列表进行排序。

■■■P12.21　对一个包含字符串的列表按长度排序，相同长度的字符串按字典顺序进行排序。

自测题答案

1.丢弃temp变量就不能工作了，那时values[i]

和values[minPos]会以同样的值结束。

![](../Images/image07864.gif)

3.在每一步中，查找剩余元素的最大值，把它与当前元素进行交换（或者见自测题4）。

4.修改后的算法对列表按降序排列。

5.40 000个值的时间的4倍，或者大约600秒。

6.一条抛物线。

7.大概需要100倍。

8.如果n是4，那么![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07865.jpeg)是8，![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07866.jpeg)是7。

9.2×(n-i-1)

10.平均而言，i是n/2。O(2×(n-n/2-1))=O(n)。

11.我们需要检查values[0]≤values[1]，values[1]≤values[2]，以此类推，访问2n-2个元素。因此，运行时间为O(n)。

12.假设n为列表长度。在第k步中，我们需要k次访问才能找到最小值。为了删除它，我们平均需要k次访问。（精确的数字对大O效率没有影响。）把它加入到尾部需要一次额外的访问，我们也可以忽略它。因为k从n到2变化，总访问次数大概为2n+2(n-1)+…+4=n2+n-2。因此，访问总次数为O(n2)。

13.前一个while循环结束时，循环条件必须为False，也就是说，iFirst>；=len(first)或者iSecond>；=len(second)（德摩根定律）。

14.首先对8 7 6 5进行排序。递归地，首先排序8 7。递归地，首先排序8。它已经排好序了。对7进行排序，它也排好序了。合并它们：7 8。对6 5进行同样的处理，得到5 6。归并它们得到5 6 7 8。对4 3 2 1进行同样的处理：通过对4和3排序并进行合并得到3 4。通过对2和1进行排序并合并得到1 2。合并3 4和1 2得到1 2 3 4。最后合并5 6 7 8和1 2 3 4得到1 2 3 4 5 6 7 8。

15.如果列表大小为1，返回它的唯一元素作为和。否则，递归计算第一个和第二个子列表的和并返回这两个值的和。

16.大概是50 000个值需要的时间的(100 000·

log(100 000)/(50 000·log(50 000))=2·5/4.7=2.13倍。也就是2.13·0.599=1.275秒。

17.![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07867.jpeg)

18.平均而言，你要进行500 000次比较。

19.linearSearch函数返回匹配项的索引，而不是该位置上的数据。

20.你会搜索20次。（1024以2为底的对数是10。）

21.

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07868.jpeg)

22.这是一个O(n)算法。

23.这是一个O(n2)算法——访问次数遵守三角模式。

24.对列表排序，然后执行线性搜索来检查相邻的重复项。

25.这是一个O(n2)算法——外循环和内循环都有n次迭代。

26.因为一个n×n的列表有m=n2个元素，应用于m个元素的列表时，12.7.4节的算法是O(mlog(m))算法，我们就得到一个O(n2log(n))算法。回顾log(n2)=2log(n)，因子2在大O表示法中不起作用。