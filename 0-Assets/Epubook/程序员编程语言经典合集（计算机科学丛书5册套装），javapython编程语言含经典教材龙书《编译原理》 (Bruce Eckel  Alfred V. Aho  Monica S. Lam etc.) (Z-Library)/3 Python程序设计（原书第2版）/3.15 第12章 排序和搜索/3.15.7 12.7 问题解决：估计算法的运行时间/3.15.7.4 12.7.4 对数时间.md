   

### 12.7.4　对数时间

对数时间估计来自于在每一步中把工作减半的算法，比如二分搜索和归并排序。

特别地，当你在一个算法的某个阶段使用排序或二分搜索的时候，在进行大O估计时你会遇到对数。

考虑这样一个用来改进查找出现次数最多的元素的算法。假设我们首先对列表进行排序：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07818.jpeg)

那会耗费O(nlog(n))时间。如果我们能在O(n)时间甚至O(nlog(n))时间内完成这个算法，我们就找到了比上一节中O(n2)算法更好的算法。

为了搞清楚为什么这是可行的，想象一下遍历这个排好序的列表。只要你发现一个等于前面值的值，就增加计数器。当你发现不同的值时，保存这个计数器并开始一个新的计数：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07819.jpeg)

或者，使用下面的代码来表示这个过程，

![](../Images/image07820.gif)

每次迭代中的工作量是个常数，即使会访问两个元素：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07821.jpeg)

2n仍然是O(n)的。这样，对于一个排好序的列表，我们可以在O(n)时间内完成计数。现在整个算法是O(nlog(n))的。

注意，实际上我们不需要保存所有计数器，只需要保存目前为止遇到的最大计数（见练习P12.7）。这是一个有价值的改进，但是并不影响运行时间的大O估计。

自测题

21.下面用于检查一个列表是否为回文的算法的灯泡模式是什么样的？

![](../Images/image07822.gif)

22.下面用来检查第一个元素在列表中是否有重复的算法，其大O运行时间是什么？

![](../Images/image07823.gif)

23.下面用来检查一个列表中是否有重复值的算法，其大O运行时间是什么？

![](../Images/image07824.gif)

24.描述一个用来检查一个列表中是否包含重复值的O(nlog(n))算法。

25.下面用来在一个n×n表格中查找一个元素的算法，其大O运行时间是什么？

![](../Images/image07825.gif)

26.如果把12.7.4节中的算法应用到一个n×n表格，查找出现次数最多的元素的大O效率是什么？

练习它　现在你可以尝试本章最后的练习：R12.9，R12.13，R12.19，P12.7。

编程小提示12.1　搜索与排序

在编写Python程序时，你不需要实现自己的排序算法。list类提供了一个sort方法可以用来对列表中的元素进行排序。

![](../Images/image07826.gif)

在Python的早期版本中，sort方法使用快速排序算法。在现在的版本中，使用插入排序和归并排序的混合算法。

你也可以使用in运算符搜索一个列表。因为这个运算符可以作用于排序列表和未排序列表，所以使用线性搜索算法来确定一个元素是否在列表中。为了在排好序的列表上执行二分搜索，你必须自己实现这个算法并替代in运算符。

专题12.4　比较对象

在应用程序中，你经常需要对对象集合进行排序或搜索。list类的sort方法可以对任意类型的数据进行排序，包括用户自定义类的对象。然而，那个方法不知道如何比较任意对象。例如，假设你有一个Country对象的列表。这些国家应该如何排序并不是很明显。它们应该按名字排序呢，还是按面积排序呢？sort方法不能帮你做出决定。相反，它需要这些对象能够使用<；运算符进行比较。

你可以为自己的类定义<；运算符（见9.11节）。例如，为了对一组国家进行排序，Country类需要实现__lt__方法：

![](../Images/image07827.gif)

![](../Images/image07828.gif)

这个方法决定self国家的面积是否小于otherCountry的面积。当列表被排序时，每次两个对象需要进行比较来决定哪个在前时就会调用这个方法。现在你就可以使用sort方法对一个包含Country对象的列表进行排序了。

编程实战12.1　增强插入排序算法

问题描述　实现一个以其发明者Donald Shell命名的希尔排序算法，改进专题12.2中的插入排序算法。

希尔排序是一个增强版的排序算法，充分利用了这样一个事实：如果列表已经排好序的话，那么插入排序算法是一个O(n)算法。希尔排序把部分列表排好序，然后再对整个列表执行插入排序，使得最终的排序不用做太多工作。

希尔排序的一个关键步骤是把序列重新排列成行和列，然后对每一列单独排序。例如，如果列表是：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07829.jpeg)

我们把它组织为4列，得到

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07830.jpeg)

现在我们对每一列进行排序：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07831.jpeg)

再放到一起成为单个列表，我们得到：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07832.jpeg)

注意，列表不是完全排好序的，但是很多小一点的数现在在前面，而很多大一点的数是在后面的。

我们会重复这个过程，直到列表排好序。每一次，我们使用不同数量的列。希尔最初使用2的幂作为列的数量。例如，对于包含20个元素的列表，他提出使用16、8、4、2直到最后使用1列。对于一列而言，我们有简单的插入排序，所以我们知道列表会被排好序的。让人惊奇的是，前面的排序大幅度加速了这个过程。

然而，已经发现了更好的序列。我们会使用下面的序列作为列数：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07833.jpeg)

也就是说，对于包含20个元素的列表，我们首先执行一个13列的排序，然后4列的排序，最后是1列的排序。这个序列和众所周知的序列效果几乎一样好，但是更容易计算。

我们不会真的重新组织这个列表，而是计算每一列中元素的位置。例如，如果列数c为4，这4列在列表中的位置为：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07834.jpeg)

注意，连续列的元素彼此之间的距离为c。第k列是由values[k]、values[k+c]、values[k+2*c]等元素组成的。

现在我们对每一列使用插入排序算法进行排序。使用while循环改写外循环，原始算法为：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07835.jpeg)

外循环依次访问values[1]、values[2]等元素。在第k列，对应的序列是values[k+c]、values[k+2*c]等。也就是说，外循环变为：

![](../Images/image07836.gif)

在内循环中，我们依次访问values[j]、values[j-1]等元素。我们需要改为values[j]、values[j-c]等。内循环变为：

![](../Images/image07837.gif)

把所有事情组合到一起，我们得到下面的函数：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07838.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07839.jpeg)

现在我们已经准备好实现希尔排序算法了。首先，我们需要找出需要从列数序列中取出多少元素。我们生成这些值，直到它们超出要排序的列表的大小：

![](../Images/image07840.gif)

对于每个列数，我们对所有列进行排序：

![](../Images/image07841.gif)

这个性能有多好呢？让我们和快速排序以及插入排序比较一下：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07842.jpeg)

![](../Images/image07843.gif)

我们确保使用三种算法对同一个列表进行排序。同时，我们通过和快速排序算法的结果进行对比以检查希尔排序结果是正确的。

最后，我们和插入排序算法进行比较。

结果显示，与插入排序相比，希尔排序是一个巨大的改进：

![](../Images/image07844.gif)

然而，快速排序算法的性能还是比希尔排序算法好。基于这个原因，在实际应用中很少使用希尔排序算法，但是它仍然是一个效率惊人也有意思的算法。

你可能也发现了，希尔排序算法中原始的列大小很有意思。在shellSort函数中，把c=3*c+1替换为c=2*c，你会发现算法会比改进的序列多用3倍左右的时间。但是那仍然比简单的插入排序要快很多。

在配套源码中，你可以找到用来把希尔排序和快速排序以及插入排序进行比较的程序ch12/worked_example_1/shelltimer.py。

计算与社会12.1　第一位程序员

在便携式计算器和个人电脑出现之前，航海家和工程师使用机械加法机器、计算尺、对数函数与三角函数表来加速计算。不幸的是，手工计算出来的表非常不精确。数学家查尔斯·巴贝奇（1791—1871）认识到，如果能够造一台自动打印表格的机器，计算错误和排版错误就都可以避免了。于是，巴贝奇就开始着手开发这样一台机器，他把这台机器叫作差分机，因为它使用连续的差来计算多项式。例如，考虑函数f(x)=x3。写下f(1)、f(2)和f(3)等函数值。然后计算连续值之间的差：

![](../Images/image07845.gif)

![](../Images/image07846.gif)

重复这个过程，计算第二列中连续值之间的差，然后再重复一次：

![](../Images/image07847.gif)

现在所有的差都是一样的。你可以通过一种加法模式来计算函数值——需要知道这个模式边缘的值和常数差。你可以自己试一下：在一个表格上写出加亮的数字，通过把北方和西北方位置上的数字相加来填充其他数字。

这个方法非常诱人，因为人们知道机械加法机器已经有很长时间了。它们由表示数字的齿轮组成，每个轮上有10个齿，机器逐位处理进位。另一方面，机械乘法机器很脆弱也不可靠。使用自己的钱和政府补助金，巴贝奇成功构造了差分机的原型，又开始设计打印表格的机器。然而，由于资金问题和把这样的机器设计到要求的精度的巨大难度，最终没有成功。

在致力于差分机的同时，巴贝奇还酝酿了一个宏大的设想，他将其称作分析机。差分机只能执行有限的计算——不比现在的便携式计算器聪明。但是巴贝奇意识到这样一台机器是可以通过存储程序和数据进行编程的。分析机的内部存储包含1000个寄存器，其中每个有50位十进制数。程序和常数被存储在穿孔卡片上——在当时用于编织带图案纺织物的织布机上常用的一种技术。

艾达·奥古斯塔·洛夫莱斯伯爵（1815—1852），拜伦勋爵唯一的孩子，是查尔斯.巴贝奇的朋友和支持者。艾达·洛夫莱斯是早期意识到这样一台机器潜能的人之一，不仅可以用于计算数学表格，还可以用于处理非数字的数据。她被很多人认为是世界上第一位程序员。