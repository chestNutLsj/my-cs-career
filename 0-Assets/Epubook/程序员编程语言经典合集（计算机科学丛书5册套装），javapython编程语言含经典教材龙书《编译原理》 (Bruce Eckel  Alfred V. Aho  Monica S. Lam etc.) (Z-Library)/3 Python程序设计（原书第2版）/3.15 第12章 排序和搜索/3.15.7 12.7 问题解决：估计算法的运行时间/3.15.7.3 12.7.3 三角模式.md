   

### 12.7.3　三角模式

我们能对上一节中的算法进行加速吗？对于已经统计的元素，再统计一次看上去非常浪费。那么我们可以通过删除相同元素的重复统计来节省时间吗？也就是说，在统计values[i]之前，我们应该先检查一下它在values[0]…values[i-1]中没有出现过吗？

我们来估计一下这些附加检查的代价。在第i步中，这个工作量和i成比例。这和上一节的情况并不完全一样，在上一节中，对于n次迭代的循环，每次循环需要的时间为O(n)，总时间为O(n2)。现在每个步骤只需要O(i)的时间。

为了对这种情况有个直观的认识，再来看一下这些灯泡。在第二次迭代中，我们再次访问values[0]。在第三次迭代中，我们再次访问values[0]和values[1]，以此类推。灯泡的模式为：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07816.jpeg)

如果一共有n个灯泡，正方形中有一半灯泡是亮的，或者说是n2/2个。很不幸，需要的时间仍然是O(n2)。

下面是另一个节省时间的想法。当我们统计values[i]时，不需要对values[0]…values[i-1]进行统计。如果values[i]在前面从来没出现过，我们通过查看values[i]…values[n-1]就可以得到精确的计数。如果之前出现过，我们已经有精确的计数了。这样的处理方式会有帮助吗？实际上没有——它也是三角模式，只不过这次是在另一个方向上。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07817.jpeg)

那并不意味着这些改进是没有意义的。如果O(n2)是某个特定问题最好的时间，你仍然想让它尽可能快一些。然而，我们不会继续追求这个方案了，因为我们可以做得更好。