   

### 12.7.2　二次时间

现在我们来看一个更有趣的情况。如果在每次访问时要做大量工作，又如何呢？这里有个例子。我们想在一个列表中查找出现次数最多的元素。

假设列表是：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07810.jpeg)

很明显，看一下这些值就可以知道，7是出现最频繁的一个。但是现在假设列表中包含几千个值：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07811.jpeg)

我们可以数一下8出现了多少次，然后数一下7出现了多少次，等等。例如，在第一个列表中，8出现了一次，7出现了3次。我们把计数器放在哪里呢？让我们放进同样长度的第二个列表中。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07812.jpeg)

然后我们在计数器列表中选取最大值，也就是3。再看一下3出现在计数器的什么位置，找到对应的值。这样，最常见的值就是7了。

让我们首先估计一下计算计数器需要多长时间。

![](../Images/image07813.gif)

我们仍然每个列表元素访问一次，但是每次访问要做的工作就大多了。在上一节你已经看到，每个计数操作是O(n)的。这样我们在每一步中执行一个O(n)的工作，总运行时间是O(n2)。

这个算法有3个阶段：

1.计算所有计数器。

2.计算最大值。

3.在计数器中查找最大值。

我们已经知道第一个阶段是O(n2)的。计算最大值是O(n)的——查看6.3.4节的算法并注意每一步涉及固定数量的工作。最后，我们刚刚已经看到了，查找一个值是O(n)的。

已知每一阶段的大概运行时间，我们如何估计总的运行时间呢？当然，总运行时间是那些独立的时间的和，但是对于大O估计，我们会选取所有估计值的最大值。为了搞清楚原因，假设我们已有每个运行时间的精确方程：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07814.jpeg)

那么它们的和是：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07815.jpeg)

但是其中起决定作用的是最高次项，所以T(n)是O(n2)的。

这样，我们可以得出结论，用于查找出现次数最多的元素的算法是O(n2)的。