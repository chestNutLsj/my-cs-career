   

## 12.3　分析选择排序算法的性能

我们来数一下使用选择排序算法对一个列表进行排序时程序必须执行的操作的次数。我们并不知道每个Python指令会生成多少机器操作，或者那些指令中的哪些更加耗时，但是我们可以做一个简化。我们会数一下列表元素多久被访问一次。每次访问大概需要同样多的工作量，例如增加索引和比较值。

用n表示列表的大小。首先，我们必须找到n个数的最小值。为了实现这一点，我们必须访问n个列表元素。然后交换元素，这需要两次访问。（你可能会说有时候我们并不需要交换值。确实是那样的，可以改进算法来表现那个观察结果。我们很快就会看到，这样做并不影响整体的结论。）下一步中，我们只需要访问n-1个元素就可以找到最小值。再下一步中，只需要访问n-2个元素就可以找到最小值。最后一步访问两个元素就可以找到最小值。在每一步中交换元素需要两次访问。因此，访问的总次数为：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07740.jpeg)

因为

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07741.jpeg)

把式子展开并进行同类项合并，我们会发现访问的次数为：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07742.jpeg)

我们得到了n的一个二次方程。那就解释了为什么图12-1中图看起来近似于一个抛物线。

现在进一步简化这个分析。当n非常大时（例如，1000或者2000），那么![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07743.jpeg)是500 000或者2 000 000。而较低阶的项![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07744.jpeg)的贡献则小得多。它只有2497或者4997，与![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07745.jpeg)所涉及的几十万甚至上百万次比较相比，简直就是九牛一毛。我们会直接忽略低阶的项。接下来，我们会忽略常数系数![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07746.jpeg)。我们不关心对于单个n所涉及的访问的实际次数。我们想做的是比较对于不同的n值所涉及的访问次数之间的比值。例如，我们可以说，对2000个数进行排序需要的时间是1000个数的4倍：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07747.jpeg)

在这种比较中，系数![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07748.jpeg)被约掉了。我们可以简单地说“访问次数是n2阶的”。这样我们很容易能看出来，如果列表大小翻倍的话，比较的次数增长4倍：(2n)2=4n2。

为了表示访问次数是n2阶的，计算机科学家使用大O表示法：访问次数是O(n2)。这是个很方便的速记法。（正式定义见专题12.1。）

为了把形如

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07749.jpeg)

的多项式转换为大O表示法，简单地定位增长最快速的项，n2，忽略常数系数，而不管这个系数有多大或有多小。

我们前面已经观察到，机器操作的实际数量以及机器执行那些操作所需要的实际时间，大概与元素访问的数量成比例。可能每次元素访问需要10个机器操作（增加、比较、内存加载和保存）。机器操作的数量大约是![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07750.jpeg)。和前面一样，我们不关心系数，所以我们说机器操作的次数和排序花费的时间是n2阶的，或者说是O(n2)。

让人沮丧的事实仍然是存在的，列表大小翻倍的话会导致选择法排序的时间变为4倍。列表大小变为100倍时，排序时间变为原来的10 000倍。为了对一百万个元素的列表（例如，创建一个电话号码簿）进行排序，耗费的时间是对10 000个元素所用时间的10 000倍。如果10 000个元素排序需要9秒钟（就像我们的例子一样），那么排序一百万个元素需要一天多。在下一节我们会看到，如何通过选择一个更加复杂的算法来大幅度提高过程的性能。

自测题

7.如果你把数据集大小增加为原来的10倍，那么使用选择排序算法的话，对其排序需要多长时间？

8.n需要多大才能使得![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07751.jpeg)比![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07752.jpeg)大？

9.考虑list类的remove方法。为了删除索引i处的元素，所有索引大于i的元素都必须进行移动。如果n表示列表的长度，那个过程中列表元素被访问多少次？

10.使用大O表示法描述调用remove方法时列表元素被访问的次数。假设删除操作发生在小于n（列表长度）的随机位置。

11.检查一个列表是否已被排序的大O运行时间是多少？

12.考虑这样一个用于对列表排序的算法。设置k为列表长度。查找前k个元素的最大值，删除它。（删除元素需要的访问次数见自测题9。）把k减1，把删除的元素放进第k个位置。当k为1时停止这个过程。使用大O表示法，这个算法的运行时间是多少？

练习它　现在你可以尝试本章最后的练习：R12.4，R12.7，R12.8。

专题12.1　Oh、Omega、和Theta

在本章我们已经用过几次大O表示法来描述函数的增长行为。这里是大O表示法的正式定义：假设我们有个函数T(n)，通常它表示对于给定大小为n的输入时一个算法所需要的处理时间，可以是任意函数。假设我们还有另外一个函数f(n)，通常是选择一个简单函数，例如f(n)=nk或者f(n)=log(n)，不过也可以是任意函数。我们写：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07753.jpeg)

如果T(n)的增长速度以f(n)为上限。更正式地说，我们要求，对于大于某个阈值的所有n，比值T(n)/f(n)≤C，其中C为某个常数。

如果T(n)是n的k次多项式，就可以说T(n)=O(nk)。在本章后面，我们会遇到O(log(n))或者O(nlog(n))的函数。有些算法则需要更多时间。例如，对一个序列进行排序的一种方式是计算它的所有排列，直到某个排列是升序的。这样的算法需要的时间为O(n!)，实在是糟透了。

表12-1显示了一些常见的大O表达式，按增长速度排序。

表12-1　常见大O增长速度

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07754.jpeg)

严格来说，T(n)=O(f(n))意味着T的增长速度不会超过f。但是T的增长速度可以慢得多。这样的话，说T(n)=n2+5n-3是O(n3)或者甚至说是O(n10)，从技术上来讲都是正确的。

计算机科学家已经发明了更多表示法来更精确地描述函数的增长行为。表达式：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07755.jpeg)

意味着T的增长速度至少和f一样，或者正式一点，对于大于某个阈值的所有n，比值T(n)/f(n)≥C，其中C为某个常数。（符号Ω是大写希腊字母omega。）例如，T(n)=n2+5n-3是Ω(n2)甚至是Ω(n)。

表达式：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07756.jpeg)

意味着T和f以同样的速度增长——T(n)=O(f(n))和T(n)=Ω(f(n))都成立。（符号Θ是大写希腊字母theta。）

Θ表示法给出了函数增长行为最精确的描述。例如，T(n)=n2+5n-3是Θ(n2)但不是Θ(n)或者Θ(n3)。

这些表示法对于算法的精确分析是非常重要的。然而，大O表示法用的是最多的，并且会给出一个尽可能好的估计。

专题12.2　插入排序

插入排序是另一种比较简单的排序算法。在这个算法中，我们假设初始序列：

![](../Images/image07757.gif)

是一个已经排好序的列表。（算法开始时，我们设置k为0。）我们通过在合适的位置插入下一个列表元素values[k+1]来扩大初始序列。当我们到达列表尾部时，排序过程结束。

例如，假设我们要处理下面的列表：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07758.jpeg)

当然，长度为1的初始序列是已经排好序的。我们现在增加values[1]，也就是9。这个元素需要插入到元素11的前面。结果是：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07759.jpeg)

接下来，我们增加values[2]，也就是16，这个元素不需要进行移动。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07760.jpeg)

重复这个过程，把values[3]或者5插入到初始序列的最前面。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07761.jpeg)

最后，values[4]或者7被插入到正确的位置，排序结束。

下面的函数实现了插入排序算法：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07762.jpeg)

这个算法的效率如何呢？用n表示列表的大小，我们执行n-1次迭代。在第k次迭代中，我们有一个大小为k的已经排好序的列表，并且需要在这个序列中插入一个新元素。对于每次插入，我们需要访问初始序列中的元素，直到找到新元素可以插入的位置。然后我们需要向上移动序列中的剩余元素，这样要访问k+1个列表元素。因此，访问总次数为：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07763.jpeg)

可以得知，插入排序算法也是一个O(n2)算法，和选择排序算法的效率是一样的。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07764.jpeg)

插入排序是很多人在打扑克时会使用的一种方法。每次取出一张扑克并插入合适位置使得扑克保持有序  

插入排序有个不错的性质：如果列表已经排好序的话它的性能是O(n)——见练习12.17。在实际应用中这是个有用的性质，因为很多数据集是部分排序的。在配套源码ch12/special_topic_2/insertiondemo.py中可以看到演示插入排序用法的程序。