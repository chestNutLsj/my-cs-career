   

### 7.5.3　finally子句

你偶尔会需要不论是否发生异常都要执行的操作，finally结构就是用来处理这种情况的。这里是一个典型的场合。

关闭输出文件以确保所有输出都写入文件，这一点非常重要。在下面的代码片段中，我们打开一个输出文件，调用一个或多个函数，然后关闭这个文件：

![](../Images/image06953.gif)

现在假设最后一行之前的某个方法或函数抛出了异常。那么close的调用永远不会执行。你可以把close调用放进finally子句来解决这个问题：

![](../Images/image06954.gif)

在正常情况下，不会有问题。当try块执行结束时，finally子句被执行，文件被关闭。然而，如果出现了异常，在把异常传递给处理程序之前，finally子句还可以得到执行。

语法7.4　finally子句

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image06955.jpeg)

在需要执行某些清理工作的任何时候，例如关闭文件，记得使用finally子句来确保不管方法如何退出都会执行清理工作。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image06956.jpeg)

所有到外国的访问者都不得不经过入境护照检查，不管旅途中发生了什么。类似地，finally子句中的代码总是能够得到执行，即使已经出现了异常  

自测题

22.假设balance是100，amount是200。执行下面的语句之后balance的值是什么？

![](../Images/image06957.gif)

23.往银行账号里存钱时，我们不需要担心透支，除非要存入的数量是负数。编写在那种情况能够抛出一个合适异常的语句。

24.考虑下面的程序

![](../Images/image06958.gif)

假设给定文件名对应的文件存在但是没有内容，跟踪程序的执行流。

25.下面的代码会抛出什么类型的异常，你需要如何修改代码来阻止？

![](../Images/image06959.gif)

26.下面的代码会抛出什么异常？为了避免程序终止你应该做什么？

![](../Images/image06960.gif)

练习它　现在你可以尝试本章最后的练习：R7.6，R7.7。

编程小提示7.1　早抛出，晚处理

当函数检测到它不能解决的问题时，最好是抛出一个异常，而不是试图引入一个不完美的修补。例如，假设一个函数预计从文件中读取一个数字，而这个文件并不包含数字。简单地使用0来代替并不是一个好的选择，因为这隐藏了真实的问题，并且可能在其他地方引发不同的问题。

相反地，一个函数应该只在能够真正解决问题的情况下处理异常。否则，最好的补救办法是简单地把异常传递给函数的调用者，允许被一个有能力的处理程序来捕获。

这些原则可以总结为一句俗语“早抛出，晚处理”。

编程小提示7.2　不要在一个try语句中同时使用except和finally

在一个或多个except子句后面紧跟一个finally子句是可能的。这样的话，无论try块中的代码以下面的3种方式的哪一种退出，finally子句里的代码都能得到执行：

1.执行完try块中最后一个语句之后。

2.执行完一个except子句中的最后一个语句之后，如果try块捕获一个异常的话。

3.try块中抛出异常但没有被捕获时。

组合使用except和finally看上去很诱人，但是最终的代码很难理解，并且通常是错的。相反，使用两个语句：

·一个try/finally语句来关闭资源

·一个独立的try/except语句来处理错误

例如，

![](../Images/image06961.gif)

这个嵌套的语句在open函数抛出异常时是可以正常工作的。（完成练习R7.17来确定为什么不能使用单个try语句。）

专题7.4　with语句

因为用于打开和关闭文件的try/finally语句很常用，Python提供了一个特殊的快捷方式：

![](../Images/image06962.gif)

with语句打开给定的文件，设置outfile为那个文件对象，在到达语句块尾部或抛出异常时关闭文件对象。

工具箱7.3　读取网页

Python标准库包含了处理互联网协议的工具。在这个工具箱中，我们会使用Python的urllib库中的一部分来打开网页并读取内容。

首先你需要有网页的URL（Universal Resource Locator，统一资源定位符）。那是一个以http://开头的地址，后面是网站位置。为了打开一个网页，使用urllib.request模块中的urlopen函数，就像：

![](../Images/image06963.gif)

这时得到一个“response”对象，你可以从中读取URL引用的数据。这可能是二进制数据（例如一个图像）或者文本（例如网页）。使用read方法可以得到字节形式的所有renponse对象数据：

![](../Images/image06964.gif)

如果你指定这个网页上是文本，使用decode方法把二进制数据转换为字符串：

![](../Images/image06965.gif)

这个方法调用假设文本使用的是UTF-8字符编码（见专题7.3）。如果不是的话，你可以指定编码格式的名字作为decode方法的参数。

如果你想每次查看一行文本，使用下面的循环：

![](../Images/image06966.gif)

当然，你也可以把文本保存为字符串并从中查找需要的信息。

例如，我们可能想查找到其他网页的所有链接。网页是使用一种叫作HTML（Hypertext Markup Language）的语言编写的，指向另一个页面的链接形式为：

![](../Images/image06967.gif)

下面的循环查找关键字href的所有出现。对于每一次出现，我们定位到它后面的引号里的字符串并输出。

![](../Images/image06968.gif)

如你所见，对于这个搜索，不需要把文本切分成行。实际上，那样做也不是个好主意，因为如果在href和链接之间换行的话我们可能会丢失这个链接。

如果你熟悉HTML，会意识到这个搜索有点过于简单了，会错过某个链接。练习P7.49给出了一个改进方法。

但是那只是个小细节而已。你现在已经知道如何从一个网页上收集所有链接了。如果你依次跟踪每一个的话，可以得到整个World Wide Web的一部分。那正是Google之类的搜索引擎做的事情。在第11章，你会看到如何完成一个类似的小规模任务。

读取一个网页内容之后，调用response对象的close方法来关闭链接。

![](../Images/image06969.gif)

在源码的ch07/toolbox_3/websearch.py中可以查看读取和搜索网页内容的完整程序。