   

## 11.7　互递归

在前面的例子中，一个函数调用自己来解决一个更简单的问题。有时，一组互相协作的函数或方法会使用递归的方式互相调用。在本节中，我们研究这样的互递归。这个技术比前面几节中讨论的简单递归要高级得多。

我们会开发一个程序来计算算术表达式的值，例如

![](../Images/image07682.gif)

这样的表达式的计算由于*和/的优先级高于+和-而变得复杂了，另外，圆括号可以用来组合子表达式。

图11-5显示一组描述这些表达式语法的语法图。为了看清楚这些语法图是如何工作的，考虑表达式3+4*5：

·进入expression语法图，箭头直接指向term，你没有别的选择。

·进入term语法图，箭头指向factor，你还是没有别的选择。

·进入factor语法图，你有两个选择：沿上面的分支或者下面的分支。因为第一个输入符号是数字3而不是(，沿下面的分支继续。

·接收输入符号，因为它是数字。现在没有处理的输入是+4*5。

·沿number出来的箭头到达factor的结束。就像在函数调用中一样，你现在回退，返回到term图中factor元素的结束位置。

·现在你有另一个选择——在term图中循环回去，或者退出。下一个输入符号是一个+，和要求循环回去的*或/都不匹配。所以退出，返回到expression。

·现在你又有一个选择，循环回去或者退出。现在+匹配循环中的一个选项。接收+作为输入并且移动回到term元素，剩余的输入为4*5。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07683.jpeg)

图11-5　对表达求值的语法图  

在这种方式下，表达式被分解为一系列使用+或-分隔的短语，每个短语又被分解为一系列由*或/分隔的因子，每个因子要么是一个圆括号括起来的表达式，要么是一个数字。你可以使用树来绘制这个分解过程。图11-6显示了表达式3+4*5和(3+4)*5是如何从语法图演变而来的。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07684.jpeg)

图11-6　两个表达式的语法树

语法图为什么能帮助我们计算这棵树的值呢？如果你看语法树，会发现它们精确表示了哪些运算先执行。在第一棵树中4和5应该相乘，然后结果应该再加上3。在第二棵树中，3和4应该相加，结果应该再乘以5。

在本节最后，你会看到一个对这些表达式求值的程序。这个程序使用tokenize函数把一个输入字符串分解为多个符号——数字、运算符和圆括号。（为了简单，我们只接收正整数作为数字，并且在输入中不允许有空格。）

为了计算一个表达式的值，我们实现了3个函数：expression、term和factor。函数expression首先调用term来获得表达式中第一个term的值，然后检查第二个输入符号是不是+或-。如果是的话就再次调用term并加/减它的值。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07685.jpeg)

函数term以同样的方式调用factor，乘以或除以这个因数值。

最后，factor函数检查下一个符号是不是(。如果不是，这个符号必须是一个数字，它的值也就是那个数字。然而，如果下一个符号是一个(，factor函数递归调用expression。这样，3个方法是互相递归的：

![](../Images/image07686.gif)

为了更清晰地看互递归，跟踪表达式(3+4)*5的计算过程：

·expression调用term

·term调用factor

·factor消耗掉(输入

·factor调用expression

—expression最终返回7，消耗掉3+4。这是一个递归调用。

·factor消耗)输入

·factor返回7

·term消耗掉输入*和5并返回35

·expression返回35

和往常的递归方案一样，你需要确保递归能够结束。在这里，在考虑expression调用自己的情况时很容发现这一点。第二次调用工作在比原始表达式短的子表达式上。每次递归调用中，至少消耗掉一些符号，所以最终这个递归一定会结束。

ch11/sec07/evaluator.py

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07687.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07688.jpeg)

程序运行结果

![](../Images/image07689.gif)

自测题

23.短语和因子之间的区别是什么？我们为什么需要两个概念？

24.为什么表达式求值器要使用互递归？

25.如果你试图对非法表达式3+*4-5进行求值，会发生什么？特别地，哪个函数会抛出异常？

练习它　现在你可以尝试本章最后的练习：R11.11，P11.16。

工具箱11.1　使用Beautiful Soup分析网页

网页是使用HTML编写的，也就是超文本标记语言。HTML页面由若干元素组成，元素则由包含在一对匹配的标签中的内容组成。这些标签告诉浏览器如何显示内容。不幸的是，网上并不是所有HTML页面都是良构的——通常会有丢失或不匹配的标签。浏览器会容忍一些小的错误，并且尽最大可能显示这些页面。但是对于需要分析网页的程序员来说，标签错误是非常让人恼火的。

在这个工具箱中，你会学习到一个叫作Beautiful Soup的Python库的基本用法，可以用来把“标签大杂烩”转换为良好嵌套的结构。（如果你还没有安装这个库，参考工具箱2.1。）

HTML页面从一个根元素开始。每个元素都可以拥有孩子。根元素有两个孩子，叫作head和body，而这些孩子元素自己又拥有孩子。下面是一个网页的例子：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07690.jpeg)

在这个例子中，body元素有两个孩子：一个段落和一个有序列表（分别使用标签名字p和ol）。有序列表有3个孩子，是其中的列表项（使用标签名字li）。

把包含HTML（例如一个网页）的字符串传递给Beautiful Soup时，你得到一个表示HTML文档的对象：

![](../Images/image07691.gif)

一般地，如果e是一个标签，那么e.contents是它的孩子列表。例如，

![](../Images/image07692.gif)

把这个页面的html元素保存在root中。现在你可以检查它的孩子了。然而，root.contents是一个包含5个孩子的列表：head和body元素，以及它们周围的文本，这里全都是空格。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07693.jpeg)

在练习P11.27中你会看到如何删掉这些空格。Beautiful Soup默认不会这样做，因为识别空格什么时候是文档文本以及什么时候是标签分隔并不总是很容易。

一个元素的孩子可以是标签和文本的混合。下面演示了如何区分它们：

![](../Images/image07694.gif)

如果child是一个标签，你可以通过child.name获取它的名字；如果它是一个文本元素，str(child)就是Python字符串形式的内容。

处理一个标签的属性（例如，超链接标签a的href属性）时，你可以使用[]运算符，就像使用字典一样：

![](../Images/image07695.gif)

通过递归访问孩子以及孩子的孩子，你可以遍历一个HTML文档来查找感兴趣的元素和属性——见练习P11.28。

因为查找元素是非常常用的操作，Beautiful Soup库为此提供一个函数。调用

![](../Images/image07696.gif)

可以得到标签名以a开头的所有元素。

编写网页爬虫

你可以使用Beautiful Soup库创建网页爬虫，一个能够浏览万维网并从网页上收集信息的程序。像Google这样的搜索引擎就使用网页爬虫来收集和索引网页内容来方便快速搜索。网页爬虫也被用来收集网页地址和页面上的链接来映射网上的一部分。

这里，我们准备编写一个网页爬虫来浏览网络并收集从给定页面出发能够在3步之内就可以到达的所有网页的地址。

为了实现这一点，你首先必须读取一个网页的完整内容并搜索该页面上指向其他网页的所有超链接，并在那些页面重复同样的过程，直到你已经遍历了3层链接。这很自然地要使用一个递归算法：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07697.jpeg)

为了跟踪搜索的距离或者深度，我们可以维护一个从初始页面开始并且每一步都减少的计数器。当计数器达到0时结束前向搜索。

我们的函数有3个输入：网页地址、从这个网页开始搜索的步数和一个用于保存爬取过程中遇到的网页的列表。

![](../Images/image07698.gif)

第一次调用这个递归函数时，main函数创建一个列表，用于保存后面爬取过程中遇到的网页地址。这个列表被crawl函数填充之后，输出它的内容显示爬取过程中遇到的URL：

![](../Images/image07699.gif)

在工具箱7.3中，你学习了如何打开一个网页并获取一个响应对象：

![](../Images/image07700.gif)

为了解析网页并查找所有超链接，你可以使用Beautiful Soup工具包提供的工具。

为了使用这个工具包，你要创建BeautifulSoup类（在bs4模块中定义）的一个实例并把打开网页得到的响应对象传递给它：

![](../Images/image07701.gif)

网页被自动读取和解码。如果连接服务器或者解析响应对象时遇到任何问题（例如，如果这个URL指向的是一个图像），会抛出异常。可以使用一个try/except块来跳过这样的URL。

为了查找该网页上的所有超链接，你可以使用find_all方法，返回一个包含链接的列表，每个元素对应于页面上找到的一个<；a>；标签。

![](../Images/image07702.gif)

这些工具可以用来实现下面显示的递归函数crawl。

ch11/toolbox_1/webcrawler.py

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07703.jpeg)