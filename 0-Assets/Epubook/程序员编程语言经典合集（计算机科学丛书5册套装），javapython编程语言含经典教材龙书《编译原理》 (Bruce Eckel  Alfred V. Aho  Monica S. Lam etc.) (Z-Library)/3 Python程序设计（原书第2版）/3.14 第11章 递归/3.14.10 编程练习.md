   

## 编程练习

■P11.1　给定一个带有实例变量width和height的类Rectangle，提供一个递归方法getArea。构造一个宽度比原始矩形小1的矩形并调用其getArea方法。

■■P11.2　给定一个带有实例变量width的类Square，提供一个递归getArea方法。构造一个宽度比原始正方形小1的正方形并调用其getArea方法。

■P11.3　编写用于翻转一个字符串的递归函数reverse(text)。例如，reverse("Hello!")返回字符串"!olleH"。通过删除第一个字符、翻转剩余文本然后在把两个合并来实现一个递归方案。

■■P11.4　重做练习P11.3，使用用于翻转文本子字符串的递归辅助函数。

■P11.5　使用迭代重新实现练习P11.3的reverse函数。

■■P11.6　使用递归实现一个函数：

![](../Images/image07704.gif)

用于测试给定文本是否包含一个字符串。例如，find("Mississippi"，"sip")返回True。

提示：如果文本以想要匹配的字符串开头，程序结束。如果不是，就考虑删除第一个字符得到的剩余文本。

■■P11.7　使用递归实现一个函数：

![](../Images/image07705.gif)

返回text中能够匹配string的第一个子字符串的起始位置。如果string不是text的子字符串就返回-1。例如，s.indexOf("Mississippi"，"sip")返回6。

提示：这比练习P11.6要麻烦一点，因为你必须记录匹配项与文本开始处的距离。把那个值作为一个辅助函数的参数。

■P11.8　使用递归查找一个列表中的最大元素。

提示：在除最后一个元素的子序列中查找最大元素，然后把那个最大值与最后一个元素比较。

■P11.9　使用递归计算一个列表中所有值的和。

■■P11.10　使用递归计算一个多边形的面积。切掉一个三角形，然后使用下面公式计算顶点为(x1，y1)、(x2，y2)和(x3，y3)的三角形面积

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07706.jpeg)

■■P11.11　下面的函数是古希腊用来计算平方根的函数。给定一个值x>；0和平方根的一个猜测g，一个更好的猜测是(g+x/g)/2。编写一个递归辅助函数def squareRootGuess(x，g)。如果g2近似等于x，就返回g，否则就返回更好猜测的squareRootGuess的值。编写一个函数def squareRoot(x)调用上面的辅助函数。

■■■P11.12　实现一个用来返回一个字符串所有子串的列表的函数substrings。例如，字符串"rum"的子串有7个：

![](../Images/image07707.gif)

提示：首先生成以第一个字符开头的所有子串。如果字符串长度为n，那么有n个子串。然后生成通过删除第一个字符得到的字符串的所有子串。

■■■P11.13　实现一个函数subsets返回包含一个字符串中字符所有子集的列表。例如，字符串"rum"中字符的子集有8个字符串：

![](../Images/image07708.gif)

注意，子集不必须是子串，例如，"rm"不是"rum"的子串。

■■■P11.14　在这个练习中，修改11.5节中permutations函数（该函数一次性计算所有排列），实现一个类PermutationIterator（每次计算一个排列）。

![](../Images/image07709.gif)

然后可以使用下面的代码输出字符串"eat"的所有排列：

![](../Images/image07710.gif)

现在你需要一种方式递归地迭代这些排列。考虑字符串"eat"。和前面一样，我们会生成以字母"e"开头的所有排列，然后生成以字母"a"开头的那些，最后生成以字母"t"开头的那些。我们如何生成以字母"e"开头的那些排列呢？创建另一个PermutationIterator对象（叫作tailIterator）来迭代子串"at"的排列。在nextPermutation方法中，简单地问一下它下一个排列是什么，然后在前面加上字母"e"即可。

然而，有个特殊情况。如果尾部生成器已经没有排列了，那么以当前字母开头的所有排列都被枚举过了。

那么

·增加当前位置。

·计算包含除当前字符之外的所有字符的尾部字符串。

·为尾部字符串创建一个新的排列迭代器。

如果当前位置已经到达字符串结束，任务就完成了。

■■■P11.15　下面的程序生成数字0、1、2、…、n-1的所有排列，没有使用递归。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07711.jpeg)

这个算法使用了这样一个事实，要排列的集合中所有数字都是唯一的。这样，你不能使用这个算法计算字符串中字符的排列。然而，你可以使用这个程序得到字符位置的所有排列，然后计算第i个字符是word[a[i]]的字符串。使用这个方法重新实现11.5节中的permutations函数，不使用递归。

■■P11.16　扩展11.7节中的表达式求值器，使得可以处理%运算符以及幂运算符^。例如，2^3的值应该为8。和数学上一样，幂运算的优先级应该比乘法高：5*2^3的值为40。

■■■P11.17　实现一个DiskMover类生成编程实战11.2中描述的汉诺塔的移动情况。提供方法hasMoreMoves和nextMove，其中nextMove方法应该产生一个描述下一步移动的字符串。例如，下面的代码输出把5个圆盘从钉子1移动到钉子3的所有移动：

![](../Images/image07712.gif)

提示：把单个圆盘从一个钉子移动到另一个钉子的圆盘移动器只有一个返回下面字符串的nextMove方法：

![](../Images/image07713.gif)

有多于一个圆盘需要移动的圆盘移动器必须努力工作。它需要另一个DiskMover帮忙移动前d-1个圆盘。nextMove方法询问那个圆盘移动器下一步如何移动，直到任务完成。然后nextMove发起一个命令移动第d个圆盘。最后，它再创建另一个圆盘移动器来生成剩余移动。

跟踪圆盘移动器的状态是有帮助的：

·BEFORE_LARGEST：辅助移动器把上面的一小堆移动到另一个钉子。

·LARGEST：把最大的圆盘从源移动到目的地。

·AFTER_LARGEST：辅助移动器把上面的小堆从另一个钉子移动到目的地。

·DONE：所有移动均已完成。

■■■P11.18　迷宫逃脱。你现在正处于一个迷宫内部，迷宫的墙使用星号（*）表示。

![](../Images/image07714.gif)

使用下面的递归方法检查你是否可以从迷宫中逃脱：如果你正处于出口，返回True。递归检查你是否可以从一个空的邻居位置逃脱，而不访问当前位置。这个函数只测试是否存在一条出迷宫的路径。如果你能输出一条到达出口的路径，额外加分。

■■■P11.19　回溯算法可用于任何部分方案可以检查和扩展的问题。提供一个带有方法examine和extend的PartialSolution类，再为其提供一个solve方法，和一个子类EightQueens

PartialSolution并提供具体的examine和extend方法。

■■■P11.20　使用练习P11.19中的PartialSolution类和solve方法，提供一个类MazePartialSolution用于解决练习P11.18中的迷宫逃脱问题。

■■■P11.21　改进用于解决八皇后问题的程序，不显示已显示方案的旋转和对称方案。你的程序应该输出12种唯一的方案。

■■■P11.22　改进用于解决八皇后问题的程序，把得到的方案写入一个HTML文件，使用黑白背景色的表格表示棋盘，使用Unicode字符♕"\u2655"表示皇后。

■■P11.23　改进用于解决八皇后问题的程序，使其适用于n皇后问题。你的程序应该提示用户输入n的值然后显示这些方案。

■■P11.24　使用回溯法，编写程序解决求和之谜游戏，其中每个字母应该替换为一个数字，例如

![](../Images/image07715.gif)

其他的例子还有base+ball=games和kyoto+osaka=tokyo。

■■P11.25　通过记录已经计算出来的值，可以大幅度提高递归计算斐波那契数列的速度。提供一个使用这个策略的fib函数实现。返回一个新值时，同时保存到一个辅助列表中。而在着手一个计算时，首先查询列表看一下这个结果是否已经计算过了。比较一下三种方案的运行时间：刚刚改进的实现，原始递归实现，和循环实现。

■■■图形P11.26　科赫雪花。科赫雪花的形状是由下面的步骤递归定义的。从一个等边三角形开始：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07716.jpeg)

接下来，把大小变为原来的3倍，并把每条直线替换为4个线段：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07717.jpeg)

重复这个过程：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07718.jpeg)

编写程序绘制雪花形状的迭代。提示用户按回车键查看生成的下一个迭代的形状。

■■■工具箱P11.27　编写一个函数，删除使用Beautiful Soup（见工具箱11.1）读取的HTML文档中可忽略的空格。忽略出现在两个元素之间的空格，除非它与这些元素相邻：

![](../Images/image07719.gif)

（这些元素在HTML中称作“内联元素”，因为它们可以包含在文本内容中。）

■■工具箱P11.28　重新实现Beautiful Soup的find_all方法，编写一个函数接收HTML标签作为字符串，返回一个包含带有给定标签名的所有后代标签的列表。要求在方案中使用递归。

自测题答案

1.假设我们略去该语句。计算边长为1的三角形面积时，我们会计算边长为0的三角形面积为0，然后加上1，也可以得到正确答案。

2.你会递归计算更小的面积，然后返回：

![](../Images/image07720.gif)

当然，简单地使用sideLength*sideLength会更简单一些，并且结果是一样的，因为：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07721.jpeg)

3.没有停止递归的条项。对于一个小于10但不是8的数字，函数应该返回False然后停止。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07722.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07723.jpeg)

6.在这个问题中，任何分解都会正常工作。我们可以删除第一个或最后一个字符，然后从剩余部分删除标点符号。或者我们可以把字符串分解为两个子字符串，然后从每个子字符串中删除标点符号。

7.如果最后一个字符是标点符号，那么你可以简单地删除标点符号并返回更短的字符串。否则，就把最后一个字符附加到那个结果后面再返回。

8.最简单的输入是空字符串。它不包含标点符号，所以简单地返回即可。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07724.jpeg)

10.只有一个函数可以使用给定的名字。为了区分两个函数，其中一个必须叫作另外的名字。这里我们选择substringIsPalindrome是因为它用来测试子字符串。

11.当start>；=end时，也就是说，待测试的字符串要么为空，要么长度为1。

12.函数sumHelper(a，start)把a[start]和sumHelper(a，start+1)加到一起。

13.sum(a)可以计算a[0]+sum(a[1：])。但是在每一步中都使用切片的效率是很低的。

14.循环略快一些。简单地计算width*(width+1)/2会更快一些。

15.不，递归方案和迭代方法效率差不多。为了计算n!，两个方法都需要n-1次乘法。

16.递归算法和循环差不多。和递归的斐波那契算法不一样，这个算法不在同样的输入上再次调用自己。例如，列表[1，4，9，16，25，36，49，64]的和计算为[1，4，9，16]与[25，36，49，64]的和，那么作为[1，4]、[9，16]、[25，36]与[49，64]的和，这些都可以直接计算。

17.它们是：在eat的6个排列的前面都加上字母b，bat的6个排列的前面都加上字母e，bet的6个排列的前面都加上字母a，bea的6个排列前面都加上字母t。

18.把if len(word)==0改为if len(word)<；=1，因为单个字母的单词也是自己的一个排列。

19.迭代方案会有一个循环，其循环体根据上一个排列来计算下一个排列。但是没有明显的机制用来获取下一个排列。例如，如果你已经发现排列eat、eta和aet，你如何使用这个信息来获取下一个排列并不明显。实际上，有个聪明的机制可以做那个，但是很不明显——见练习P11.15。

20.我们想要检查任何queen[i]是否会攻击queen[j]，但是攻击是相互的。也就是说，我们选择只比较i<；j的那些（或者，使用i>；j也是一样的）。当i等于j时我们不调用attacks函数，直接返回True即可。

21.其中一个方案是：

![](../Images/image07725.gif)

22.有两个方案：一个来自自测题21，一个是它的镜像图。

23.因子通过乘性运算符（*和/）组合，短语通过加性运算符（+和-）组合。我们需要两个术语以便乘法可以先于加法进行计算。

24.为了处理带圆括号的表达式，例如2+3*(4+5)，子表达式4+5通过递归调用expression进行处理。

25.试图计算3+*时，expression函数会抛出异常，因为星号被包含在符号列表中，就像一个数字一样。