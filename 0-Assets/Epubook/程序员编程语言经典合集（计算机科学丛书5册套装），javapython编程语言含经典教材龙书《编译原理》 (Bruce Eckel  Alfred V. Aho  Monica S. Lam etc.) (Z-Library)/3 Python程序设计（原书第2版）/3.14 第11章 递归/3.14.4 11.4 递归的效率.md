   

## 11.4　递归的效率

你已经看到，递归是用来解决复杂问题的强有力工具。另一方面，递归可能会导致算法效率很低。在本节中，我们会分析递归何时有用以及何时低效。

考虑斐波那契数列：一个由下面公式定义的数列

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07633.jpeg)

也就是说，数列中的每个值都是前两个值的和。该数列中的前十项为

![](../Images/image07634.gif)

很容易对这个数列进行无限扩展，只需要一直把数列的最后两个值的和添加到数列尾部即可。例如，下一项是34+55=89。

我们可以编写一个函数计算任意值n对应的fn，下面我们把定义直接转换为一个递归函数：

ch11/sec04/recursivefib.py

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07635.jpeg)

程序运行结果

![](../Images/image07636.gif)

上面的思路确实很简单，函数也能正常工作。但是运行测试程序时自己观察一下输出。前几次调用fib函数非常快。然而，对于大数，程序在两次输出之间会停顿很长时间。

那样是没有意义的。如果有铅笔、纸和便携式计算器，你也可以很快地计算这些数字，就没必要使用计算机了。

为了发现这个问题，让我们在函数中插入一些跟踪信息：

ch11/sec04/recursivefibtracer.py

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07637.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07638.jpeg)

程序运行结果

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07639.jpeg)

图11-1显示计算fib(6)的递归调用模式。现在函数为什么需要那么长时间就很明显了，它一次又一次地计算同样的值。例如，计算fib(6)时调用了两次fib(4)和3次fib(3)。这和我们使用笔和纸可能进行的计算有很大不同。使用笔和纸的话，我们会写下已经计算出来的值，然后把最后两个值加起来得到下一个值，直到达到期望的那一项。那样不会有数列中的哪个值被计算两次。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07640.jpeg)

图11-1　递归函数fib的调用模式

如果我们模仿使用笔和纸计算的过程，可以得到下面的程序：

ch11/sec04/loopfib.py

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07641.jpeg)

程序运行结果

![](../Images/image07642.gif)

![](../Images/image07643.gif)

这个函数比递归版本的函数运行速度快多了。

在这个fib函数的例子中，递归方案很容易编写程序，因为它严格遵守数学定义。但是运行起来比迭代方法慢很多，因为很多中间结果被计算了很多次。

总是可以通过改写为循环来加速递归方案吗？迭代方案和递归方案往往在本质上具有同样的性能。例如，下面是回文测试的迭代方案：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07644.jpeg)

这个方案使用两个索引变量：start和end。第一个索引从字符串开始处开始，当一个字母被匹配或一个非字母被忽略时，该索引就加1。第二个索引从字符串结束处开始，并且朝字符串开始处移动。当两个索引变量相遇时，迭代结束。

迭代和递归运行速度大致相同。如果一个回文具有n个字符，迭代执行循环的次数介于n/2和n之间，依赖于有多少字符是字母，因为每一步中会移动一个或两个索引变量。类似地，递归方案调用自己的次数也介于n/2和n之间，因为在每一步中有一个或两个字符被删除。

在这样的场合，迭代可能会略快一点，因为每次递归函数调用会占用一定数量的处理器时间。在理论上，一个聪明的编译器可能会避免一些符合简单模式的递归调用，但是Python编译器并没有那么做。从这一点来看，迭代方案更可取一些。

然而，很多问题如果使用递归方案的话，会比迭代版本更加容易理解，也更容易正确实现。有时，根本就没有明显的迭代方案——见下一节中的例子。递归方案看起来更加优雅，也更容易实现，使得递归方案更有吸引力。就像计算机科学家（也是图形描述语言PostScript

解释器GhostScript的发明者）L.Peter Deutsch所说：“迭代是人，递归是神。”

自测题

14.对于计算三角数，是像11.1节中显示的那样递归计算快一些，还是使用计算1+2+3+…+width的循环更快一些？

15.对于阶乘函数，要么使用一个循环和定义n!=1×2×…×n，要么使用定义0!=1和n!=(n-1)!×n进行递归。这种情况下递归方法效率更低吗？

16.为了计算一个列表中所有值的和，你可以从中间把列表切开，递归计算两半的和，然后再把结果加起来。比较这个算法的性能和使用循环累加所有值的算法的性能。

练习它　现在你可以尝试本章最后的练习：R11.7，R11.9，P11.5，P11.25。