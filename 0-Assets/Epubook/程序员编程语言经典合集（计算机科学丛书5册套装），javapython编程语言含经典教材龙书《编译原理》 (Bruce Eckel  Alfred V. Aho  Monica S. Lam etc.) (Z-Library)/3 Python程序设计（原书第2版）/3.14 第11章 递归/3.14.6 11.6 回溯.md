   

## 11.6　回溯

回溯是一种问题解决技术，构建越来越接近目标的部分解决方案。如果一个部分解决方案无法完成，就拒绝它，然后返回去检查其他的候选方案。

回溯可以用来解决填字游戏、逃出迷宫或者查找由某些规则限定的系统的解决方案。为了在特定问题上使用回溯法，我们需要两个特征。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07660.jpeg)

在回溯算法中，挖掘出通往解决方案的所有路径。如果一个路径是死胡同，就需要退回去，然后尝试另一个选择

1.一个过程用来检查一个部分方案并决定是否

·接受它为实际方案。

·拒绝它（或者因为违背了某些规则，或者因为很明显不会产生一个有效方案）。

·继续扩展它。

2.一个过程用来扩展部分方案，生成一个或多个更接近目标的方案。

回溯法可以使用下面的递归算法来表示：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07661.jpeg)

当然，检查和扩展一个部分方案的过程依赖于问题的本质。

作为一个例子，我们会开发一个程序用来查找八皇后问题的所有解决方案：把八个皇后放到棋盘上，并且使得这些皇后在国际象棋的规则下不会互相攻击。换句话说，没有两个皇后在同一行、同一列或者同一对角线上。图11-2显示了一个方案。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07662.jpeg)

图11-2　八皇后问题的一个解决方案

在这个问题中，很容易检查一个部分方案。如果两个皇后互相攻击，就拒绝这个方案。否则的话，如果这个方案已经有8个皇后了，就接受它。否则就继续。

扩展一个部分方案也很容易。简单地在一个空的方格上放一个皇后。

我们把一个部分方案表示为一个字符串列表，其中每个字符串表示一个皇后在传统国际象棋棋盘上的位置。例如，

![](../Images/image07663.gif)

函数examine检查部分方案中是否有两个皇后互相攻击：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07664.jpeg)

函数extend接收一个部分方案，然后复制8份。每个副本得到一个在不同列的新皇后。

![](../Images/image07665.gif)

唯一还没解决的问题是两个皇后什么时候会在对角线上互相攻击。下面是一个检查那种情况的简单方法。计算斜率并检查是不是±1。

这个条件可以简化为：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07666.jpeg)

仔细看一下queens.py程序中的solve函数。这个函数是回溯法伪代码的直接翻译。注意这个函数中并没有针对八皇后问题的地方——它适用于任何带有examine和extend函数的部分解决方案（见练习P11.19）。

图11-3显示了用于解决四皇后问题的solve函数。从一个空白棋盘开始，在第一行放置皇后有4个部分方案①。如果该皇后放在第一列，那么在第二行放置一个皇后有4个部分方案②，其中有两个可以立刻丢弃，而另外两个可以产生具有3个皇后的部分方案③和④，除其中一个之外其他的也被丢弃了。一个部分方案被扩展为4个皇后，但是也被全部丢弃了⑤。然后算法回溯，放弃位置a1的皇后，而是在位置b1放置一个皇后并扩展这个方案（没有显示）。

我们的示例程序解决了八皇后问题。运行这个程序，它会列出92个方案，包括图11-2中显示的那个。练习P11.21要求删除互为旋转或对称的那些。

ch11/sec06/queens.py

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07667.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07668.jpeg)

图11-3　四皇后问题的回溯法

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07669.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07670.jpeg)

程序运行结果

![](../Images/image07671.gif)

自测题

20.在examine函数中j为什么从i+1开始？

21.继续跟踪图11-3中显示的四皇后问题。第一个皇后在位置a2的方案有多少个？

22.四皇后问题一共有多少种方案？

练习它　现在你可以尝试本章最后的练习：P11.19，P11.23，P11.24。

编程实战11.2　汉诺塔

汉诺塔问题有个带有3个钉子的模板，和一堆越来越小的圆盘，初始状态下这些圆盘在第一个钉子上（见图11-4）。

目标是把所有圆盘移动到第三个钉子上去。每次只能把一个圆盘从任意一个钉子移到其他任意钉子上，并且只能把小圆盘放到大圆盘的上面。

传说有个庙（应该是在汉诺）里有这样一个组合，上面有64个金盘，然后僧人按照上面描述的方法进行移动。当他们把这些圆盘全部移动到第三个钉子上的时候，世界末日就会来临。

问题描述　编写程序输出移动这些圆盘的所有指令。

考虑把d个圆盘从钉子p1移动到钉子p2，其中p1和p2是1、2或3，并且p1≠p2。因为1+2+3=6，我们可以获得剩余的一个钉子的索引为p3=6-p1-p2。

现在我们可以像下面这样移动这些圆盘：

·把上面的d-1个圆盘从p1移动到p3

·把一个圆盘（d个圆盘最下面的那个）从p1移动到p2

·把p3上的d-1个圆盘移动到p2

第一步和第三步需要递归处理，但是因为我们需要移动的圆盘越来越少，所以这个递归最终会结束。

把这个算法翻译成Python程序是很直观的。对于第二步，我们简单地为僧人把指令打印出来即可，就像：

![](../Images/image07672.gif)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07673.jpeg)

图11-4　汉诺塔

ch11/worked_example_2/towersofhanoimoves.py

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07674.jpeg)

程序运行结果

![](../Images/image07675.gif)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07676.jpeg)

这些指令对僧人来说可能已经足够了，但不幸的是，我们并不容易看明白正在发生什么。让我们改进一下程序，使得真正执行这些指令并显示每一步移动之后每个塔的内容。

我们把每个塔表示为圆盘的列表。每个圆盘表示为一个表示大小的从1到n的整数，也就是游戏中每个圆盘的编号。一共有3个塔，所以游戏配置是包含3个列表的列表，就像：

![](../Images/image07677.gif)

move函数首先进行移动，然后再显示这些塔的内容：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image07678.jpeg)

这里，索引值为0、1、2。因此，另一个钉子的索引为3-fromPeg-toPeg。

下面是main函数：

![](../Images/image07679.gif)

程序输出为

![](../Images/image07680.gif)

![](../Images/image07681.gif)

这样更好一些。现在你能看到这些圆盘是怎么移动的。你可以验证所有的移动都是合法的——圆盘大小是递减的。完整程序在文件ch11/worked_example_2/towersofhanoi.py中。

你可以看到为了移动5个圆盘就需要31=25-1次移动。对于64个圆盘，需要264-1=18446744073709551615次移动。如果这些僧人可以每秒移动一个圆盘，完成这个工作需要大概5850亿年。因为在本书编写时地球大概才45亿年，我们不需要过于担心在他们完成任务时世界会不会真的到了末日。