   

## 6.6　问题解决：通过处理物理对象发现算法

在6.5节中，你已经看到如何通过组合和修改已知操作和算法来解决问题。但是，如果不知道如何应用标准算法解决问题时，你该怎么做呢？在本节中，你会学到一个通过处理物理对象发现算法的技巧。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image06633.jpeg)

处理物理对象可以给你发现算法的灵感

考虑下面的任务：已知一个大小为偶数的列表，要求交换前一半和后一半。例如，如果列表中包含8个数：

![](../Images/image06634.gif)

那么你应该把它改为：

![](../Images/image06635.gif)

很多学生发现得到一个算法很困难。他们可能知道需要一个循环，并且也意识到元素应该被插入（6.2.2节）或者交换（6.3.8节），但是他们没有足够的直觉来画图，描述算法，或者写出伪代码。

发现算法时一个有用的技巧是处理物理对象。把一些对象摆成一行表示列表。硬币，扑克牌，或者小玩具，都是不错的选择。

这里我们摆放了8个硬币：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image06636.jpeg)

现在让我们回退一步看看为了改变硬币的顺序我们可以做什么。我们可以删除一个硬币（6.2.4节）：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image06637.jpeg)

我们可以插入一个硬币（6.2.2节）：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image06638.jpeg)

或者，我们可以交换两个硬币（6.3.8节）：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image06639.jpeg)

继续——现在就把一些硬币摆成一行并且试一下这三个操作，找找感觉。

那么如何能帮助我们解决交换列表的前一半和后一半的问题呢？

让我们把第一个硬币放进正确的位置，和第5个硬币交换。然而，作为Python程序员，我们会说是交换位置0和位置4的硬币：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image06640.jpeg)

接下来，我们交换位置1和位置5的硬币：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image06641.jpeg)

再交换两次，我们就完成了：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image06642.jpeg)

现在一个算法就很明显了：

![](../Images/image06643.gif)

变量j从哪里开始呢？我们有8个硬币时，位置0的硬币移动到位置4。一般地，是被移动到列表的中间，或者位置length/2。

我们应该执行多少次迭代呢？需要交换前一半的所有硬币。也就是说，我们需要交换length/2个硬币。伪代码为：

![](../Images/image06644.gif)

对伪代码进行一次预排（见4.2节）是个好主意。你可以使用回形针表示变量i和j的位置。如果预排成功，那么我们知道在伪代码中不存在“差一错误”。自测题29要求执行这个预排，练习P6.10要求把伪代码翻译成Python程序。练习R6.24给出了一个交换列表两部分的不同算法，重复地删除和插入硬币。

很多人发现处理物理对象不像画图或者在脑子里想象算法那么可怕。在需要设计一个新算法时尝试一下这个方法！

下面是实现我们算法的完整程序：

ch06/sec06/swaphalves.py

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image06645.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image06646.jpeg)

自测题

29.预排我们在本节中开发的算法，使用两个回形针表示i和j的位置。解释为什么伪代码中没有边界错误。

30.拿出一些硬币模拟下面的伪代码，使用两个回形针表示i和j的位置。

![](../Images/image06647.gif)

算法的功能是什么？

31.考虑重排列表中所有元素使得偶数在前的任务。除此之外，顺序不重要。例如，列表

![](../Images/image06648.gif)

应该被重排为

![](../Images/image06649.gif)

使用硬币和回形针，通过交换元素来发现解决这个任务的算法，然后使用伪代码描述。

32.发现解决自测题31中任务的算法，使用元素删除和插入，而不使用交换。

33.考虑4.5.4节中的算法，发现一系列输入中的最大元素——不是列表的最大元素。为什么在桌子上放置扑克牌比按序摆放玩具兵的视觉效果更好呢？

34.在Python中，可以使用切片操作（专题6.2）交换列表的两部分：

![](../Images/image06650.gif)

比较一下使用这种方式和6.6节中方法的元素移动次数。

35.你如何通过处理物理对象来发现自测题34的解决方案？

练习它　现在你可以尝试本章最后的练习：R6.24，R6.25，P6.10。