   

### 6.4.2　重载和自动类型转换

在某些情况下，有两个朋友未必胜过只有一个朋友。有时，两件好事带来的好处也会互相抵消。重载就是一个朋友，至少是Java语言中很有用的一项特性。引元的自动类型转换也是Java语言中很有用的一项特性，例如某个方法希望得到double类型的引元时，2这样的int值会被转换为2.0这样的double值。但是这两个友好的特性有时可能会彼此互相妨碍。

例如，下面的语句创建了一个重量为750磅的Pet对象。

![](../Images/image10432.gif)

但是，假设我们忘记了小数点和后面的0，编写的是下面的语句：

![](../Images/image10433.gif)

那么创建的就不是重量为750磅的Pet对象，而是年龄为750岁的Pet对象。因为引元750的类型为int，所以它会和有一个int类型参数的构造器相匹配。这个构造器会将实例变量age而不是实例变量weight设置成引元的值。如果Java可以找到参数与引元的数量和类型都匹配的方法定义，那么就不会执行任何像从int到double这样的类型转换。

在刚刚看到的情况中，我们需要类型转换，但是却没有发生类型转换。还有一些情况是我们不希望类型转换，但是Java却执行了类型转换。例如，假设我们的狗名叫Cha Cha，重2磅，3岁大。我们会尝试执行下面的代码：

![](../Images/image10434.gif)

这会将myDog的年龄设置为2而不是3，而其重量被设置成了3.0而不是2.0。当然，真正的问题在于我们将第二个和第三个引元颠倒了，但是让我们按照Java的方式来审视这段代码。在前面的调用中，Java会寻找头部具有下面形式的构造器：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10435.jpeg)

Pet没有这样的构造器，因此针对该调用没有任何精确的匹配。然后，Java会尝试着将int转换为double以获得一个匹配，因为它注意到如果将3转换为3.0，那么就可以产生一个匹配：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10436.jpeg)

因此Java就会执行这个类型转换。

除了将两个引元颠倒了顺序，还有哪里有问题？我们给出的重量应该是2.0，而不是2。如果我们使用了2.0，或者如果Java没有为我们执行任何自动的类型转换，那么我们就会得到一条错误消息。在上面的例子中，Java尝试着提供了帮助，但是却帮了倒忙。

旁白：对两个字符进行平均  

让我们来快速浏览一下如何对两个字符进行平均。对于前面的示例，是否使用离奇的方式来平均两个字符都没有关系，但是，事实上，我们在程序清单6.15中针对第三个版本的getAverage所使用的技术是一种非常合理地平均两个字符或者平均至少两个字符的方式。如果两个字母都是小写字母，那么计算得到的平均值就是按照字母表顺序在它们中间的小写字母，或者是尽量靠近它们的字母。类似地，如果两个字母都是大写字母，那么计算得到的平均值就是按照字母表顺序在它们中间的大写字母。这种方式行得通是因为Unicode会对按照字母表顺序排序的字母顺序赋值，所以赋给’b’的数字就比赋给’a’的数字大1，赋给’c’的数字就比赋给’b’的数字大1，以此类推。因此，如果将两个字母转换为数字，对数字进行平均，然后将它们再转换回字母，就会得到它们中间的字母。  

疑难杂症：重载和自动类型转换

有时，一个方法调用可以按照两种不同的方式来解析，取决于重载与类型转换的交互方式。这种二义性的方法调用在Java中是不允许的，并且会产生运行时错误消息，有时甚至会产生编译器错误消息。例如，我们可以像下面这样来重载SampleClass类中的problemMethod方法名：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10437.jpeg)

这个类可以毫无问题地编译。但是，像下面这样的调用：

![](../Images/image10438.gif)

将产生一条错误消息，因为Java无法决定应该使用problemMethod的哪个重载定义：它应该把int值5转换成double值，然后使用problemMethod的第一个定义；还是应该将int值10转换为double值，然后使用第二个定义呢？在这种情况下，Java会产生一条错误消息，表示该方法调用具有二义性。

尽管下面两个方法调用都是允许的：

![](../Images/image10439.gif)

这种情况虽然合法，但是容易令人混淆，因此应该避免。

牢记：在自动类型转换之前重载

Java总是会在尝试使用自动类型转换之前使用重载。如果Java可以找到一个能够匹配引元类型的方法定义，就会使用这个定义。Java尝试寻找参数类型与方法调用中的引元精确匹配的方法名定义，直至尝试失败之后才会尝试方法引元的自动类型转换。

编程窍门：选择描述性的名字以避免重载

因为在程序清单6.1的Pet类中给出了四个具有相同名字（set）的设置方法，所以这些方法可以用来演示我们刚刚讨论过的重载和自动类型转换的问题。与其重载这些名字，不如通过选择不同的名字来避免这些困难。我们不会称这四个方法都为set，而是会使用更具描述性的名字setName、setAge、setWeight和setPet。你应该在理由充分时再使用重载，但是当不同的方法名更具描述性时，就不应该使用重载。但是，对于构造器来说，这条建议并不适用，因为它们必须以类来命名。即便如此，一个类具有多个重载的构造器也是很常见的情况。