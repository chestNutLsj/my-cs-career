   

## 6.5　再探信息隐藏

我不喜欢别人干涉我的私事。

——卡尔·卡劳斯（1874—1936）

本节中的内容对于理解本书剩下大部分内容并非是必需的。如果你愿意，可以在更加习惯于使用类之后再阅读这些内容。本节将讨论在定义某些种类的类时可能会产生的一个微妙的问题，对于你的定义的类来说，如果实例变量要么是基本类型（例如int、double、char或boolean），要么是String类型，那么这个问题并不会发生，所以你在定义许多类时都不用担心这个问题。

隐私泄露

类可以拥有任何类型的实例变量，包括任何类类型。这些实例变量对于类来说，拥有它们经常显得很自然也很有用。但是，使用类类型的实例变量可能会引入一个需要我们特别当心的问题。这个问题之所以会发生，是因为类类型的变量包含了表示该对象在内存中存储单元的内存地址。例如，假设goodGuy和badGuy都是我们在程序清单6.1中定义的Pet类类型的变量。现在，假设goodGuy命名了某个对象，而程序将执行下面这条赋值语句：

![](../Images/image10458.gif)

在这条赋值语句执行之后，badGuy和goodGuy就变成了同一个对象的两个名字。因此，如果修改badGuy，也就修改了goodGuy。（这必然是经过了道德的洗礼。）

让我们对这条赋值语句增加一些上下文来看看它的含义：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10459.jpeg)

因为badGuy和goodGuy命名的是同一个对象，所以这段代码将产生下面的输出：

![](../Images/image10460.gif)

对badGuy的修改也修改了goodGuy，因为goodGuy和badGuy命名的是同一个对象。相同的事情也会发生在实例变量上，并且也会引发一些微妙的问题。让我们来看一个示例。

程序清单6.18包含了名为PetPair的类的定义，该类表示一对Pet对象。这个类包含两个Pet类型的私有实例变量。编写这个类的程序员错误地认为实例变量first和second命名的数据不会被任何使用PetPair类的程序所修改，这是程序员经常犯的错误。毕竟，实例变量是私有的，因此它们不可能在类外部通过名字来访问。而且，为了万无一失，该程序员没有编写任何修改实例变量的修改器方法。但是，任何人都可以通过使用公有访问器方法getFirst和getSecond来查看这一对对象。看起来不错？很遗憾，这位程序员将如梦初醒。

程序清单6.18　不安全的类

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10461.jpeg)

程序清单6.19中创建了一个PetPair对象，然后修改了该对象的私有实例变量first的状态！这怎么可能呢？问题在于类类型的变量包含内存地址，正如你在本节开头部分所看到的，可以用赋值操作符为同一个对象产生两个名字，这正是编写了程序清单6.19中的程序的黑客程序员所做的。通过调用访问器方法getFirst，就可以获得私有实例变量first的地址。这个内存地址存储在变量badGuy中，因此badGuy就是first的另一个名字。黑客无法使用私有名first，但是可以使用等价的名字badGuy。黑客只需使用badGuy这个名字就可以调用Pet类的setPet方法，并且因为badGuy是由first命名的对象的另一个名字，所以黑客也就修改了由私有实例变量first命名的对象。这种现象称为隐私泄露。

程序清单6.19　修改类中的私有对象

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10462.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10463.jpeg)

怎样才能在编写类定义时避免这个问题呢？看起来好像无法让类类型的私有实例变量变得真正安全。黑客总是可以找到某种方式来得到它们，或者看起来确实如此。但是，总有方法可以绕过这个问题：有些比较容易，而有些又比较困难。

有一种绕过此问题的简单方法是只使用基本类型的实例变量。当然，这是一种相当严苛的限制。我们还可以使用没有任何修改器方法的类类型的实例变量。String就是这样的一个类。一旦某个String对象被创建，它的数据就不能被修改，因此黑客所使用的诡计对这些变量并不奏效。基本类型不是类类型，因此黑客的诡计对它们也无法奏效。这种简单的解决方案是我们在本书中所采用的方法。

另一种简单的方法是在定义访问器方法时，返回由类类型的实例变量所命名的对象的单个属性，而不是该对象本身。当然，任何自身就是另一个对象的属性可能也会产生类似的问题。因此，举例来说，我们并不会在PetPair中定义像getFirst这样的访问器方法，而是会定义以下三个方法：getNameOfFirst、getAgeOfFirst和getWeightOfFirst。

还有一种实现起来更困难的解决方案，但是它超出了本书的范围。然而，我们可以在这里给出有关这种方案的一些提示。我们可以编写一个方法，以产生与某个对象完全一样的副本，这种完全一样的副本称为克隆体。与返回由类类型的私有实例变量命名的对象这种并不安全的做法不同，我们可以返回该对象的克隆体。在这种方式中，黑客可以破坏克隆体，但是实际的私有数据不会受到影响。附录J（在本书的网站上）给出了有关克隆机制的简介。在更加习惯于使用类之后，你可能会希望阅读该附录。

不要对类类型的实例变量产生它们不宜使用的印象。它们非常自然也非常有用，但是，有效地处理它们需要非常仔细。我们将在本书稍后更详细地讨论这种实例变量。

疑难杂症：隐私泄露

对于某些类来说，类类型的私有变量命名的是在包含该实例变量的类的外部可以对其进行修改的对象。为了避免这个问题，可以采取以下措施：

·声明实例变量的类型为没有任何set方法的类，例如String类。

·对于访问器方法，如果会返回由类类型的实例变量命名的对象，那么就删除它，取而代之的是定义返回这个对象的单个属性的方法。

·让访问器方法返回类类型的实例变量命名的对象的克隆体，而不是该对象本身。

自测问题

40.请给出可以用来取代程序清单6.18中PetPair类的定义中单一的访问器方法getFirst的三个访问器方法的定义。其中，一个方法会返回宠物的名字，一个方法会返回宠物的年龄，一个方法会返回宠物的体重。这些新的访问器方法不会产生本节所描述的问题。它们可以返回一个PetPair类的对象中的所有数据，但是不会返回任何通过其修改器方法可以修改其状态的对象。