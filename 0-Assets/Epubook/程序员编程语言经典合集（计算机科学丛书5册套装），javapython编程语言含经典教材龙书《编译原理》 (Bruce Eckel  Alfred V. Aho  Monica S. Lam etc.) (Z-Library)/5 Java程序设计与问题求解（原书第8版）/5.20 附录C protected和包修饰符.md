   

# 附录C　protected和包修饰符

在本书中，我们总是在实例变量和方法定义前面使用public和private修饰符。正常情况下，我们只需要这些修饰符，但是还有两个其他的可选项介于public和private这两种极端情况之间。在本附录中，我们将讨论protected修饰符和压根不用任何修饰符时的限制情况。

如果一个方法或实例变量使用protected而不是public或private修饰的，那么它可以在下面的范围内直接通过名字来访问：

·它自己的类定义中。

·任何子孙类。

·同一个包中的任何类的任何方法定义。

这是一种访问范围，受保护的方法和实例变量不能在任何除上述类之外的其他类中通过名字来方法。因此，如果一个方法在A类中标记成了protected，B类是从A类中派生的，那么该方法可以在B类的任何方法定义内部调用。但是，对于与A类不在同一个包中且不是从A类派生的类而言，受保护方法的行为就像它们是私有的一样。

修饰符protected会施加特殊种类的限制，因为它使得愿意不辞艰辛地定义适合的派生类的程序员具有直接访问的权限。因此，就像常说的，“这东西我会让你用起来不方便，但是我不禁止你使用它。”在实践中，实例变量从来都不应该标记成protected，它们应该是私有的。但是，你可以拥有用于这些实例变量的受保护的访问器和修改器方法。

如果想要的访问级别不是公有的，但是也不是像私有这么严格的权限，那么有一种可选的权限经常会被用到。你可能已经注意到了，如果你忘了在实例变量或方法定义前放置public或private修饰符，那么你的类定义仍旧可以编译。在这种情况下，这种实例变量或方法可以在任何与其所属的类处于同一个包中的类定义中通过名字来访问。但是，在这个包的外部是不能通过名字来访问的。这种类型的访问权限称为包访问权限或缺省访问权限。在将由互相协作的类构成的包当作单个封装单元时，就应该使用包访问权限。注意，包访问权限比受保护访问权限更严格，也赋予了定义类的程序员更多的控制权。如果你控制了包的目录，那么你就可以控制谁具有包访问权限。