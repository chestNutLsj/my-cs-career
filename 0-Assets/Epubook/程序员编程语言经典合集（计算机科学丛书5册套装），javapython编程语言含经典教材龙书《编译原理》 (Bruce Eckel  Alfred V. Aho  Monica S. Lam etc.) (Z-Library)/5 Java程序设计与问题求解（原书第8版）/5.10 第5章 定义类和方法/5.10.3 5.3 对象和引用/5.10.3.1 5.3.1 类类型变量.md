   

### 5.3.1　类类型变量

类类型的变量对对象命名的方式与基本类型的变量存储它们的值的方式不同。每个变量（不论是基本类型的还是类类型的）都是作为存储单元来实现的。如果变量为基本类型，那么存储在存储单元中的数据值就会赋值给该变量。但是，类类型的变量包含的是该变量命名的对象的内存地址，而对象本身并未存储在该变量中，而是存储在内存其他的某个位置上，这个存储单元的地址称为对该对象的引用。因此，类类型经常也称为引用类型。引用类型就是其变量持有的是引用（即内存地址）而不是对象的实际值的类型。

基本类型变量和类类型变量的命名行为不同是有原因的。对于给定的基本类型，例如int类型，其每个值所需的内存数量总是相同的。Java的int类型具有最大值，因此，int类型的值在内存中无法超出某个固定的大小。但是，作为对象，例如String类的对象，可以具有任意大小，使得系统难以为对对象命名的变量划出固定数量的内存。另一方面，在变量中很容易存储任何字符串的地址，因为计算机的内存以及内存地址的大小都是有限的。

因为类类型的变量包含的是引用，并且其行为与基本类型的变量迥然不用，所以会得到一些令人意外的结果。考虑下面的代码行，它们可能是某个程序主体部分的开头：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10243.jpeg)

有两个int类型的变量：n和m，它们的值都是42，但是如果修改其中一个，另一个的值仍旧是42。例如，如果程序继续执行下面的语句：

![](../Images/image10244.gif)

其输出将会是：

![](../Images/image10245.gif)

到目前为止，没有任何意外情况，但是假设程序继续执行下面的语句：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10246.jpeg)

![](../Images/image10247.gif)

你可能会认为klingonSpecies是克林贡公牛，而earthSpecies是大象，但是事实并非如此，下面是实际的输出：

![](../Images/image10248.gif)

发生了什么？这里有两个变量：klingonSpecies和earthSpecies。首先，这两个变量引用的是不同的对象，每个对象都存储在计算机内存中的某个位置上，这些位置都有自己的地址。因为类类型的变量存储的是对象的内存地址，而不是对象本身，所以下面的赋值语句：

![](../Images/image10249.gif)

会将klingonSpecies的内存地址复制给变量earthSpecies，使得这两个变量都包含了相同的内存地址，因此这两个变量命名的是同一个对象。无论用它们中的哪个变量来调用setSpecies，实际上都是同一个对象接收到了该方法调用，因此修改的是同一个对象。我们之前创建的第二个对象会怎样？对于该程序来说再也无法访问到它了。图5.5展示了这种行为。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10250.jpeg)

图5.5　类变量的行为

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10251.jpeg)

图5.5　（续）

有关内存地址的警告：内存地址是数字，但是它与int值所表示的数字属于不同种类。因此，不要试图将其当作普通的整数处理。

牢记：类类型的变量包含的是内存地址

基本类型的变量包含的是对应类型的值。类类型的变量包含的不是对应类的对象，而是该对象在计算机内存中的位置对应的内存地址。这种模式使得类类型的变量可以用作该类的对象的名字。但是，某些操作（例如=和==），作用于类类型变量时的行为与作用于基本类型变量时的行为差异很大。

牢记：内存地址既是数字，也不是数字

类类型的变量包含的是内存地址。尽管内存地址是数字，但是类类型的变量不能当作存储数字的变量来使用。内存地址的重要属性就是它们是用来标识存储单元的，而地址是数字而不是字母、颜色或其他东西这个事实只是附属的属性。Java禁止我们使用这个附属的属性，这样做可以防止我们做不该做的事情，例如获取对受限内存的访问权，否则，会把计算机玩坏的。它还可以让代码更易于理解。

回顾：类类型和引用类型

类类型的变量持有的是该类的某个对象在内存中的地址，这个内存地址经常称为对内存中该对象的引用。因此，类类型是引用类型。引用类型的变量持有的是引用，即内存地址，而不是对象实际的值。但是，有些引用类型不是类类型，因此，在引用类的名字时，我们将使用术语类类型。所有类类型都是引用类型，但是正如你将在第7章看到的，并非所有的引用类型都是类类型。

疑难杂症：对类类型变量使用==

在上一节中，你看到了在对类类型变量使用赋值操作符时发生了一些令人感到意外的情况。对相等性的测试所使用的方式看起来也显得很奇怪。假设SpeciesFourthTry类的定义如程序清单5.11所示，并且程序中包含下面的代码：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10252.jpeg)

那么这段代码会输出：

![](../Images/image10253.gif)

这两个SpeciesFourthTry类型的对象都在内存中，它们表示的都是现实世界中相同的物种，但是具有不同的内存地址。问题在于，尽管这两个对象在直觉上应该相等，但是类类型的变量实际上包含的只是内存地址。==操作符只检查它们的内存地址是否相等，它测试的确实是相等性，但是并非我们通常关心的相等性。当定义类时，你应该为类定义一个名为equals的方法，该方法用来测试两个对象是否相等。下一节将向你展示如何定义这个方法。

图5.6展示了这段代码的执行过程。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10254.jpeg)

图5.6　对对象使用==的危险