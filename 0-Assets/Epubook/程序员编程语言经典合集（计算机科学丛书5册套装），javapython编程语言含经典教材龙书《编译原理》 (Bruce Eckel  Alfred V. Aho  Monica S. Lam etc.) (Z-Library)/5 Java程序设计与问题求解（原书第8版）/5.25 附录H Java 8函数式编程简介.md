   

# 附录H　Java 8函数式编程简介

函数式编程是在Java 8中引入的，其核心功能是使用Lambda表达式的函数式编程。在本附录中，我将阐述函数式编程的好处，并给出一些这种编程风格的示例。大多数Java 8的特性更适合在高阶的Java书籍中讨论，但是这些概念适用于我们之前讨论过的内容，特别是第12章的集合框架和JavaFX应用的事件处理器。

Lambda表达式是没有名字的函数。在函数式编程中，函数是与方法相同的东西。相关的概念你可能听到过，包括闭包、匿名函数和函数字面常量。就像没有名字的函数一样，Lambda表达式本质上就是一小段代码，我们可以将其当作数据来传递，但是会将其当作带有参数的函数来处理。Lambda表达式提供了一种灵巧的方式，让我们去实现通常只有一个方法的类，并且让现场修改这些方法变得更容易，无须经历定义一个方法来执行特化任务的工作。此外，Lambda表达式还帮助Java自身可以更高效地在多核或多处理器的机器上并行地运行。例如，正常情况下，我们处理一个ArrayList中的元素时，会创建一个for循环，逐个地访问每个元素。这种循环被认为是从外部访问。相比之下，在使用Lambda表达式时，我们可以提供一个函数，告诉Java如何处理每个元素，从而实现在内部遍历ArrayList。然后，JVM通过将函数和元素调度到不同的处理器上来实现并行操作。

定义Lambda表达式的格式看起来像下面这样：

![](../Images/image11484.gif)

箭头将参数与表达式体分离。在许多情况下，表达式体非常短，只有一行代码。如果表达式体更长，那么传统的方法可能会显得更有意义。下面是一个返回两个整数x和y的和的Lambda表达式：

![](../Images/image11485.gif)

在许多情况下，Java可以确定参数的类型，此时我们可以删除数据类型。我们还可以在右侧只提供表达式，它会自动地变成返回值：

![](../Images/image11486.gif)

Java的Lambda表达式在应用于集合时会显得特别有用。在典型情况下会执行的三个常见操作是在集合上的过滤（filter）、映射（map）和化简（reduce）操作。在本附录中，我们会对每种操作都给出一个简短的示例。

让我们从过滤器的概念开始。考虑下面的代码，它创建了一个double列表：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11487.jpeg)

如果我们只想输出这个数组中超过50的值，按照传统的Java风格（外部处理），我们会用一条if语句创建一个循环：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11488.jpeg)

在使用Java 8的Lambda表达式时，我们可以创建一个由这个ArrayList中的元素构成的流，然后对它们进行过滤，从而完成相同的任务。这可以通过下面的函数调用序列来实现：

![](../Images/image11489.gif)

出于可读性的考虑，常见的做法是将每个函数调用都单独放到一行中：

![](../Images/image11490.gif)

stream（）方法会创建一个流，它会产生一个我们可以在其上执行一次迭代的列表。不要将这个流与数据流混淆在一起，这种新类型的流可以被并行或顺序地访问。在这个案例中，我们只使用了顺序流。一旦生成了这种流，我们就在其上调用filter和forEach。在过滤器内部，我们指定了一个Lambda表达式，这个ArrayList中的每个元素都会按照这个Lambda表达式来过滤。在这个案例中，变量val是这个ArrayList中的一个待处理的元素，该函数声明要过滤出来那些大于50的元素。接下来，forEach会遍历过滤出来的元素，通过println输出其中的每个元素。在本例中，这样做会输出56.3和81.1。

我们可以通过删除数据类型来稍微简化一下代码，因为Java可以从上下文中推导出数据类型。所产生的代码为：

![](../Images/image11491.gif)

新的格式与传统的方法非常不同，但是其风格更加简洁，可以更容易地并行化，并且与以前的技术相比，通常只需要更少的代码。

接下来，让我们来考虑映射的概念。映射会获取集合中的元素，并按照某种方式对它们进行转换。考虑一个简单的映射，我们想要将ArrayList中的每个元素都加上100。我们可以按照下面的方式来实现此任务：

![](../Images/image11492.gif)

上述代码将输出加上100后的值（即，103.5、156.3、181.1、104.8）。注意，按序列调用每个函数。如果我们在映射前加上之前的过滤器，那么只会得到156.3和181.1：

![](../Images/image11493.gif)

最后，考虑一下收集的概念。收集表示我们要以某种方式处理所有的元素，并回收最后的结果。最终结果经常是单个值。收集的例子包括对数据集求和、求平均值、查找最小值、查找最大值。下面的代码展示了我们可以如何计算ArrayList中的所有元素：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11494.jpeg)

mapToDouble函数会取出每个元素，将其映射为double值（这里有点多余，因为这些元素本来就是double值），然后将它们累计到总和中。正如你推测的，还有mapToInt（）、mapToLong（）等方法，以及用来计算min（）、max（）、average（）和其他值的方法。

使用reduce函数时，还可以做更多的定制。在我们的案例中，我们使用的版本会接受作为输入的一个种子值和一个二元函数。考虑由值v1、v2和v3构成的集合。如果我们以种子值s开始，reduce首先会将二元函数应用于s和v1，产生r1。然后，二元函数会应用于r1和v2，产生r2。然后，二元函数应用于r2和v3，产生会当作最终结果值返回的r3。下面的代码使用reduce计算了所有值的总和：

![](../Images/image11495.gif)

在这个案例中，0.0是种子值，第二个参数是用来说明如何累计值的总和的函数。对于第一步，v1对应于0.0，v2对应于3.5，产生中间和3.5。在第二步中，v1对应于3.5，v2对应于56.3，产生59.8。在第三步中，v1对应于59.8，v2对应于81.1，以此类推，直至产生最终的总和。

再举一个例子，考虑下面的名字列表：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11496.jpeg)

如果我们想要计算所有名字的平均长度，那么可以用将长度映射为整数：

![](../Images/image11497.gif)

在这个案例中，我们用length（）方法将每个名字都映射成一个int，然后计算平均值，将结果作为double取出。

再举最后一个例子，假设我们想要获取最长的名字，可以使用约简技术：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11498.jpeg)

在这个案例中，我们使用了代码块，其中的函数比较了字符串的长度，并返回最长的一个。对于下面的案例，我们通常会使用？操作符来缩短代码：

![](../Images/image11499.gif)

这些示例应该让你对Java的Lambda表达式看起来什么样和它们能做些什么有了初步的了解。尽管肯定存在学习曲线，但是Lambda表达式使得我们可以编写出能够并行运行的简洁代码。Java 8的新语法同时支持函数式编程和面向对象编程，且同时具备了这两种风格的优点。