   

### 9.3.4　多个抛出和捕获

try块可以抛出任意数量的异常，它们可以是不同的类型。每个catch块都只能捕获一种类型的异常，但是我们可以通过在一个try块后面放置多个catch块的方式来捕获不同类型的异常。例如，程序清单9.8中的程序在其try块后面就有两个catch块。一个catch块用来捕获程序清单9.5中定义的DivideByZeroException类型的异常，另一个用来捕获程序清单9.9中定义的NegativeNumberException类型的异常。

程序清单9.8　捕获多个异常

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11009.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11010.jpeg)

程序清单9.9　NegativeNumberException类

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11011.jpeg)

编程窍门：先捕获更具体的异常

当捕获多个异常时，catch块的顺序显得很重要。当在try块中抛出异常时，会按照catch块出现的顺序对它们进行审视。第一个与被抛出异常所属类型匹配的catch块就是会得以执行的catch块。因此，下面的catch块顺序就不好：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11012.jpeg)

在这个顺序之下，用于捕获DivideByZeroException的catch块将永远都不会被用到，因为所有异常都会被第一个catch块捕获。幸运的是，编译器可能会警告你存在此问题。

正确的顺序应该是将上面两个catch块颠倒一下，让更具体的异常出现在其父异常类的前面，如下面代码所示：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11013.jpeg)

编程窍门：用户输入

当程序读入由用户键入的输入数据时，我们就很有可能需要处理异常。用户几乎可以键入任何东西作为输入，不管其是有心的还是无意的！

编程窍门：异常处理和信息隐藏

我们知道，方法调用可能会引发在该方法的throws子句中声明的异常。任何时刻，只要有异常抛出，无论是你编写了throw语句还是调用了某个方法，都需要按照完全相同的方式去处理它：它要么被某个catch块捕获，要么在另一个throws子句中声明。在分析可能会抛出异常的方法调用时，不要去考虑如何在该方法定义中定位throw语句。异常是如何被抛出的并不重要，重要的是该方法调用可能会抛出异常。无论在该方法中何处抛出了异常，处理该异常的方式都完全一样。

自测问题

24.通过添加适合的throws子句来纠正下面的方法：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11014.jpeg)

25.如果调用某个方法，而该方法抛出了它并不会捕获的受检异常，那么会发生什么？

26.考虑对方法A的调用。假设方法A调用了方法B、方法B调用了方法C。如果方法C抛出了它自己没有捕获的异常，那么这个异常可能会在哪里被捕获？在B中？在A中？还是在A外部？

27.下面的代码会产生什么输出？NegativeNumberException类的定义在之前的内容中给出过，但是你无须查看它就可以回答此问题。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11015.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11016.jpeg)

28.重复自测问题27，但是n的值从7改为-7。

29.重复自测问题27，但是n的值从7改为0。

30.下面的程序将产生什么样的输出？

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11017.jpeg)

常见问题：我的代码应该何时抛出异常？

throw语句应该作为针对无法避免情况的保留手段。如果想要使用throw子句，应该先想想在不使用这条throw语句的情况下，可以如何编写程序或类定义。如果能够想到一种可以产生合理代码的替代方法，那么可能就不应该抛出异常。但是如果处理异常情况的方式取决于方法是如何以及在何处被调用的，那么最佳方式就是让调用该方法的程序员来处理异常。在所有其他情况中，最好是避免抛出异常。

预定义方法经常将异常留给调用该方法的程序员去处理。当你在学习预定义方法的用法时，可能会被告知它会抛出某些类型的异常。作为使用该预定义方法的程序员，它希望你能够去处理该方法抛出的所有异常。

编程窍门：在哪里抛出异常

到目前为止，我们在说明异常处理的基本概念时，使用的都是非常简单的代码。但是，我们的示例显得有些不切实际地简单。一般而言，我们应该将抛出异常和捕获异常分离到不同的方法中。例如，某个方法可能具有下面的形式：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11018.jpeg)

而另一个方法可能具有下面的形式，它甚至可能在其他的类中：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11019.jpeg)

这样做的原因与上一个常见问题所讨论的何时应该抛出异常有关。如果一个方法知道如何处理某种特定的情况，那么它可能就应该去处理这种情况而不抛出异常。如果一个方法中的某段代码会抛出异常，例如，如果你的方法调用了另一个会抛出异常的方法，那么如果你能够处理，就应该处理它。否则，在你的方法的throws子句中声明该异常，并且让另一个方法包含相应的catch块。

疑难杂症：嵌套的try-catch块

尽管我们可以将一个try块及其后续的catch块放到一个更大的try块或更大的catch块中，但是这么做几乎没什么用处。如果想要嵌套这些块，那么你至少应该考虑一下是否还有其他的代码组织方式。例如，你可以完整地删除一个或多个try块，或者可以将内层的try-catch块置于某个方法定义中，然后在外层的try块或catch块中调用该方法。避免使用嵌套的try-catch块几乎总是优选的方案。

但是，假设你确实使用了嵌套的try-catch块。如果你将某个try块及其后续的catch块放到一个更大的try块中，并且在内层的try块中抛出了异常，但是该异常没有被内层catch捕获，那么该异常就会抛给外层的try块去处理，并且可能会被某个外层catch块捕获。如果你将某个try块及其后续的catch块放到一个更大的catch块中，那么你需要对内层和外层块中的catch块参数分别赋予不同的名字。毕竟，try块和catch块都是语句块，因此，你需要牢记Java是如何处理所有种类的嵌套语句块的。