   

### 3.2.2　优先级规则

Java计算布尔表达式的策略与计算算术表达式的策略是相同的。例如，如果下面的表达式中的整数变量score是95：

![](../Images/image09865.gif)

那么，第一个子表达式（score>=80）为真，但是第二个子表达式（score<90）为假。因此，整个表达式等价于：

![](../Images/image09866.gif)

正如在本章之前小节中所看到的，Java会根据表3.3

中给出的规则来组合true和false的值。因此，上面这个表达式的值为fasle。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09867.jpeg)

图3.6　操作符优先级

正如编写算术表达式一样，通常最好是在布尔表达式内部使用括号来表示操作的顺序。但是，如果删除这些括号，Java会按照图3.6中所示的优先级规则指定的顺序执行操作。这张图是图2.1的增强版本，展示了你可能会用到的所有操作符。正如在第2章中所提到的，所列操作符在这张表中位置越高，其优先级也就越高。当两个操作的顺序没有用括号来表示时，Java会确定它们的优先级，并且在执行一个操作之前，先执行另一个具有更高优先级的操作。有些操作符具有相等的优先级，此时，它们会按照在表达式中的先后顺序执行。具有相等优先级的二元操作符将按照自左向右的顺序执行，而具有相等优先级的一元操作符将按照自右向左的顺序执行。回忆一下，一元操作符只有一个操作数，即它只能作用于一个事物，而二元操作符有两个操作数。

让我们思考一个例子。下面是用相当简陋的样式编写的语句，因为它缺少括号，但是计算机不会觉得有问题：

![](../Images/image09868.gif)

在这个表达式的所有操作符中，除法操作符具有最高优先级，因此首先会执行除法。我们通过添加括号来表示这个事实，就像下面这样：

![](../Images/image09869.gif)

在这个表达式的其余操作符中，减法操作符具有最高优先级，因此接下来会执行减法：

![](../Images/image09870.gif)

在这个表达式的其余操作符中，比较操作符>和<具有最高优先级，因此接下来会执行它们。因为>和<具有相同的优先级，所以它们会按照自左向右的顺序执行：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09871.jpeg)

最后，两个比较的结果用||组合了起来，因为它具有最低的优先级。

我们使用优先级规则产生了该表达式带括号的版本。对于计算机来说，这个版本和原来不带括号的版本是等价的。你应该保留其中大部分的括号，使得其中的算术表达式和布尔表达式更易于理解。但是，你可以在该表达式只包含简单的 & & 或||序列时安全地删除括号。例如，尽管删除了一些括号，下面的代码仍不失为一种好的样式：

![](../Images/image09872.gif)

你可能会得出结论，上面这个表达式中的三个比较会先执行，然后用||组合起来。但是其中的规则比你目前看到的要更复杂一些。假设temperature的值为99。在这种情况下，我们知道无论rainFall和humidity的值如何，整个布尔表达式都为真。因此，无论rainFall>20是否为真，下面表达式的值都一定为真：

![](../Images/image09873.gif)

基于类似的推理，我们可以得出结论，无论humidity>=60是否为真，下面的表达式都一定为真：

![](../Images/image09874.gif)

Java会计算第一个子表达式，如果其结果包含了足够的信息，可以知道整个表达式的值，那么它就不会再计算后续的子表达式了。因此，在这个例子中，Java永远都不会再去计算包含rainFall和humidity的子表达式了。这种计算表达式的方式称为短路计算，有时也称为惰性计算，正是Java用来处理包含||或 & & 的表达式的方式。

现在，让我们来看一看一个包含 & & 的表达式。我们通过将其置于if-else语句中，为这个布尔表达式创建一个上下文：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09875.jpeg)

假设assignmentsDone的值为0。那么第一个子表达式就是false。因为false & & true和false & & false都是false，所以整个表达式为false，无论第二个子表达式是真还是假。因此，Java不会再去计算第二个子表达式：

![](../Images/image09876.gif)

在这种情况中，不计算第二个子表达式会产生巨大的差异，因为第二个子表达式包含除以0。如果Java去尝试计算第二个子表达式，那么就会产生运行时错误。通过使用短路计算，Java避免了发生这种错误。

Java也允许我们要求执行完整计算。在完整计算中，当两个表达式用“与”或“或”操作符连接时，两个子表达式总是都会被计算，然后用真值表来获得最终表达式的值。为了在Java中执行完整计算，我们需要用 & 代替 & & 表示与，用|代替||表示或。

在大多数情况下，短路计算和完整计算会给出相同的结果，但是正如你刚刚看到的，有时短路计算可以避免运行时错误。也有一些情况下完整计算会更好，但是我们在本书中不会使用这些技术。我们将总是使用 & & 和||，因此，总是会执行短路计算。

牢记：短路计算

对于Expr_A||Expr_B形式的布尔表达式来说，如果Expr_A为真，那么Java无须计算Expr_B，就可以知道整个表达式的值为真。类似地，对于Expr_A & & Expr_B形式的布尔表达式来说，如果Expr_A为假，那么Java无须计算Expr_B，就可以知道整个表达式的值为假。