   

## 编程项目

编程项目与实践程序相比，要求更高的问题解决能力，并且通常可以用多种不同的方式来解决。

1.回文是指正向和反向读起来都相同的字符串，例如"radar"。编写一个静态递归方法，它有一个String类型的参数，在引元是回文的情况下返回true，否则返回false。字符串中的空格和标点符号应该被丢弃，将同一个字母的大写和小写版本看作相同字符。例如，下面的字符串在你的方法中就应该被认为是回文：

![](../Images/image11294.gif)

你的方法不需要检查该字符串是否是正确的英语短语或单词。将这个方法嵌入某个程序中，并对其进行测试。作为额外的挑战，你可以用你的回文检测方法来检查第10章编程项目11中所描述的英语单词文件，找到其中是最长回文的单词。

2.几何级数被定义为前n个整数的乘积，表示如下：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11295.jpeg)

这种标记法表示将从1到n的整数连乘。调和级数被定义为前n个整数的倒数的乘积，表示如下：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11296.jpeg)

这两种类型的级数都具有等价的递归定义：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11297.jpeg)

编写一个静态方法，实现这些计算geometric（n）和harmonic（n）的递归公式。不要忘了包含基础情况，这些情况在上面的公式中没有给出，但是你必须确定这些情况是什么。将这个方法放到一个测试程序中，该程序允许用户针对输入的整数值n计算geometric（n）和harmonic（n）。你的程序应该允许用户输入另一个n的值，并重复计算，直至发出终止程序的信号。你的方法同样不应该用循环将n个数字乘起来。

3.在自然界中，某些理想化的动物种群数量的增长率经常会呈现为斐波那契数列。该数列以0和1开始，每个后续的斐波那契数都是前两个斐波那契数的和。因此，前10个斐波那契数分别是0、1、1、2、3、5、8、13、21、34。该序列中的第三个数字是0+1，即1；第四个数字是1+1，即2；第五个数字是1+2，即3；以此类推。

除了描述种群数量增长，这个序列还可以用来定义螺旋线的形式。另外，该序列中连续的两个斐波那契数之比接近一个常数，大约为1.618，这个常数被称为“黄金分割”。人们发现这个比例在美学上很完美，所以经常用它来作为房屋或明信片的长宽比。

使用递归公式定义一个静态方法，针对给定的引元n，计算第n个斐波那契数。你的方法不应该使用循环来计算所有斐波那契数，直至得到想要的数字，而应该是一个简单的递归方法。将这个静态递归方法放到一个程序中，演示斐波那契数比例是如何收敛的。你的程序应该让用户指定要计算多少个斐波那契数，然后显示这些斐波那契数，每个一行。在前两行之后，还要在每一行上显示当前的斐波那契数和前一个斐波那契数之比。（前两项的比例没有数学意义。）如果用户输入5，那么输出应该看起来像下面这样：

![](../Images/image11298.gif)

4.想象一下，有一根水果糖，它有k个可以切开的位置。你想知道将这根糖切成小段有多少种不同的切分序列。例如，如果k为3，那么你可以在位置1切开它，然后是位置2，最后是位置3，我们用123来表示这个切分序列。因此，如果k为3，就有6种不同的切法：123、132、213、231、312、321。注意，我们有n种可能来切第一刀，一旦切了第一刀，就必须在剩下的k-1个位置上选择一个切第二刀，这可以递归地表示为：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11299.jpeg)

我们添加一项限制，让这个问题更有趣一些。你必须总是切下最左边可以切的小段。现在，如果k为3，我们可以切的序列就是123、132、213、312、321。231这种切法是不允许的，因为在2处切开后，我们必须在位置1处切开，因为它是最左边的小段。切第一刀仍旧有k种切法，但是现在我们必须计算切开后两段的切法，并将它们乘起来。这可以递归地表示为：

![](../Images/image11300.gif)

当k为3时，我们将计算：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11301.jpeg)

对于这两个递归公式，如果k=0，就只有一种切分的方式。

开发一个程序，从键盘读取k的值，然后显示C（k）和D（k）。（D（k）很有趣，因为它的结果是我们用括号将包含k个二元操作符的算术表达式括起来的各种不同方式的数量。）

5.从前，在遥远的地方有一个王国，它的国王在囤积粮食而百姓却在挨饿。国王的顾问建议将粮仓中的粮食拿出来救济百姓，但是国王拒绝了。一天，一伙造反派试图刺杀国王，但是却被这位顾问化解了。作为回报，国王要赐予顾问一件礼物。顾问要求从国王的粮仓中拿取一些麦粒分发给百姓，麦粒的数量将通过在国际象棋棋盘上放置麦粒的方式来确定。在棋盘上第一个方格内，他放了一粒小麦，然后，在第二个方格内放了两粒小麦，在第三个方格内放了四粒小麦，在第四个方格内放了八粒小麦，以此类推。

通过编写递归方法getTotalGrains（k，grains）来计算放置在k个方格内的麦粒总数。每次调用getTotalGrains时，它都会在单个方格内“放置”麦粒，grains表示在这个方格内放置的麦粒数。如果k是1，那么就返回grains。否则，进行递归调用，其中k减小1，而grains翻倍，该递归调用会计算剩余k-1个方格内要放置的麦粒总数。为了计算出所有k个方格内的麦粒总数，需要将递归调用的结果和grains加起来，然后返回得到的和。

6.在房间里有n个人，其中n是大于等于2的整数，每个人都需要与其他每个人握手。这间房子里的人总共握了多少次手？编写一个递归方法来解决这个问题，它具有下面的方法头：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11302.jpeg)

其中handshake（n）会返回房间里n个人的握手总次数。为了能够着手解决该问题，假设房间里只有一个人或两个人时握手次数如下：

![](../Images/image11303.gif)

7.给定如下的二维数组：

![](../Images/image11304.gif)

编写一个递归程序，按照顺序输出每个子数组的所有可能的组合。在上面的例子中，希望得到的输出如下（尽管未必要遵循下面的顺序）：

![](../Images/image11305.gif)

你的程序应该能够操作在两个维度上具有任意尺寸的数组。例如，下面的数据

![](../Images/image11306.gif)

应该输出：

![](../Images/image11307.gif)

8.词语阶梯游戏是刘易斯·卡罗尔在1877年发明的游戏。它的玩法是从某个起始单词开始，每次修改一个字母，直至终止单词。整条路径上的每个单词都必须是英语单词。

例如，从FISH开始，我们可以通过下面的阶梯序列制造一条到达MAST的阶梯：

![](../Images/image11308.gif)

编写一个程序，使用递归来查找从给定的起始单词到给定的终止单词的词语阶梯。使用在本书在线源代码中可以找到的words.txt作为有效单词的字典，这个文件包含了87 314个单词。你的程序不需要找到两个单词之间最短的词语阶梯，如果存在这样的词语阶梯，那么找到任意一条都可以。

9.有关File类的描述可以在Oracle的Java网站[http://docs.oracle.com/javase/7/docs/api/java/io/File.html](http://docs.oracle.com/javase/7/docs/api/java/io/File.html)上获取，为了使用这个类，必须使用import java.io.File。对于这个程序，File类中相关的方法描述如下：

·File（String pathname）——接受一个路径名的构造器，它会创建一个File对象，对应于这个路径名表示的文件或目录。

·String getAbsolutePath（）——返回File对象的路径名，例如C：\Papers\TermPaper.odt。

·String getName（）——返回File对象的名字，例如TermPaper.odt。

·boolean isDirectory（）——测试File对象是否是一个目录。

·File[]listFiles（）——如果File对象是一个目录，那么该方法会返回一个File对象数组，对应于这个目录中所有的项。

编写一个静态递归方法String searchForFile（File currentFolder，String filename），其中第一个参数应该是一个File对象，用于指定搜索名字为filename的文件时所使用的根路径。这个方法应该递归地在所有子文件夹中搜索文件，并返回第一个匹配项的完整路径名。例如，如果currentFolder被设置成了C：\，文件名是"foo.txt"，那么它可能会返回"C：\Code\Stuff\foo.txt"，如果这是该文件的有效路径的话。如果没有任何文件具有与currentFolder匹配的名字，那么该方法应该返回一个空字符串""。

10.创建一个JavaFX应用，它会用线段绘制一条分形曲线。分形是递归定义的曲线，这条曲线可以基于点p1和p2之间的线段来绘制：

![](../Images/image11309.gif)

为了绘制从p1到p2的曲线，首先要将该线段分成三段，然后添加两段并移动中间的一段，使它们构成一个正方形的三条边，如下图所示：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11310.jpeg)

注意，不要绘制箭头，在这里用它表示绘制的方向。如果p1和p2的顺序反过来，那么正方形就会位于原来线段的下方。

这个过程是递归的，并且会作用于5条新线段上的每一条，从而形成下面的曲线：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11311.jpeg)

分形是通过无限次地重复这个递归过程而给出的。当然，我们并不想这么做，我们将会在一定次数之后停止该过程。

为了绘制这条曲线，需要使用递归方法drawFractal（p1x，p1y，p2x，p2y，k）。如果k为0，那么就只绘制一条从p1到p2的线段。否则，按照前面所述的方式将这条线段分成5段，并且在这5段上递归地调用drawFractal。在递归调用中，最后一个引元为k-1。为了方便起见，你可以假设这些线段要么是垂直的，要么是水平的。

初始调用应该是drawFractal（50，800，779，800，5）。将窗口的尺寸设置为1000×1000。

11.实现第4章的编程项目17——Edoc计算器，但是要使用递归函数来计算或辅助计算你可以获得的经验值的最大值。

12.实现第8章的编程项目9，但是要使用Lambda函数来实现按钮点击事件。