   

### 11.2.2　案例研究：二分搜索

这个案例研究假设你已经阅读了第7章给出的有关数组的基础知识。我们将设计一个递归方法，辨别给定的数字是否在某个整数数组中。如果这个“香饽饽”数字在数组中，那么该方法将给出这个数字在数组中的位置的索引。

例如，假设这个数组包含一个中奖彩票的列表，我们想搜索该列表，看看是否中奖了。假设另一个数组包含这些中奖彩票的奖金额，其顺序与第一个数组中彩票的顺序相同。这样，如果我们知道中奖彩票号码的索引，就可以使用这个索引在第二个数组中定位获奖金额。

7.4.3节讨论了一个直接通过检查每个数组位置来搜索数组的方法。我们在这个案例研究中开发的方法将会比这种简单的顺序搜索快得多。但是，为了让这种更快的方法可以工作，数组必须是排好序的。假设数组已经按照升序排好序了，并且数组是完全填满的。如果该数组名为a，那么我们就会知道

![](../Images/image11260.gif)

回忆一下，顺序搜索并没有这个要求。

将这个方法设计为返回一个整数，这个整数给出了“香饽饽”数字的索引。如果这个数字不在数组中，那么该方法会返回-1。在我们考虑这个类和方法的确切设置以及如何将该方法与数组联系起来之前，先设计一些解决这个搜索问题的伪代码。

因为数组是排好序的，所以可以排除数组中不可能包含待搜索数字的部分。例如，如果我们搜索的是数字7，并且知道a[5]包含的是9，那么我们当然会知道7不等于a[5]。但是，我们可以知道得更多：因为数组是排好序的，所以我们知道

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11261.jpeg)

进而，我们知道7不等于任何i大于等于5的a[i]。因此，所有i≥5的a[i]元素都不用搜索了，因为我们无须检查就知道“香饽饽”值7不在这些元素中间。类似地，如果“香饽饽”值7大于a[5]，例如，假设a[5]是3而不是9，那么我们可以排除所有i≤5的a[i]。

我们将这些洞察表示成算法的第1稿，其中前面例子中的索引5替换成m：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11262.jpeg)

如果a[m]不是我们要找的元素，可以忽略数组的一部分，只搜索另一部分。我们对m的选择将影响到这两个部分的大小。因为我们不知道哪个部分包含a[m]，所以可以尽量让这两个部分尺寸相同。为了实现此目的，我们选择的m可以让a[m]位于数组中间，或者尽可能靠近数组的中间。因此，将前面伪代码中的步骤1替换为：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11263.jpeg)

为了厘清我们的算法，可以将索引m重命名为mid。

注意，两种else-if情况都会搜索数组的一部分，这种搜索是我们正在设计的任务的更小版本。这种洞察告诉我们应该使用递归。实际上，数组的一部分也可以用对该算法的递归调用来搜索。尽管我们需要在算法中编写两个递归调用，但是在给定的搜索过程中，只会执行其中的一个调用，因为我们只会搜索数组的一半。因此，如果a[mid]不是要搜索的元素，那么我们要么搜索a[0]到a[mid-1]，要么搜索a[mid+1]到a[a.length-1]。

但是，这里还涉及一种复杂性。（难道不总是这样吗？）为了实现这些递归调用，我们需要更多的参数。这些递归调用指定了要搜索的数组子范围。在第一种情况中，这个子范围是索引从0到mid-1的元素。在第二种情况中，这个子范围是索引从mid+1到a.lenth-1的元素。因此，我们需要两个额外的参数来指定要搜索的数组子范围的第一个和最后一个索引。将这两个额外的参数分别表示成first和last。现在，我们可以将伪代码更准确地表示成下面的样子：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11264.jpeg)

如果想搜索整个数组，初始时可以将first设置为0，将last设置为a.length-1。但是每次递归调用first和last都会使用某些其他的值。例如，如果第一次递归调用是在第5步中做出的，那么first会被设置为0，而last会被设置为mid-1。

应该总是确保我们编写的所有递归算法都不会产生无限递归，这是通过检查算法中每个可能的调用是否都能够到达某种基础情况而实现的。考虑一下在嵌套的if-else语句中的三种可能性。在第一种情况中，“香饽饽”数字在a[mid]处找到，没有任何递归调用，搜索终止，这样我们就到达了基础情况。在其他两种可能性中，都会用一个递归调用来搜索数组中一个更小的子范围。如果“香饽饽”数字在数组中，那么该算法就将搜索的范围逐渐地缩小，直至找到这个数字。但是，如果这个数字不在数组中，会怎么样呢？当这个数字不在数组中时，所产生的一系列递归调用最终能否到达某种基础情况呢？遗憾的是，不能。

但是，这个问题并不难修复。注意，在每个递归调用中，要么first的值会递增，要么last的值会递减。如果这两个索引在数值上彼此越过，导致first实际上变得比last还要大，那么我们就知道没有剩下任何还需要继续检查的索引了，而target这个数字并不在数组中。如果我们将这项测试添加到伪代码中，那么就会得到下面更完整的伪代码：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11265.jpeg)

这种搜索数组的方式称为二分搜索。在搜索时，该算法剔除了数组的一半，然后是剩下一半中的一半，以此类推。图11.3给出了这个算法如何工作的一个示例。

现在，我们需要将这个伪代码算法转译成Java代码。将这个方法命名为binarySearch，并把它放到一个名为ArraySearcher的类中。这个类有一个实例变量来命名待搜索的数组，而待搜索的数组是通过构造器赋给这个实例变量的。因为binarySearch方法具有额外的参数，所以用户总是需要将它们设置为0和a.length-1来指定需要搜索整个数组。为了不让用户去关心这个细节，我们添加了find方法，它会调用binarySearch，使得用户只需指定target的值，而无须关心这些索引。因为binarySearch方法现在只是一个辅助方法，所以我们让它成为私有的。

程序清单11.6展示了ArraySearcher类的最终代码，而程序清单11.7给出了一个展示这个类如何工作的简单程序。

程序清单11.6　二分搜索类

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11266.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11267.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11268.jpeg)

图11.3　二分搜索示例

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11269.jpeg)

图11.3　（续）

程序清单11.7　二分搜索演示程序

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11270.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11271.jpeg)

二分搜索算法非常快，它一开始就剔除了数组的一半元素，然后又剔除了数组的四分之一元素，然后是八分之一元素，以此类推。这个剔除过程意味着数组的大部分是根本不用搜索的，从而节省了大量的时间。例如，对于具有1000个元素的数组而言，二分搜索只需要将目标值与大约10个元素进行比较。相比之下，简单的顺序搜索可能需要将目标值与所有1000个元素进行比较，而平均情况下，需要进行500次比较。搜索100万个元素的数组可以给人们带来更深刻的印象，100万个元素的二分搜索只需要至多20次比较即可，而相同数组的顺序搜索平均会比较50万次，有时甚至会是100万次。

编程窍门：泛化问题

在设计递归算法时，我们经常需要解决比最初期望解决的问题更泛化的问题。例如，考虑一下上一个案例研究中的binarySearch方法。我们将它设计为不仅可以搜索整个数组，而且可以搜索数组的任何子范围。这种设计对于表示递归子情况而言是必需的。当我们设计递归算法时，情况经常如此，必须让问题更加泛化一些，使得我们可以很容易地表示递归子情况。

自测问题

8.如果数组没有排好序，二分搜索算法是否还能工作？

9.对于包含重复值的数组，二分搜索是否还能工作？数组中所有的值是否必须是不同的？

10.假设你想让ArraySearcher类可以在数值降序排序而不是升序排序的数组上正常工作，应该如何修改ArraySearcher的定义呢？