   

### 11.1.2　递归如何工作

计算机到底是怎样处理递归调用的呢？为了观察其中的细节，请考虑下面对display-AsWords方法的调用：

![](../Images/image11225.gif)

尽管程序清单11.2中的displayAsWords的定义包含递归调用，但是Java并没有做任何特殊的事情去处理上面这个调用或者任何其他对displayAsWords的调用。引元987的值会复制给该方法的参数number，然后执行所产生的代码。这段代码等价于下面的代码：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11226.jpeg)

因为987不比10小，所以会执行else后面的组合语句。这条组合语句以对display-AsWords（987/10）的递归调用开始，而该组合语句的剩余部分在这个递归调用完成之前是不会被执行的。注意，这里描述的情况在该方法调用的是另一个方法而不是递归地调用其自身时，也是如此。因此，displayAsWords（987）的代码的执行会被挂起，等待display-AsWords（987/10）完成。当递归调用的执行完成时，被挂起的计算才恢复执行，即该组合语句的剩余部分将得以执行。

新的递归调用displayAsWords（987/10）就像任何其他的方法调用一样处理：引元987/10的值会复制给参数number，然后执行所产生的代码。因为987/10的值是98，所以所产生的代码等价于下面的代码：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11227.jpeg)

再一次，方法的引元（这一次是98）不比10小，因此，这段新的代码的执行包含了递归调用，即displayAsWords（98/10）。在此处，前面的计算被挂起，等待这个递归调用完成。参数number的值是98/10的值，即9，所以下面的代码开始执行：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11228.jpeg)

因为9实际上小于10，所以if-else语句中只有第一部分会执行：

![](../Images/image11229.gif)

这种情况称为基础情况或者停止情况，即不包含任何递归调用的情况。快速浏览一下get-WordFromDigit方法的定义，它会在屏幕上显示字符串"nine"。现在，displayAsWords（98/10）这个调用完成了。

在此处，下面所示的被挂起的计算可以从箭头指向的位置之后恢复执行了。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11230.jpeg)

因此，下面的语句会执行：

![](../Images/image11231.gif)

这会导致字符串"eight"显示在屏幕上，并结束递归调用displayAsWords（98）。

这个过程就快要结束了。我们只有一项被挂起等待完成的计算了，下面的代码展示了它：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11232.jpeg)

这项计算将在箭头所指向的位置之后恢复，下面的代码将执行：

![](../Images/image11233.gif)

这条语句会导致字符串"seven"显示在屏幕上，且整个过程结束。图11.2展示了完整的递归调用序列。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11234.jpeg)

图11.2　执行递归调用

注意，在执行递归方法调用时，并没有发生任何特殊的事情。引元值复制给了参数，方法定义中的代码得以执行，就像其他任何方法调用一样。

牢记：递归成功的关键

包含对方法自身递归调用的方法定义行为不一定正确，除非遵循某些具体的编程规则。下面的规则可以应用于大多数涉及递归的情况：

·方法定义的核心必然是一条if-else语句或某条其他可以导向不同情况的分支语句，这取决于方法参数的某项属性。

·有一个或多个分支应该包含对该方法的递归调用。这些递归调用在某种意义上必须使用“更小的”引元或解决该方法所执行的任务的“更小的”版本。

·有一个或多个分支应该不包含任何递归调用。这些分支是基础情况，或者称为停止情况。

回顾：基础（停止）情况

必须设计基础情况，使得它们可以终止每一条递归调用链。一个方法调用可能会产生对同一个方法的递归调用，而这个调用又可能会产生另一个递归调用，以此类推，可能会产生一定数量的递归调用，但是每个这样的调用链都必须最终到达某种基础情况，这种情况会因为没有任何递归调用而终止调用链。否则，这种方法的调用可能永远都不会终止（或者可能直至计算机耗尽资源之前都不会终止）。

典型的递归方法定义包含一条if-else语句或者其他在多种情况中进行选择的分支语句，其中有一种或多种情况包含对该方法的递归调用，并且有一种或多种情况会以不包含任何递归调用的形式结束该方法调用。每一条递归调用链必须最终都会到达这些非递归情况之一，或者说到达这些基础情况之一。

确保总是能够到达某种基础情况的最常见的方式就是让所有对该方法的递归调用都使用“更小的”引元。例如，考虑程序清单11.2给出的displayAsWords方法。它的参数是number，并且传递给该方法的递归调用的参数是更小的值number/10。在这种方式中，递归调用链中的每一个递归调用都是在用更小的引元进行调用。因为这个方法的定义具有针对所有一位数字引元的基础情况，所以我们知道最终总是能够到达某种基础情况。