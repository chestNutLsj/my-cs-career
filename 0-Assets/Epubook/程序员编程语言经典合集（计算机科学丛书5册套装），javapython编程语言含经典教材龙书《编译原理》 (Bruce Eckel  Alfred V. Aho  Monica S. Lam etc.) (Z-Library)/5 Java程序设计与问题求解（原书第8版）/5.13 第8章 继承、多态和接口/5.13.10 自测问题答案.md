   

## 自测问题答案

1.覆盖是指重新定义基类的方法，使得它在派生类中具有不同的定义。重载是指赋予同一个方法名两个具有不同参数列表的定义。在上述两种情况下，方法都具有相同的名字。在覆盖方法定义时，在派生类中给出的新方法定义具有完全相同的名字、返回类型和相同数量与类型的参数。另一方面，如果派生类中的方法与基类中的方法具有不同数量的参数，或者其某个参数具有不同的类型，那么派生类中将同时拥有这两个方法，这就是重载。你可以在不涉及基类的情况下，在单个类中重载方法名。

2.没有，派生类没有继承其基类的私有实例变量。但是，SportsCar可以访问或修改speed、manufacturer和numberOfCylinders的值，前提是基类提供了用于此目的的公有方法。

3.是的，它拥有这些方法。派生类拥有基类拥有的所有公有方法，它们在派生类中执行的动作与在基类中执行的动作完全相同。但是，派生类可以包含这些方法的新的覆盖定义，该新定义将替换旧定义，只要它具有相同的名字、返回类型以及相同数量与类型的参数。

4.不行

5.不行

6.hasSameName方法没有在Student的类图中列出。因此，你应该顺着箭头查看Person的类图，hasSameName方法在Person的类图中。这个方法的参数的数据类型是Person，但是因为你知道一个Student对象就是一个Person对象，所以你可以将一个Student对象作为引元传递给这个方法。因此，用于hasSameName方法的定义在Person的类图中。

7.你可以从Student的类图入手。setStudentNumber方法在Student的类图中，因此无须再继续查找，用于setStudentNumber方法的定义就在Student的类图中。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10938.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10939.jpeg)

12.是的。如果类A是从类B中派生的，那么B类型的对象就可以被A类型的变量和B类型的变量所引用。

13.Undergraduate、Student和Person类型的变量可以引用这个对象。（正如你很快就会在本章中所看到的，Object类型的变量也可以引用这个对象。Object是一个Java预定义的类，我们将在下一节介绍它。）

14.它可用作基类构造器的名字。（请查看程序清单8.2。）在用作接收对象时，例如在super.writeOutput（）中，super表示应该调用基类中的方法。例如，在程序清单8.4中，这条语句调用的是基类Student的writeOutput，而不是Undergraduate类中的writeOutput方法。

15.关键词this在用作方法名时，命名的是与其同属一个类中的构造器。关键词super在用作方法名时，命名的是正在被定义的派生类的基类中的构造器。

16.因为toString返回的值包含了换行符'\n'。

17.a）合法，一个Student就是一个Person。

b）合法，一个Undergraduate就是一个Person。

c）非法，Person对象无法执行Student所有的动作。

d）合法，一个Undergraduate就是一个Student。

e）非法，Person对象无法执行Undergraduate所有的动作。

f）非法，Student对象无法执行Undergraduate所有的动作。

g）合法，一个Student就是一个Object。

h）非法，Object对象无法执行Student所有的动作。

18.多态意味着通过使用动态绑定机制，使得对于对象来说，无论命名它们的变量的类型是什么，它们都可以执行正确的行为。方法名的含义依赖于变量所命名的对象。

19.动态绑定和延迟绑定是同一件事情的两种表述（所以我们只给出了一个定义和一个示例。）有了动态绑定，或者说延迟绑定，方法调用的含义在运行程序时才与其所在位置绑定。Java使用了动态绑定。在决定需要使用方法的哪个定义时，Java使用的实际上是在用new操作符创建对象时所使用的类中的定义，而并非必需使用命名该对象的变量所属类型中的定义。

20.这个问题可能没有确定的答案。在多态最初的定义中，认为重载是多态的一个例子，有些书仍旧使用这种旧的定义。在目前的用语以及在本书中，重载方法名并不是多态的例子。

21.不，它们会产生不同的输出。第一个输出的是名字Sam，学号9999，而第二个输出的是名字Sam，学号9999，以及学生等级1。

22.使用的是Undergraduate中给出的writeOutput的定义，而不是Person中给出的write-Output定义，因为p引用的是一个Undergraduate对象。

23.不行。Oval类必须包含一个implements子句，声明它实现了Measurable。

24.是的，一个类可以实现多个接口。在关键词implements后面直接列出这些接口，中间用逗号分隔。

25.可以。

26.不行。

27.覆盖。

28.覆盖。

29.重载。

30.不行。派生类不能继承私有方法。如果我们让skipSpaces成为公有方法而不是私有方法，那么就可以执行这种移动。更好的解决方案是定义一个包含公有静态方法的工具类，其拥有的公有静态方法包括skipSpaces方法和用来绘制水平线段、大V形状和倒转的大V形状的方法。

31.drawHere方法可以调用两个私有方法drawTop和drawBottom。我们可以使用Triangle中的drawTop，其中变量base是菱形的宽度。drawBottom与drawTop类似，只是要进行如下修改：startOfLine从偏移量开始，insideWidth从2*lineCount–1开始，每次迭代后，startOfLine递增1，而insideWidth递减2。skipSpaces方法与Triangle的版本相同。

32.不是，它并不合法，因为程序清单8.19中的ShapeBase是抽象类。

33.是的，它是合法的。

34.事件处理器是实现了预定义接口的方法。

35.让主应用类成为事件监听器对象的优点是事件处理器可以很方便地访问在这个类中定义的其他GUI控件。并且，你还无须创建单独的类。缺点是你只能有该主应用类的一个实例，因此你无法让不同的UI控件拥有单独的事件监听器。因此，handle方法需要确定触发事件的源控件，而不是每个源控件都有自己专用的处理器。

36.一个匿名内部类。