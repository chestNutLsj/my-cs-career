   

### 8.1.1　派生类

假设我们正在设计一个大学备案程序，它保存了所有学生、教师和其他员工的记录。有一种很自然的层次结构可以用来群组这些记录类型：它们都是有关人的记录，学生是人的一个子类，雇员是另一个子类，而雇员又包含教师和员工两种。学生也可以再分成两个更小的子类：本科生和研究生。这些子类还可以更进一步地分成更小的子类。

图8.1描述了这种层次排列结构的一部分。尽管你的程序可能不需要任何对应于人或雇员的类，但是依据这些类来思考问题是有益的。例如，所有人都有姓名，而初始化、显示和修改姓名的方法对于学生、员工和教师记录来说，都是相同的。在Java中，你可以定义一个名为Person的类，它包含的实例变量表示人的所有子类都具有的属性。这个类定义还可以包含所有操作Person类中实例变量的方法。实际上，在程序清单8.1中，已经有了一个这样的Person类。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10767.jpeg)

图8.1　一个类层次结构

程序清单8.2给出了学生类的定义。学生就是人，因此我们将Student类定义为Person类的派生类或子类。派生类是通过在既有类中添加实例变量和方法而定义的类。我们称派生类扩展了既有类，而派生类所基于的既有类称为基类或超类。在我们的示例中，Person是基类，而Student是派生类。在程序清单8.2中，我们通过在Student类定义的第一行包含extends Person短语来表示这一点，所以，Student的类定义以下面这样的语句开始：

![](../Images/image10768.gif)

程序清单8.2　一个派生类

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10769.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10770.jpeg)

像任何其他的派生类一样，称Student类为继承了它所扩展的基类的公有实例变量和公有方法。当定义派生类时，只需给出新添加的实例变量和方法。即使Student类拥有Person类的全部公有实例变量和所有公有方法，但是我们在Student的定义中并没有声明或定义它们。例如，Student类的每个对象都有getName方法，但是我们没有在Student类的定义中定义getName。

像Student这样的派生类还可以在那些从基类继承而来的实例变量或方法的基础上添加新的实例变量或方法。例如，Student定义了实例变量studentNumber和方法reset、getStudentNumber、setStudentNumber、writeOutput、equals以及一些构造器。（我们把对构造器的讨论延后到解释完这些类定义的其他部分之后再进行。）

注意，尽管Student没有继承Person的私有实例变量name，但是它继承了方法setName和基类其他所有的公有方法。因此，Student可以间接地访问name，所以也就不需要定义其自己的版本了。如果s是按如下方式定义的Student类的新对象：

![](../Images/image10771.gif)

那么我们可以编写：

![](../Images/image10772.gif)

因为name是Person的私有变量，所有不能在Person的类定义外部编写s.name，甚至在Student的定义内部也不行。但是，这个实例变量是存在的，可以通过在Person内定义的方法来访问和修改它。程序清单8.3包含了一个非常简单的用来展示继承的演示程序。

Student对象具有Person的所有方法以及Student的所有方法。之前，我们注意到，学生就是人。Student和Person类对现实世界中Student具有Person的全部行为这种关系进行了建模。我们称这种关系为“是一个”关系。只有在一个类和所提议的派生类之间存在“是一个”关系时，才应该使用继承。

程序清单8.3　使用Student演示继承的程序

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10773.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10774.jpeg)

编程窍门：只有对“是一个”关系建模时才使用继承

如果两个提议的类之间不存在“是一个”关系，那么就不要用继承从一个类派生出另一个类。我们应该考虑在一个类的内部将另一个类的对象定义为实例变量。这种关系被称为“有一个”关系。名称为“是一个和有一个关系”的编程窍门会更深入地讨论这两种关系。

当讨论派生类时，通常会使用从家庭关系派生出来的术语。基类经常称为父类，而派生类经常称为子类。这使得有关继承的话可以说得很自然。例如，我们可以称子类从其父类那里继承了公有实例变量和公有方法。

这种类比还会更近一步。如果一个类是另一个类的父类的父类的父类（或者任意数量的“父类”），那么就会称其为祖先类。如果类A是类B的祖先类，那么类B就是类A的后裔类。

回顾：派生类

你可以以一个定义好的类为基础，通过添加（或修改）方法和实例变量来定义派生类或子类。你基于的类称为基类或超类。派生类从基类处继承了所有公有方法和公有实例变量，并可以添加更多的实例变量和方法。

语法

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10775.jpeg)

示例

查看程序清单8.2。

正如你在下一节中将会看到的，对方法进行修改也称为覆盖。

派生类也称为子类、孩子类或后裔类。