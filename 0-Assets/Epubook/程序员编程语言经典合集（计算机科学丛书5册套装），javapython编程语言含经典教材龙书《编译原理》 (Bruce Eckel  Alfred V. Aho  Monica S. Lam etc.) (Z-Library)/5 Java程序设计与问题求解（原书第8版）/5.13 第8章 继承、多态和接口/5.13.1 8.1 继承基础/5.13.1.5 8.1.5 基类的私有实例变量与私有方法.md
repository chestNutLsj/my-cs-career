   

### 8.1.5　基类的私有实例变量与私有方法

派生类Student（程序清单8.2）的对象没有从基类Person（程序清单8.1）中继承实例变量name的值，但是它可以通过Person的公有方法来访问和修改name的值。例如，下面的语句就创建了一个Student对象，并设置了实例变量name和studentNumber的值：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10779.jpeg)

因为实例变量name是Person类定义中的私有实例变量，所以在Student类定义中不能直接用名字访问它。因此，Student类中的reset方法的定义如下：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10780.jpeg)

但是，它的定义不能像下面这样：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10781.jpeg)

正如注释所表示的，第一条赋值语句无法工作，因为派生类并没有从其基类处继承私有实例变量。因此，Student类中的reset的定义需要使用setName方法来设置name实例变量。

疑难杂症：私有实例变量在派生类中不能直接访问

派生类不能用名字直接访问其基类中的私有实例变量。它只知道其基类的公有行为。派生类并不知道或者说不关心其基类是如何存储数据的。但是，继承而来的公有方法可以包含对私有实例变量的引用。

基类的私有实例变量不能在派生类的方法定义中用名字访问，这一点在许多人看来是错误的。毕竟，学生应该能够修改它们自己的名字，而不是被告知“对不起，name是Person类的私有实例变量”。如果你是一名学生，那么你同时也是一个人。在Java中，这也是成立的，Student类的对象也是Person类的对象。但是，有关私有实例变量的使用规则必须是我们所描述的那样，否则，指定为私有就没有任何意义。如果一个类的私有实例变量在派生类的方法定义中是可访问的，那么无论何时，只要你想访问该私有实例变量，就可以直接创建一个派生类，然后在派生类的方法中访问它。这意味着所有私有实例变量对任何只想付出极小代价的人来说，都是可访问的。

类似地，基类中的私有方法也不能在任何其他类中用名字直接访问，甚至在派生类中也不行。但是，私有方法确实存在。如果派生类调用了继承而来的公有方法，而该公有方法又包含了对某个私有方法的调用，那么对私有方法的调用仍旧可以工作。但是，派生类不能定义直接调用基类私有方法的方法。这应该不是个问题。私有访问只应该起到辅助方法的作用，因此对它们的使用应该局限在定义它们的类内部。如果想要让某个方法可以在大量的派生类中起到辅助方法的作用，那么它就不仅仅只是一个辅助方法，你应该让它成为公有方法。

疑难杂症：不能在派生类中直接访问私有方法

派生类不能调用在基类中定义的私有方法。但是，如果基类中某个公有方法调用了同在一个基类中的某个私有方法，那么派生类是可以调用这个公有方法的。

编程窍门：假定你的合作者是具有恶意的

私有实例变量不能在派生类中通过名字来访问是因为如果可以这样做，那么怀有恶意的程序员就会使用某种小伎俩来访问它们。你可能会争辩，你的合作者并没有恶意。事实上，在这门启蒙课程中，你有时可能是某项作业上唯一的程序员，你当然不会试图破坏你自己的工作，这是好的方面。但是，你的合作者，有时甚至是你自己，可能会在漫不经心间做了这样的事情，尽管其意图可能并非是恶意的，但是问题还是产生了。我们认为程序员怀有恶意，并非是因为我们真的认为我们的合作者怀有恶意，而是因为这是防止好心的程序员制造无心之失的最佳方式，这里说的程序员包括你在内！