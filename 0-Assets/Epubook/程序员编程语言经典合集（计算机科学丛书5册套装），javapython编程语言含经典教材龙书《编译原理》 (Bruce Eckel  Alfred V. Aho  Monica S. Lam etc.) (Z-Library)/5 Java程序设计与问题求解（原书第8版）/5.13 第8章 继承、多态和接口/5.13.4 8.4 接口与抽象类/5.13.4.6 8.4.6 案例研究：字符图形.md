   

### 8.4.6　案例研究：字符图形

Java具有在计算机屏幕上绘制图形的方法。但是，设想一下，如果你正在为廉价的设备设计程序，而该设备的屏幕不具备任何图形化的能力，只允许使用文本输出，该怎么办呢？在本案例研究中，我们将设计3个接口和3个类，它们可以通过在屏幕的每一行上放置普通的键盘字符来绘制简单的形状，从而在屏幕上产生图形。我们的绘图并不复杂，但是可以通过它探索在解决实际问题时如何使用接口和继承。

让我们从编写接口开始，首先编写的接口将指定我们的对象应该具有的方法。假设drawHere方法将从当前的行开始绘制形状，而drawAt方法将沿当前行向下移动给定数量的行之后绘制形状。

所有形状都具有某些公共属性。例如，每个形状都有一个偏移量，告知它距离屏幕左边缘缩进了多少。我们可以包含设置和获取该偏移量的方法。每个形状还都有尺寸，但是有些形状的尺寸是由单个数字描述的，而有些形状的尺寸是由多个数字决定的。因为尺寸会根据形状的种类而决定，所以它并不是所有形状都公有的属性。程序清单8.10包含的接口指定了所有形状都应该拥有的方法。

程序清单8.10　使用键盘字符绘制形状的接口

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10873.jpeg)

假设我们想绘制矩形和三角形。矩形的尺寸是由其宽度和高度给出的，这两个维度可以表示成大量的字符。因为字符的高度比宽度在数值上更大，所以这样的矩形看起来会比我们预期的更高。例如，5×5的矩形在屏幕上看起来就不是正方形，而是像图8.5所示的样子。

假设我们决定三角形在显示时，总是有一个顶点在上面，一条边在底部。在选择了底边的边长之后，为了让另外两边看起来平滑，两条斜边的坡度被限制为每行只缩进一个字符。因此，一旦选择了底边，我们就没有办法选择三角形两条斜边的样子了。图8.5还展示了一个三角形样例。

如果我们同意只在形状的构造器中指定其偏移量和尺寸，那么在程序清单8.10中编写的接口就够用了。但是假设我们还希望能够重新定义已有矩形的尺寸，即，我们希望有一个修改器方法。由于形状的尺寸取决于正在绘制的形状，所以我们再多定义两个接口——一个用于矩形，一个用于三角形。程序清单8.11中就包含了这两个接口。注意，这两个接口都扩展了ShapeInterface。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10874.jpeg)

图8.5　矩形和三角形的样例

程序清单8.11　绘制矩形和三角形的接口

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10875.jpeg)

现在，我们有了自己的规范，因此可以尝试着编写一些使用我们的绘制方法的Java语句。例如，我们可以在当前的行上绘制一个8×4的偏移量为5的矩形，就像下面这样：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10876.jpeg)

然后，我们可以修正对象box的尺寸和缩进量，并且在屏幕上向下移动两行后绘制它，就像下面这样：

![](../Images/image10877.gif)

![](../Images/image10878.gif)

我们的规范看起来是合理的，因此我们现在将继续讨论有关实现的话题。让我们编写一个名为ShapeBasics的基类，它实现了ShapeInterface接口。随后，我们可以从这个基类派生出Rectangle和Triangle类。我们知道唯一公共的属性就是偏移量，所以ShapeBasics类只有下面的实例变量：

![](../Images/image10879.gif)

我们的接口指定了类的方法，因此只需要定义它们并添加一些适合的构造器即可。程序清单8.12包含了ShapeBasics类的定义。

程序清单8.12　基类ShapeBasics

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10880.jpeg)

drawAt方法有一个int类型的参数，它的值表示在绘制形状之前应该插入多少个空行，而形状是通过调用drawHere绘制的。

drawHere方法会在屏幕上缩进许多空格，空格个数在数量上等于偏移量。这个简单的输出只是为了进行测试，并不会在任何实际应用中使用这个版本的drawHere，你应该在定义矩形类和三角形类时覆盖drawHere的定义。

现在，让我们将注意力转向绘制矩形的类。这个类名为Rectangle，应该是Shape-Basics的派生类。因此，该类的定义应该以下面的语句开头：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10881.jpeg)

因为想要让我们的类实现RectangleInterface，所以我们添加了implements子句，就像下面这样：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10882.jpeg)

当同时包含extends子句和implements子句时，extends子句总是应该在前。有一种方式能够很容易地记住这两个子句的顺序，那就是关键词extends和implements是按照字母序排序的。

我们需要决定除了已经在ShapeBasics类中的实例变量外，还需要添加哪些实例变量。我们还要决定是否需要覆盖ShapeBasics中的某些方法定义。我们的类Rectangle可以使用基类中的实例变量offset，但是还需要有表示矩形高度和宽度的实例变量。因此，该类的定义看起来像下面这样：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10883.jpeg)

注意，我们没有在Rectangle中列出实例变量offset。

我们知道Rectangle需要常见的构造器和设置边的方法。Rectangle从ShapeBasics类中继承了setOffset、getOffset、drawAt和drawHere方法。但是，我们需要覆盖draw-Here方法的定义，使得它绘制的确实是矩形。我们需要覆盖drawAt方法吗？当我们观察程序清单8.12中的drawAt时，就会发现，只要drawHere是正确定义的，那么drawAt就可以在矩形或其他任何形状上正常工作。多态确保了drawAt调用的是drawHere的正确版本。

让我们先观察一个样例构造器，它会将所有的实例变量都设置成为其引元给定的值。但是有一个实例变量（即offset）是基类ShapeBasics的私有实例变量，因此我们无法直接通过名字访问它。但是，我们可以调用setOffset方法或者使用super调用基类的构造器。我们选择了后者，因此这个构造器的定义如下：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10884.jpeg)

与上面的构造器类似，缺省构造器会调用基类的缺省构造器，并将矩形的尺寸设置为0。我们可以在缺省构造器中删除对super的显式调用，因为它无论如何都会被自动调用，但是为了表达清晰，我们保留了它。

在RectangleInterface中指定的set方法显得很直接，因此让我们来测试drawHere方法，它非常依赖于其正在绘制的形状的特性。我们可以使用一种名为“自顶向下设计”的技术。在这项技术中，我们会将要执行任务分解为子任务。我们会得到下列子任务：

绘制矩形的算法

1）绘制顶边的线段。

2）绘制两条侧边的线段。

3）绘制底边的线段。

注意，并非每一种任务分解的方式都行得通。我们可能最先会试图将绘制框体两条侧边的任务分解为两个子任务。但是，输出必须是一行接着一行的，并且没有办法回退，所以，我们必须同时绘制两条侧边，使得它们可以并排显示，这正是我们所需要的。

drawHere方法的定义很简单：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10885.jpeg)

尽管很简单，但是它将大部分的工作都推到后面去实现了。我们仍旧需要定义draw-HorizontalLine和drawSides方法。因为这些都是辅助方法，所以它们都将是私有方法。

drawHorizontalLine的逻辑并不复杂，正如下面的伪代码所示：

drawHorizontalLine的算法

1）显示offset个空格。

2）显示width个字符'-'。

3）system.out.println（）；

书写指定数量空格的任务可以通过另一个名为skipSpaces的辅助方法来实现，该方法只是一个简单的循环。drawHorizontalLine方法的最终代码为：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10886.jpeg)

接下来，我们考虑drawSides方法，它的任务是绘制像下面这样的图形：

![](../Images/image10887.gif)

因为每条线段都是相同的，所以我们可以将显示其中一条线段当作一个子任务。因此，drawSides方法的定义为：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10888.jpeg)

注意，我们显示的线段比高度要求的少了两行，这是因为顶边和底边的水平线段占据了额外的两个单位的高度。

剩下的工作就是定义辅助方法drawOneLineOfSides。因为我们已经有了一个用来执行书写空格子任务的方法，所以drawOneLineOfSides的伪代码会转换为下面的Java代码：

![](../Images/image10889.gif)

我们基本上完成任务了。程序清单8.13给出了Rectangle完整的类定义。

程序清单8.13　Rectangle类

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10890.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10891.jpeg)

尽管不会描述这个案例研究中的测试过程，但是在ShapeBasics类、Rectangle类和Triangle类中的所有方法（Triangle类中的方法尚未讨论）都需要被测试。记住，每个方法都应该在只有该方法是未测试方法的程序中测试。

程序清单8.14包含了Triangle类的定义。我们使用的技术与设计Rectangle类时使用的技术相同。我们只讨论drawHere方法的一部分内容，其技术细节在一开始也许并不那么清晰。drawHere方法将其任务分解为两个子任务：绘制倒转过来的V，作为三角形的上半部分，绘制水平线作为三角形的底。

程序清单8.14　Triangle类

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10892.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10893.jpeg)

drawTop方法绘制的形状如下：

![](../Images/image10894.gif)

注意，整个形状是有偏移量的，形状底边缩进量的宽度就是这个偏移量。但是，随着自底向上移动，每一行的缩进量都会变大。或者说，按照计算机执行的顺序，随着自顶向下移动，每一行的缩进量都在按照一行一个字符的方式减小。因此，如果三角形顶点的缩进量是由int变量startOfLine的值给出的，那么第一行缩进可以用下面的语句来执行：

![](../Images/image10895.gif)

然后，我们书写一个星号。

在书写完第一行的星号后，我们需要为两条侧边的后续部分书写两个星号。我们编写了一个循环，在每次迭代时将startOfLine递减1，并执行与之前对skipSpaces调用完全相同的语句。然后，我们书写一个星号，并且在书写第二个星号之前，跳过一定数量的空格。一行中两个星号之间的空隙在逐行下移的过程中会不断地递增2。如果这个空隙是由int变量insideWidth的值给定的，那么绘制除顶点星号之外的所有倒转V的循环可以写成下面的样子：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10896.jpeg)

程序清单8.14给出了drawTop方法的完整定义。

三角形的底边是一条由星号构成的边，我们应该使用奇数个星号，否则画出来的三角形看起来稍微有些不平衡。但是，为了让这个类保持简单，我们只是将其描述为Triangle类的set方法的前置条件，而不会试图去强制要求这一点。

程序清单8.15所示的样例应用程序演示了我们的类的用法，它绘制了一个三角形和一个矩形，从而构成了一张粗略的杉树图片。

程序清单8.15　Triangle和Reactangle的演示程序

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10897.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10898.jpeg)

自测问题

27.程序清单8.13中给出的drawHere的定义是重载还是覆盖？

28.程序清单8.14中给出的drawHere的定义是重载还是覆盖？

29.程序清单8.14中给出的两个构造器定义是重载还是覆盖？

30.Rectangle类的定义（程序清单8.13）和Triangle类的定义（程序清单8.14）中都出现了私有方法skipSpaces。我们是否可以将这个方法移到基类ShapeBasics（程序清单8.12）中，使得Rectangle和Triangle都可以继承它而不用各自都需要定义自己的版本？

31.描述从ShapeBasics类派生出来的名为Diamond的类的drawHere方法的实现。本章末尾的编程项目2会让你实际编写这个类。（提示：Diamond类与Triangle类相似。）