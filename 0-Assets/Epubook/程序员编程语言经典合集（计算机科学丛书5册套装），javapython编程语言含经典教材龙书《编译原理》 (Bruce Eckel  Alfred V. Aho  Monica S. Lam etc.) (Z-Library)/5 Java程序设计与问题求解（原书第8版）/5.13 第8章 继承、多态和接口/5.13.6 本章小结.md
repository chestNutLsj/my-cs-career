   

## 本章小结

·Java接口包含公有方法头和公有具名变量的定义。它并没有声明任何构造器或私有实例变量。

·实现某个接口的类必须为该接口中指定的每个方法都定义一个方法体，这个类还可以定义一些在接口中没有声明的方法。类可以实现多个接口。

·接口为类的设计者提供了一种为其他程序员指定方法的方式。通过实现接口，程序员可以确认这个类实现了某些方法。

·接口是一种引用类型，因此我们可以声明具有接口类型的变量和方法参数。

·我们可以通过扩展接口来创建新的接口，新接口中包含已有接口中的方法，以及一些新的方法。

·动态绑定或延迟绑定是一种使得具有相同接口的不同的类的对象可以彼此替换的处理。这种能力称为多态，使得不同的对象可以针对相同的方法名执行不同的方法动作。

·派生类是通过在基类中添加实例变量和方法而获得的。派生类继承了基类中所有的公有实例变量和公有方法。

·在定义派生类的构造器时，我们的定义应该首先通过使用super来调用基类的构造器。如果没有做出显式的调用，Java会自动调用基类的缺省构造器。

·在构造器中，this调用的是同一个类的某个构造器，但是super调用的是基类的构造器。

·我们可以重新定义从基类继承而来的方法，使得它在派生类中具有不同的定义。这称为覆盖该方法的定义。

·在覆盖方法定义时，在派生类中给出的新的方法定义必须与基类中的该方法具有相同的名字、数量和类型完全相同的参数以及相同的返回类型。如果派生类中的方法与基类中的该方法相比，具有不同数量的参数，或者某个对应位置上的参数类型不同，那么该方法就是被重载了，而不是被覆盖了。

·在派生类的方法定义中，我们可以通过在方法名前面加上super和圆点来调用基类被覆盖的方法。

·基类的私有实例变量和私有方法在派生类中无法直接访问。

·派生类的对象具有派生类的类型，同时也具有基类的类型。更普遍地讲，派生类具有其每一个祖先类的类型。

·我们可以将派生类的对象赋值给其任何祖先类型的变量，但是反过来不行。

·在Java中，每个类都是预定义类Object的子孙类。所以每个类的每个对象都具有Object类型，以及其自己的类的类型和任何其他祖先类的类型。

·JavaFX使用事件处理器来响应事件，事件处理器就是基于接口实现的。