   

### 8.3.1　动态绑定和继承

考虑图8.4中所描述的使用了Person、Student和Undergraduate类的程序。假设我们想要设置一个由4个人构成的委员会，这些人可以是学生或雇员。如果我们使用数组来存储委员会成员的列表，那么创建Person类型的数组就会具有实际意义，因为在其中可以放置任何从Person派生出来的类。下面是一个可能的数组声明：

![](../Images/image10836.gif)

接下来，我们可能会将对象添加到表示委员会成员的数组中。在下面的示例中，我们添加了3个Undergraduate类型的对象和一个Student类型的对象（也许我们并不知道这个人是本科生还是研究生）：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10837.jpeg)

在这种情况中，我们是在将派生类（Student或Undergraduate）的对象赋值给定义为该派生类祖先（Person）类型的变量。这是合法的，因为Person包含派生类。换句话说，Student“是一个”Person，Undergraduate也“是一个”Person，因此，我们可以将它们任何一个赋值给Person类型的变量。

接下来，让我们输出一张包含所有委员会成员相关信息的报表，这张表报应该尽可能地详细。例如，如果某个学生是位本科生，那么这张报表应该包含该学生的姓名、学号和年级。如果该学生是Student类型，那么该报告应该包含其姓名和学号。对于雇员也希望给出类似的细节。writeOutput方法包含这些细节，但是要调用哪一个呢？总共有3个writeOutput方法，分别是在Undergraduate、Student和Person中定义的。

如果我们只关注people[0]，那么就会看到它被声明成了Person类型的对象。如果我们调用：

![](../Images/image10838.gif)

那么认为将会调用Person类中定义的writeOutput方法就是符合逻辑的想法。但是，事情并非如此！Java会意识到是一个Undergraduate类型的对象存储在了people[0]中，因此，尽管people[0]被声明成了Person类型，但是被调用的是用来创建该对象的类所关联的方法。这称为动态绑定或延迟绑定。

更准确地讲，当调用被覆盖的方法时，它的行为就是使用new操作符创建该对象时所使用的类中定义的行为，而不是由命名该对象的变量的类型所决定的。任何祖先类的变量都可以引用其子孙类的对象，但是该对象总是会记住针对每个方法名应该执行哪个方法的行为。变量的类型并不重要，重要的是在创建对象时所使用的类名。

回到我们的报表，将用下面的代码来生成它：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10839.jpeg)

这段代码的输出为：

![](../Images/image10840.gif)

![](../Images/image10841.gif)

程序清单8.6给出了完整的程序。

程序清单8.6　一个多态的演示程序

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10842.jpeg)

有关多态最令人惊叹的是它甚至允许我们去调用可能尚不存在的方法！例如，假设在编写和运行程序清单8.6中的程序时，只定义了Person、Student和Undergraduate类。后来，我们可能会编写出图8.1中所描述的Employee、Faculty和Staff类。因为所有这些类都是从Person类中派生的，所以只要每个类都实现了writeOutput方法，那么我们就可以将这些对象添加到数组中，在for循环中就会调用它们的writeOutput方法。我们甚至不需要重新编译程序清单8.6中的PolymorphismDemo类，就可以通过动态绑定来调用新的方法。  

旁白：Java假定会发生动态绑定  

在许多其他语言中，你必须事先指定哪些方法可能需要动态绑定，而Java总是假定会发生动态绑定。尽管做出这种假定在效率上会受损，但是这使得Java更易于编程，并且更不容易犯错。  

牢记：对象知道它们应该如何行动

当调用被覆盖的方法时，它的行为就是在使用new操作符创建对象时所使用的类中定义的行为。它不是由命名对象的变量的类型所决定的。变量的任何祖先类都可以引用其子孙类的对象，但是对象总是会记住针对每个方法名应该执行哪个方法行为。变量的类型并不重要，重要的是在创建对象时所使用的类名。这是因为Java使用了动态绑定。