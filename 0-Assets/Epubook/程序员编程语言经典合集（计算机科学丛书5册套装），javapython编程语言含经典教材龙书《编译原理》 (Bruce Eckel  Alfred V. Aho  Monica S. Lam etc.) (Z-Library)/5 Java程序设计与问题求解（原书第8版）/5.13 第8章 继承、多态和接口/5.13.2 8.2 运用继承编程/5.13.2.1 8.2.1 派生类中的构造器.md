   

### 8.2.1　派生类中的构造器

像程序清单8.2中Student类这样的派生类具有自己的构造器，它没有从基类继承任何构造器。像Person这样的基类也有其自己的构造器。在派生类的构造器的定义中，在典型情况下，第一个动作都是对其基类构造器的调用。例如，让我们考虑如何为Student类定义构造器。学生名字是需要初始化的东西，由于实例变量name是在Person的类定义中定义的，所以正常情况下，它是由基类Person的构造器初始化的。

考虑下面的在派生类Student（程序清单8.2）中的构造器定义：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10788.jpeg)

这个构造器使用了保留词super作为方法名去调用基类的构造器。尽管基类Person定义了两个构造器，但是下面的调用：

![](../Images/image10789.gif)

是该类中具有一个字符串参数的那个构造器的调用。注意，这里使用的是关键词super，而不是构造器的名字。即，不能使用下面的写法：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10790.jpeg)

常见问题：如何才能记住super调用的是基类而不是派生类的构造器

回忆一下，基类的另一个称谓是超类（superclass），所以super调用的是当前类的超类的构造器。

super的用法还涉及一些细节：它必须总是构造器定义中第一个执行的动作，我们无法在定义的后续部分中使用super。如果没有在派生类的构造器中包含对基类构造器的显式调用，那么Java就会自动包含一个对基类缺省构造器的调用。例如，程序清单8.2中给出的Student类的缺省构造器的定义如下：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10791.jpeg)

完全等价于下面的定义：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10792.jpeg)

回顾：调用基类构造器

在定义派生类的构造器时，你可以使用super作为基类构造器的名字，任何对super的调用都必须是构造器执行的第一个动作。

示例

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10793.jpeg)

疑难杂症：在构造器中忽略对super的调用

如果在派生类构造器中忽略对基类构造器的调用，那么对基类缺省构造器的调用就会成为这个新构造器中的第一个动作。这个缺省构造器（即不带参数的构造器）也不并非是应该被调用的构造器。因此，包含你自己的对基类构造器的调用通常会是一个好主意。

例如，在Student类的第二个构造器中忽略super（initialName）会导致调用Person的缺省构造器，这个动作会将学生的名字设置成为"No name yet"而不是字符串initialName。