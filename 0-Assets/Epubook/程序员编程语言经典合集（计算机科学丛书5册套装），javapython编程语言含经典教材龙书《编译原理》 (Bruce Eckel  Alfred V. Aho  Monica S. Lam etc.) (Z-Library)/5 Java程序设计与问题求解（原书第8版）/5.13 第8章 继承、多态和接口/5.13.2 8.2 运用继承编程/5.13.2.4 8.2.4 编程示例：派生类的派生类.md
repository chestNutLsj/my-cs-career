   

### 8.2.4　编程示例：派生类的派生类

我们可以从派生类中产生派生类。实际上，这很常见。例如，我们之前就从Person类（程序清单8.1）派生了Student类（程序清单8.2）。现在，我们从Student类派生Undergraduate类，如程序清单8.4所示。图8.4包含了一张UML图，展示了Person、Student和Undergraduate类之间的关系。

程序清单8.4　派生类的派生类

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10801.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10802.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10803.jpeg)

图8.4　图8.2中所示类层次结构的更多细节

Undergraduate类的对象具有Student类中所有的公有成员。但是，Student已经是Person的派生类了。这意味着Undergraduate类的对象也具有Person类的所有公有成员。Person类的对象具有实例变量name，Student类的对象具有实例变量student-Number，Undergraduate类具有实例变量level。尽管Undergraduate类的对象没有继承实例变量name和studentNumber，因为它们是私有的，但是它可以使用继承而来的访问器和修改器方法来访问并修改它们。实际上，Student类和Undergraduate类以及从它们派生出来的任何其他类，都重用了Person类的定义中给出的代码，因为它们都继承了Person类的所有公有方法。

Undergraduate类的每个构造器都是以对super的调用开头的，在其上下文中，super表示基类Student的构造器。但是Student类的构造器也是以对super的调用开头的，而此时super表示基类Person的构造器。因此，当用new调用Undergraduate中的构造器时，Person和Student的构造器会先被调用，然后再执行Undergraduate构造器中跟在super之后的代码。

Student和Undergraduate类都定义了一个名为reset的方法。在Student中，reset有两个参数，而在Undergraduate中，reset有三个参数，所以reset是被重载了的名字。Undergraduate类中的reset方法（即下面呈现的代码）是以对reset的调用开头的，传递给reset的引元只有2个：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10804.jpeg)

因此，这个调用是对基类Student中定义的名为reset的方法的调用，它会修改实例变量name和studentNumber。然后，Undergraduate的reset方法会通过调用setLevel来修改新的实例变量level。

还记得吗？在Undergraduate类的定义中，分别来自基类Person和Student的私有实例变量name和studentNumber无法用名字来引用，因此需要有修改器方法来修改它们。Student类的reset方法是很适合用来实现此目的。

因为Undergraduate类中定义的reset版本与Student类中定义的reset版本具有不同数量的参数，因此在派生类Undergraduate中同时包含这两个版本不会产生任何冲突。换句话说，我们可以重载reset方法。相比之下，Undergraduate中writeOutput方法的定义（即下面呈现的代码）与基类Student中的writeOutput版本具有完全相同的参数列表：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10805.jpeg)

因此，当调用writeOutput时，Java必须决定使用writeOutput的哪一个定义。对于派生类Undergraduate的对象来说，它使用的是在Undergraduate类的定义中给出的writeOutput版本。Undergraduate中的版本覆盖了基类Student中给出的定义。为了在派生类Undergraduate的定义中调用Student中定义的writeOutput版本，必须将super和圆点置于方法名writeOutput之前，就像前面看到的那样。

现在，考虑Student类和Undergraduate类中名为equals的方法，它们具有不同的参数列表。Student类中的equals具有一个Student类型的参数，而Under-graduate中的equals具有Undergraduate类型的参数。它们具有相同数量的参数，都是1个，但是在这两个版本的定义中类型彼此不同。回想一下，类型上的不同足以认定其为重载。为了有助于分析这种情况，在下面再次呈现了派生类Undergraduate中的equals方法的定义：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10806.jpeg)

为什么在对equals的调用中将otherUndergraduate强制转型成了Student？因为如果不这样做，Java就会调用Undergraduate类中的equals的定义。即，这个equals方法会调用它自己。尽管一个方法调用自身在某些情况下是完全可以接受的，就像你将会在第11章看到的，但是在此处我们并非想如此调用。通过将引元从Undergraduate强制转型为Student，就可以让Java调用Student的equals方法。注意，otherUndergraduate作为一个Undergraduate对象，拥有Student对象的所有行为，因此在Student的equals方法中可以正确地工作。我们将在下一节中详细阐述这一点。

Undergraduate类的用法没有任何特殊之处，但是我们在UndergraduateDemo.java文件中编写了一个简单的针对这个类的演示程序，这个文件是本书在网站上可下载的源代码的一部分。