   

### 8.2.6　类型兼容性

考虑一下程序清单8.4中的Undergraduate类，它是Student类的派生类。在现实世界中，每个本科生都是学生。这种关系在我们的Java示例中也存在。每个Under-graduate类的对象也都是Student类的对象。因此，如果你有一个方法，它具有类型为Student的形式参数，那么在对该方法的调用中，引元可以是Undergraduate类型的对象。在这种情况下，该方法只可以使用在Student类中定义的方法，但是Undergraduate类的每个对象都具有所有Undergraduate类中定义的方法。

例如，假设Student类和Undergraduate类的定义如程序清单8.2和程序清单8.4所示，请考虑下面可能会出现在某个类中的方法定义：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10809.jpeg)

使用SomeClass的程序可能包含下面的代码：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10810.jpeg)

如果观察compareNumber的方法头，就会看到两个参数都是Student类型的。但是，下面的调用：

![](../Images/image10811.gif)

用到了一个Student类型的引元和一个Undergraduate类型的引元。我们为什么可以在需要Student类型的引元的地方使用Undergraduate类型的对象呢？答案是每个Undergraduate类型的对象同时也具有Student类型。为了让这一点显得更戏剧化一些，我们可以将两个引元像下面这样颠倒顺序，而该方法仍旧是合法的：

![](../Images/image10812.gif)

注意，这里不存在任何自动的类型强制转换。Undergraduate类的对象也是Student类的对象，因此它就是Student类型的，不必也没有将其类型强制转换为Student类的对象。

因为继承的原因，一个对象实际上执行的行为就好像它具有多种类型一样。回忆一下，Undergraduate类是Student类的派生类，而Student类又是程序清单8.1中的Person类的派生类。这意味着Undergraduate类的每个对象同时也是Student类型的对象和Person类型的对象。因此，在Person类的对象上可以工作的任何东西在Undergraduate类的对象上也可以工作。

例如，假设Person类和Undergraduate类如程序清单8.1和程序清单8.4的定义，考虑下面这段可能会出现在某个程序中的代码：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10813.jpeg)

如果查看程序清单8.1中的hasSameName方法头，就会发现它有一个参数，该参数的类型为Person类型。但是，在前面的if-else语句中的调用：

![](../Images/image10814.gif)

是完全合法的，尽管引元someUndergraduate是Undergraduate类的对象，即，它的类型是Undergraduate，而在hasSameName中对应的参数是Person类型的。Undergraduate类的每个对象也是Person类的对象。

甚至下面的调用也是合法的：

![](../Images/image10815.gif)

hasSameName方法属于Person，但是它被Undergraduate类继承了。因此，Undergra-duate对象someUndergraduate具有该方法。Undergraduate类型的对象也具有Person类型。在祖先类的对象上可以工作的任何东西在子孙类的对象上也可以工作。或者，换种说法，子孙类的对象可以做与祖先类一样的事情。正如我们已经看到的，如果A类是从B类中派生的，而B类又是从C类派生的，那么A类的对象是类型A的对象同时也是类型B和类型C的对象。这种机制对于任何派生类链都有效，无论派生链有多长。

因为派生类的对象除了其“自己”的类型外，还具有其所有祖先类的类型，所以我们可以将某个类的对象赋值给其任何祖先类型的变量，但是反过来不行。例如，因为Student是Person类的派生类，Undergraduate是Student的派生类，所以下面的代码是合法的：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10816.jpeg)

我们甚至可以绕过s和ug，直接将新对象放置到p1和p2中，就像下面这样：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10817.jpeg)

但是，下面的语句都是非法的：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10818.jpeg)

如果我们像下面这样定义p和s：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10819.jpeg)

甚至这些看起来更没问题的语句也是非法的：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10820.jpeg)

这些都具有实际的意义。例如，一个Student是一个Person，但是一个Person并不一定非要是一个Student。有些程序员发现短语“是一个”在决定一个对象可以具有什么类型以及哪些对变量的赋值合法时会显得很有用。我们来看另一个示例，如果Employee是Person的派生类，那么一个Employee就是一个Person，因此我们可以将Employee对象赋值给Person类型的变量。但是，一个Person并非必需是一个Employee，因此不能将作为普通Person创建的对象赋值给Employee类型的变量。

牢记：赋值兼容性

派生类的对象具有派生类的类型，但是它可以被属于其任何祖先类类型的变量所引用。因此，我们可以将派生类的对象赋值给任何祖先类型的变量，但是反过来不行。

编程窍门：“是一个”和“有一个”关系

正如我们提到的，一个Student就是一个Person，因此我们让Student类成为Person类的派生类，这是类之间的“是一个”关系的示例。这是一种从简单类产生复杂类的方式。

另一种方式称为“有一个”关系。例如，我们有一个记录日期的Date类，通过在Student类中添加Date类型的实例变量，就可以在Student类中添加录取日期。在这种情况下，我们称一个Student“有一个”Date。让我们来看看另一个示例，如果我们有一个MechanicalArm类，并且正在定义一个模拟机器人的类，那么可以在Robot类中添加一个MechanicalArm类型的实例变量。在这种情况下，我们称一个Robot“有一个”MechanicalArm。

在大多数情况下，代码既可以用“是一个”关系来工作，也可以用“有一个”关系来工作，但是，“有一个”关系经常是更好的选择。虽然让Robot类成为MechanicalArm类的派生类看起来很愚蠢，但是这么做也行得通。然而，这种设计是一种较差的设计。

幸运的是，最佳编程技术通常就是按照自然语言描述听起来最自然的方式。“一个机器人有一条机械臂”的说法比“一个机器人是一条机械臂”的说法要自然得多。因此，更有意义的编程方式应该是有一个MechanicalArm对象作为Robot类的实例变量。

自测问题

8.请给出一个从程序清单8.1的Person类派生的名为TitledPerson类的完整定义。Titled-Person具有一个额外的String实例变量表示头衔，例如Ms.、Mr.或Honorable。Titled-Person类具有两个构造器：一个缺省构造器和一个同时设置姓名与头衔的构造器。它具有writeOutput、reset和equals方法，以及返回头衔的getTitle访问器方法和修改人物头衔的setTitle修改器方法。对于两个有头衔的人，如果要判定他们相同（equals），那么他们必须具有相同的姓名和相同的头衔。你可能会希望使用程序清单8.2的Student类作为模型。

9.在Student类中添加一个构造器，它会将学生的名字设置成为给定的引元字符串，并将学号设置为0。你的构造器应该调用Student中的另一个构造器来实现此目的。

10.重写程序清单8.4中Undergraduate类的writeOutput方法的定义，用getName和get-StudentNumber代替super.writeOutput。（大多数程序员会使用程序清单8.4中的版本，但是你应该会写这两种版本。）

11.重写程序清单8.4中Undergraduate类的reset方法的定义，用setName和set-StudentNumber代替重载的reset方法名。（大多数程序员会使用程序清单8.4中的版本，但是你应该会写这两种版本。）

12.一个对象能够被多个具有不同数据类型的变量所引用吗？

13.哪种或哪些类型的变量可以引用下面语句中所创建的对象？（程序清单8.4中给出的Undergraduate类的定义。）

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10821.jpeg)

14.描述关键词super的两种用法。

15.当this和super用于构造器定义中作为被调用的方法名时，这两个词的差异是什么？