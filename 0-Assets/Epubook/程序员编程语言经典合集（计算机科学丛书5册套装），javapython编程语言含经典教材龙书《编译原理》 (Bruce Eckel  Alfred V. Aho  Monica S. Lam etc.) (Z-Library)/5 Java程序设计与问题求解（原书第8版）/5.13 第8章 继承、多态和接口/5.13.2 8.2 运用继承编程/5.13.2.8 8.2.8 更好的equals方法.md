   

### 8.2.8　更好的equals方法

正如我们在上一节所提到的，Object类定义了每个类都会继承的equals方法。但是在大多数时间内，如果我们想要让自己的类拥有能够正确工作的equals方法，就应该覆盖Object的定义并定义自己的版本。但是，严格地讲，我们没有遵循我们自己给出的这条建议。在程序清单8.2中给出的Student类的定义中，equals方法头如下：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10828.jpeg)

但是Object的equals方法头如下：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10829.jpeg)

这两个equals方法具有不同的参数类型，因此，我们实际上没有覆盖equals的定义，我们仅仅只是重载了该方法。换句话说，Student类同时拥有这两个方法。对于大多数情况，这并不会有什么问题。但是，在有些情况下，它们就会有问题。

假设我们使用了某个方法，该方法要么是预定义的，要么是程序员定义的，它有一个名为objectParam的Object类型的参数和另一个Student类型的参数studentParam。现在，假设其方法体中包含下面的调用：

![](../Images/image10830.gif)

如果将两个Student类型的引元传递给参数objectParam和studentParam，那么Java就会使用从Object继承而来的equals定义，而不是在Student类中定义的equals。这意味着在有些情况下，equals方法会返回错误的答案。

为了修正这个问题，我们需要将Student类中的equals方法的参数类型从Student修改为Object。第一次尝试可能像下面这样：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10831.jpeg)

注意，我们需要将参数otherObject的类型从Object强制转换为Student。如果没有进行类型强制转换，也没有使用变量otherStudent，那么在编写下面的代码时，就会产生语法错误：

![](../Images/image10832.gif)

因为Object类没有名为studentNumber的实例变量。（实际上，对hasSameName的调用也可能会产生语法错误。）

这是对改进equals方法的第一次尝试，它覆盖了Object类中给出的equals定义，并且在大多数情况下都可以良好地工作。但是，它仍旧存在缺点：新的equals定义现在允许引元是任何对象。如果equals方法操作的不是Student对象会发生什么？答案是，在执行强制类型转换到Student时，会产生一个运行时错误。

我们应该让定义能够在任何对象上工作。如果该对象并非是Student对象，那么直接返回false。毕竟，该方法属于Student对象，因此，如果引元不是Student对象，那么这两个对象就会被认为是不等的。但是我们如何才能知道该参数不是Student类型呢？

我们可以使用instanceof操作符来检查某个对象是否是Student类型，其语法为：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10833.jpeg)

如果Object是Class_Name类型的，那么该表达式会返回true，否则返回false。因此，下面的表达式在otherObject是Student类型时，将会返回true：

![](../Images/image10834.gif)

因此，equals方法应该在上面的布尔表达式为false时返回false。

程序清单8.5展示了equals方法的最终版本。注意，我们还考虑到了另一种可能的情况。预定义常量null可以传递给Object类型的参数。Java文档声称equals方法在对一个对象和null值进行比较时，应该返回false。因此，这就是我们的代码所做的。

旁白：多重继承

有些编程语言（例如C++）允许一个类派生自两个不同的基类。即，我们可以从类A和B派生类C。这种特性称为多重继承，但是在Java中是不允许的。在Java中，派生类只能有一个基类。但是，我们可以从A类派生B类，然后从B类派生C类，因为这并不算多重继承。

派生类除了可以扩展任意一个基类之外，还可以实现任意数量的接口。我们将在下一章讨论接口。这种能力使得Java得到了近似的多重继承机制，同时可以避免多个基类所带来的复杂性。  

程序清单8.5　Student类的一个更好的equals方法

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image10835.jpeg)