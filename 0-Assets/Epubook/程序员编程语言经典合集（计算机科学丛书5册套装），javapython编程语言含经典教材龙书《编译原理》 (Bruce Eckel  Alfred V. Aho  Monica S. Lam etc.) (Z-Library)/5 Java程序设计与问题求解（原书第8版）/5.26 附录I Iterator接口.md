   

# 附录I　Iterator接口

Iterator接口被设计为需要与其对象为元素集合的类一起实现。在良好的实现中，重复执行next方法就可以访问集合中的所有元素。Iterator接口可以由集合类自身来实现，也可以由其对象是集合类的迭代器的另一个类来实现。Iterator接口指定了3个方法，看起来像下面这样：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11500.jpeg)

接口可以指定泛化数据类型，就像类能够做的那样。第12章讨论了如何使用或编写具有泛化数据类型的类。接口使用了相同的标记法。例如，Iterator接口具有泛化数据类型E。注意，Iterator在头部有<E>，并且用E作为next方法的返回类型。因此，E表示的是集合中将要被迭代的元素的数据类型。

我们可以修订第12章程序清单12.10中给出的LinkedList类，在其类头中添加implements子句，让它实现Iterator接口，就像下面这样：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11501.jpeg)

然后，我们实现LinkedList的方法以及Iterator接口中的方法。

Iterator接口在java.util包中。因此，对于实现Iterator接口的类，其源代码文件中应该包含下面的import语句：

![](../Images/image11502.gif)

最后，请注意，在Iterator的方法描述中提及的所有异常类都是RunTimeException的派生类。因此，这些异常中没有一个需要被捕获或者需要在throws子句中声明。