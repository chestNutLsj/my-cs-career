   

### 10.2.1　创建文本文件

Java类库中的PrintWriter类定义了在创建和写入文本文件时所需的方法。这个类是用于写入文本文件的首选类，它位于java.io包中，因此我们需要以import语句开头。实际上，我们还会用到其他的类，因此我们还应该导入它们，正如你马上就会看到的。

在我们可以写入文本文件之前，必须先将其与某个输出流连接起来。即，我们需要先打开文件。为了实现此目的，我们需要拿到用字符串表示的文件名，而文本文件具有像out.txt这样的由操作系统使用的名字。我们还必须声明一个用来引用与实际文件相关联的流的变量，这个变量称为流变量，其数据类型在这种情况下是PrintWriter。通过调用Print-Writer的构造器并将文件名当作引元传递给它，我们就可以打开一个文本文件用于输出。因为这个动作可能会抛出异常，所以我们必须将对构造器的调用放到一个try块中。

下面的语句将打开文本文件out.txt，用于输出：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11088.jpeg)

FileNotFoundException类也必须从java.io包中导入。

注意文件名（即本例中的out.txt）是以String值的形式给出的。通常，我们会读入文件名而不是使用字面常量。我们将文件名当作引元传递给了PrintWriter的构造器，得到的结果就是一个PrintWriter类的对象，该对象被赋值给了流变量outputStream。

当我们以这种方式将文件与输出流连接起来时，我们的程序总是会从一个空文件开始。如果文件out.txt已经存在，那么它原来的内容就会丢失。如果文件out.txt不存在，那么就会创建一个新的名为out.txt的空文件。

因为PrintWriter的构造器在尝试打开文件时可能会抛出FileNotFoundException异常，所以对它的调用必须出现在try块中，而抛出的任何异常都会被某个catch块捕获。即使构造器抛出了该异常，也并不表示文件找不到，毕竟，如果在创建新文件，那么该文件不可能已存在。在这种情况下，该异常表示这个文件无法创建，例如，该文件名已用于表示文件夹（目录）名。

在打开文件之后，即，将文件连接到流上后，我们就可以向其中写入数据了。PrintWriter类的println方法向文本文件写入数据的工作方式与System.out.println方法将数据写到屏幕上的工作方式相同。PrintWriter还有一个print方法，它的行为与System.out.print类似，只是其输出会写入文本文件中。

既然该文件处于打开状态，那么我们总是可以用流变量而不是文件名来引用它。我们的流变量outStream（即PrintWriter对象）引用的是我们创建的输出流，因此，我们在调用println时将用到它。注意，outStream是在try块外部声明的，因此它在该块的外部仍旧可用。记住，在一个块中声明的任何东西都只局限于在该块中使用，即使在try块内部也是如此。

让我们向该文本文件中写入几行文本。下面的语句出现在之前打开文件的语句之后：

![](../Images/image11089.gif)

PrintWriter并不是将输出立即发送到文件中，而是会等待，直至可以一次性发送尺寸更大的数据包。因此，println语句中的输出不会立即发送到输出文件中，而是会与其他对print和println的调用所产生的输出一起保存并置于内存中被称为缓冲区的区域内。当缓冲区满，无法接收更多的输出时，其中的内容就会被写入文件中。因此，来自若干条println语句的输出会同时写入，而不是在每执行一条println时就写入。这种技术称为缓冲机制，它使得文件处理变得更快。

在完成写入整个文本文件时，就可以将流与文件断开了。即，可以通过编写下面的语句来关闭连接到文件的流：

![](../Images/image11090.gif)

关闭流会导致系统释放将这个流与文件连接时用到的所有资源，并且执行其他的善后工作。如果没有关闭流，那么Java会在程序结束时自动关闭它。但是，最安全的方式还是通过显式地调用close方法来关闭流。回忆一下，在将数据写入文件时，数据可能并没有立即到达其目的地，所以关闭输出流会强制将任何尚未写入的输出写入到文件中。如果没有关闭流并且程序异常终止了，那么Java可能就无法自动关闭它了，此时数据可能会丢失。越早关闭数据流，就越不会发生这种事情。

如果程序在文件中写入了数据并且随后又要读取该文件的内容，那么在向文件中写入数据之后，必须关闭这个流，然后再重新打开该文件用于读取。（Java确实有一个类允许将文件打开同时用于读取和写入，但是在本书中将不讨论这个类。）注意，所有像PrintWriter这样的流类都包含名为close的方法。

对println和close的调用无须放在try块中，因为它们不会抛出必须捕获的异常。程序清单10.1包含了一个简单但是完整的程序，它可以用从用户处读取的数据来创建文本文件。注意，在所产生的文本文件中所示的各行文本看起来与将它们写出到屏幕上时相同。我们可以用文本编辑器或稍后将要编写的Java程序来读取该文件。

程序清单10.1　将输出写出到文本文件中

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11091.jpeg)

回顾：创建文本文件

语法

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11092.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11093.jpeg)

示例

请查看程序清单10.1。

编程窍门：程序不应该沉默

创建文件的程序应该在它完成写入文件操作之后通知用户。否则，我们编写的就是一个沉默的程序，用户无法知道程序是成功执行了，还是遇到了问题。这项建议适用于文本文件和二进制文件。

牢记：文件在程序中有两个名字

每个被程序用到的文件，无论是用于输入还是输出，都具有两个名字：操作系统使用的实际的文件名，以及与该文件连接的流的名字。在将文件连接到某个流时，会用到文件名，此后会使用流的名字来操作该文件。流的名字在程序终止执行之后就不复存在了，但是实际的文件名将持久化地存在。注意，因为流变量可以有别名，所以文件实际上可以有两个以上的名字。但是，将文件名与流名区分开是此处的要点所在。

常见问题：什么是文件命名规则？

有关如何拼写文件名的规则取决于操作系统，而不是Java。当我们将文件名传递给Java流类的构造器时，传递给构造器的并不是Java标识符。大多数常见的操作系统允许我们使用字母、数字和圆点作为构成文件名的字符。后缀（例如out.txt中的.txt）对Java程序来说没有任何特殊的意义。使用该后缀是为了表示这是文本文件，但是这仅仅只是一个常见的惯例而已。我们可以使用操作系统允许使用的任何文件名，但是你应该意识到，有些操作系统会缺省地隐藏后缀。

疑难杂症：try块是一个块

再看一遍程序清单10.1中的程序，在try块外部声明outputStream变量并非偶然为之，也并非只是编程风格上的小问题。假设将这个声明移到try块内部，就像下面这样：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11094.jpeg)

这种替换看起来完全没有问题，但是它使得outputStream成为了try块中的局部变量。因此，我们无法在这个try块的外部使用outputStream。如果我们这么做，就会得到一条错误消息，声明outputStream是一个未定义的标识符。

第8章建议在我们的类中定义一个toString方法，这个方法会返回该类实例中的数据的字符串表示。System.out的print和println方法在传递给它们的引元是对象时，会自动调用toString方法。PrintWriter对象的print和println方法也是这样处理的。

例如，可以在第5章的Species类中添加一个toString方法。回忆一下，这个类定义了三个实例变量：name、population和growthRate。因此，我们可以按如下方式定义toString：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11095.jpeg)

现在，如果我们在程序中编写下面的语句：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11096.jpeg)

那么就会产生下面的输出：

![](../Images/image11097.gif)

我们还知道：

![](../Images/image11098.gif)

会自动调用toString，因此它会产生相同的输出。

如果要写到文本文件中，那么情况也相同。下面的两条语句：

![](../Images/image11099.gif)

或

![](../Images/image11100.gif)

会将之前展示的输出写到与outputStream流关联的文本文件中。

文件TextFileSpeciesOutputStream中的程序演示了这个事实，该程序在本书的网站上可以下载到源代码。

编程窍门：为你的类定义toString方法

无论print和println方法是属于System.out对象，还是属于某个输出流对象，因为这两个方法会自动调用toString方法，所以为你的类定义toString方法是一个很好的想法。

疑难杂症：覆写文件

当把文本文件或二进制文件打开用于输出时，我们总是会从空文件开始。如果没有任何已有文件具有给定的名字，你调用的构造器就会创建具有该名字的空文件。但是如果某个已有文件具有给定的名字，那么其所有数据都会被消除。任何新的输出都会被写入到这个已有文件中。10.3节展示了如何测试文件是否存在，以避免无意中覆写了它的内容。