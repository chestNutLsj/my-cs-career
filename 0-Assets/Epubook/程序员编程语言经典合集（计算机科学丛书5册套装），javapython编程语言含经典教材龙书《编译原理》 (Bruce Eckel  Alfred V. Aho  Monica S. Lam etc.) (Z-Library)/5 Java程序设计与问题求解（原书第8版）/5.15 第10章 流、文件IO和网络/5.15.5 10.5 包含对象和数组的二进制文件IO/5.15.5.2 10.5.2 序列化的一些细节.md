   

### 10.5.2　序列化的一些细节

在上一节对序列化的介绍忽略了一些我们现在必须讨论的细节，因为我们现在需要给出可序列化类的完整定义。回忆一下，我们提到过，实例变量可以是另一个对象，而这个对象自身又可能包含对象类型的实例变量。实际上，Species类确实有一个字符串类型的实例变量。当可序列化的类具有类类型的实例变量时，这些实例变量的类应该也是可序列化的，以此类推，这些类所有层级上的实例变量都必须如此。

因此，如果一个类满足下面全部条件，那么这个类就是可序列化的：

·这个类必须实现Serializable接口。

·所有类类型的实例变量必须都是可序列化类的对象。

·如果存在，该类的直接超类要么是可序列化的，要么定义了缺省的构造器。

例如，Species类实现了Serializable接口，并且有一个字符串类型的实例变量，而String类是可序列化的。因为可序列化类的所有子类都是可序列化的，所以从Species派生的类也是可序列化的。

让一个类可序列化的效果是什么呢？在某种意义上，对这个类没有任何直接影响，只是对Java如何执行类对象的文件I/O会产生影响。如果一个类是可序列化的，那么对于要写入ObjectOutputStream类型的流的类，Java会对其每个对象都赋予一个序列号。如果同一个对象被多次写入这种流，那么在第一次写入之后，后续Java只会将对象的序列号写入流中，而不会将对象的数据多次写入。这种特性使得文件I/O更加高效，并且使文件的尺寸变小了。当使用ObjectInputStream类型的流读入该文件时，重复的序列号会被当作对同一个对象的引用返回。注意，这种情况意味着，如果两个变量包含对同一个对象的引用，并且我们将这两个对象都写入了文件，随后又从文件中读取它们，那么这两个被读取的对象就会引用到同一个对象。因此，当我们将对象写入文件，随后将它们读出时，对象数据的结构不会有任何损失。

序列化听起来很不错，那么，为什么不让所有的类都是可序列化的呢？有些情况是出于安全的原因，因为序列号系统使得程序员可以更加容易地访问写入到辅存中的对象数据。还有些情况是将对象写入到辅存中可能没有什么必要，因为随后将它们再次读回毫无意义。例如，如果对象中包含依赖于系统的数据，那么再次读回这些数据就可能毫无意义。