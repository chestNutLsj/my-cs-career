   

# 附录J　克隆

对象的克隆体是与对象完全一样的副本。这里强调的是完全一样和副本。克隆体应该与原始的对象具有完全相同的数据值，并且应该是单独的对象，而不仅仅只是原始对象的另一个名字。

克隆体是通过调用clone方法创建的。回忆一下第8章的内容，这个方法是在Object类中定义的，但是需要被覆盖，即，需要重新定义，以便让其可以针对具体的类执行适合的行为。

标准类ArrayList是一个定义了自己的clone方法的类，如第12章所述。假设我们像下面这样用ArrayList定义一个字符串列表：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11503.jpeg)

然后，我们可以通过调用ArrayList的clone方法创建一个与aList完全一样的副本，这样我们就有了两个单独的副本：

![](../Images/image11504.gif)

尽管clone方法返回的是aList的副本，但是它总是会将其作为Object类型的对象返回。因此，我们通常需要进行类型强制转换。

对于字符串之外的对象列表，使用clone方法可能会更复杂，并且可能有不少坑。让我们来审视这个问题，首先，来看看如何在我们自己的类中添加clone方法。例如，考虑第6章程序清单6.1中的Pet类。在我们对这个类定义做了适当的修订后，就可以像下面这样创建Pet类型的对象的副本了：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11505.jpeg)

请注意克隆体从Object到Pet的类型强制转换。现在，让我们对Pet做必要的修订。

首先，这个类必须实现标准接口Cloneable。通过让Pet类的定义以下面这行开头，就可以实现此目的：

![](../Images/image11506.gif)

这个接口实际上是空的，但是它要求你在类定义中添加clone方法的定义。Object类中的clone方法的头部如下：

![](../Images/image11507.gif)

Pet将会用下面的公有版本覆盖这个方法：

![](../Images/image11508.gif)

如果类的实例变量为基本类型，或者是其对象不能通过其方法进行修改的类类型（例如String类型），那么clone的定义就只需要调用继承而来的clone版本。因为Pet就是这样的类，它有一个String类型的实例变量和两个基本类型的实例变量，所以，程序清单10.1[^1]中的clone版本，它直接创建了一个逐位复制的内存副本，用来存储调用对象的实例变量。其中的try-catch块是必需的，因为clone方法在类没有实现Cloneable接口时，可以抛出CloneNotSupportedException异常。当然，在这些类中，我们实现了Cloneable接口，因此，这个异常不会被抛出，但是编译器仍旧坚持要求我们使用try-catch块。

程序清单J.1　clone方法的一个简单实现

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11509.jpeg)

注意，Cloneable接口和clone方法的行为方式比大多数接口和继承而来的方法要复杂。尽管Object类有一个名为clone的方法，但是它不会被自动继承。你必须在类的定义中包含implements Cloneable，并且必须包含clone的定义，尽管可能只是像程序清单J.1一样简单地定义。clone的这个版本的行为就像按照正常方式从Object继承而来的clone一样。

如果你的类具有类类型的实例变量，这种类类型的对象可以通过类的方法做修改，那么程序清单J.1中的clone定义尽管合法，但是可能执行的操作就不是你想要的操作了。这个版本产生的克隆体是每个实例变量的内存地址的副本，而不是实例变量的数据的副本。对于像String这样的类，因为它的对象是不能修改的，即，它没有set方法，所以在这种情况下是不会有问题的，我们克隆Pet对象或之前克隆字符串列表也是如此。

对于大多数其他的类，这种情况会以6.5节中描述的方式开放对私有数据的访问权限。对于这些类，你的clone定义应该创建每个可修改类类型的实例变量的副本。当然，这项任务要求这些类类型自身也有适合的clone方法。定义这种clone方法的方式在程序清单J.2中进行了展示。让我们来看看这个程序清单中的一些细节。

程序清单J.2　一个类和它的clone方法

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11510.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11511.jpeg)

Neighbor类有三个实例变量，在定义clone方法时，name和numberOfChildren这两个实例变量不是我们所关心的，因为它们的数据类型分别是String和int。但是familyPet的数据类型是Pet，它是一个具有set方法的类。让我们来看看这会如何影响Neighbor的clone方法。

clone方法中下面的语句会创建一个逐位复制的内存副本，用来存储接收对象的实例变量：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image11512.jpeg)

这种复制对于String类型的实例变量name和int类型的实例变量numberOfChildren可以工作得很好。但是，它赋予copy的实例变量familyPet的值（即copy.familyPet的值）是接收对象的实例变量familyPet的地址。我们希望得到的是实例变量的副本，而不是其地址。为了获取副本，我们像下面这样调用了Pet的clone方法：

![](../Images/image11513.gif)

然后，Neighbor的clone方法会将copy作为克隆体返回。

我们在程序清单J.2中包含了Neighbor的访问器方法getPet。为了避免6.5节所描述的隐私泄露，getPet返回的是实例变量familyPet的克隆体而不是familyPet自身。

让我们再简要回顾一下我们的开放示例。在这个例子中，我们克隆了一个ArrayList对象。这个类的clone方法没有克隆列表中的对象，因此，尽管aList和duplicateList是两个单独的对象，但是它们共享了相同的字符串作为它们的元素。例如，aList中的第一个字符串也是duplicateList中的第一个字符串，我们并没有两个单独的但是相等的字符串。好消息是列表中的字符串是不能修改的，所以对于两个列表来说，共享相同的字符串集合非常安全。

[^1]:  本书网站上的源代码包含了一个具有clone方法的这个定义的Pet类版本。

[^2]:  如果你的类是某个（除Object之外的）类的派生类，那么我们就认为该基类具有完整定义的clone方法，因为super.clone会引用到该基类。