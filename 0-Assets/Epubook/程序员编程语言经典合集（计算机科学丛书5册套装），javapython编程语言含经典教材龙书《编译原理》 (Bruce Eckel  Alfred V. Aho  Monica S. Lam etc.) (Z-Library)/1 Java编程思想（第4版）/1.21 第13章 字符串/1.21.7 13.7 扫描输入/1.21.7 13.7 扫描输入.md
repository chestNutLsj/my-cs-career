## 13.7　扫描输入

到目前为止，从文件或标准输入读取数据还是一件相当痛苦的事情。一般的解决之道就是读入一行文本，对其进行分词，然后使用Integer、Double等类的各种解析方法来解析数据：

![342-2](../Images/image03110.jpeg)

input元素使用的类来自java.io，在第18章中我们会正式介绍这个包中的内容。StringReader将String转化为可读的流对象，然后用这个对象来构造BufferReader对象，因为我们要使用BufferReader的readLine()方法。最终，我们可以使用input对象一次读取一行文本，就像是从控制台读入标准输入一样。

readLine()方法将一行输入转为String对象。如果每一行数据正好对应一个输入值，那这个方法也还可行。但是，如果两个输入值在同一行中，事情就不好办了，我们必须分解这个行，才能分别翻译所需的输入值。在这个例子中，分解的操作发生在创建numArray时，不过要注意，split()方法是J2SE1.4中的方法，所以在这之前，你还必须做些别的准备。

终于，Java SE5新增了Scanner类，它可以大大减轻扫描输入的工作负担：

![343-1](../Images/image03111.jpeg)

Scanner的构造器可以接受任何类型的输入对象，包括File对象（同样，我们将在第18章中详细介绍File类）、InputStream、String或者像此例中的Readable对象。Readable是Java SE5中新加入的一个接口，表示“具有read()方法的某种东西”。前一个例子中的BufferedReader也归于这一类。有了Scanner，所有的输入、分词以及翻译的操作都隐藏在不同类型的next方法中。普通的next()方法返回下一个String。所有的基本类型（除char之外）都有对应的next方法，包括BigDecimal和BigInteger。所有的next方法，只有在找到一个完整的分词之后才会返回。Scanner还有相应的hasNext方法，用以判断下一个输入分词是否所需的类型。

在前面的两个例子中，一个有趣的区别是，BetterRead.java没有针对IOException添加try区块。因为，Scanner有一个假设，在输入结束时会抛出IOException，所以Scanner会把IOException吞掉。不过，通过ioException()方法，你可以找到最近发生的异常，因此，你可以在必要时检查它。

练习20：（2）编写一个包含int、long、float、double和String属性的类。为它编写一个构造器，接收一个String参数。然后扫描该字符串，为各个属性赋值。再添加一个toString()方法，用来演示你的类是否工作正确。