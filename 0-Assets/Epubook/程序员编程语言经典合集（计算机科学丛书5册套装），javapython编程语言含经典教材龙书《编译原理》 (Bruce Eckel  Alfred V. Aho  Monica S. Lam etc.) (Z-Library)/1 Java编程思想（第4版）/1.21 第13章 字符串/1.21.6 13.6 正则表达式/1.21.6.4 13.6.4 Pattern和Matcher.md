### 13.6.4　Pattern和Matcher

一般来说，比起功能有限的String类，我们更愿意构造功能强大的正则表达式对象。只需导入java.util.regex包，然后用static Pattern.compile()方法来编译你的正则表达式即可。它会根据你的String类型的正则表达式生成一个Pattern对象。接下来，把你想要检索的字符串传入Pattern对象的matcher()方法。matcher()方法会生成一个Matcher对象，它有很多功能可用（可以参考java.util.regext.Matcher的JDK文档）。例如，它的replaceAll()方法能将所有匹配的部分都替换成你传入的参数。

作为第一个示例，下面的类可以用来测试正则表达式，看看它们能否匹配一个输入字符串。第一个控制台参数是将要用来搜索匹配的输入字符串，后面的一个或多个参数都是正则表达式，它们将被用来在输入的第一个字符串中查找匹配。在Unix/Linux上，命令行中的正则表达式必须用引号括起。这个程序在测试正则表达式时很有用，特别是当你想验证它们是否具备你所期待的匹配功能的时候。

![333-1](../Images/image03089.jpeg)

Pattern对象表示编译后的正则表达式。从这个例子中可以看到，我们使用已编译的Pattern对象上的matcher()方法，加上一个输入字符串，从而共同构造了一个Matcher对象。同时，Pattern类还提供了static方法：

![334-1](../Images/image03090.jpeg)

该方法用以检查regex是否匹配整个CharSequence类型的input参数。编译后的Pattern对象还提供了split()方法，它从匹配了regex的地方分割输入字符串，返回分割后的子字符串String数组。

通过调用Pattern.matcher()方法，并传入一个字符串参数，我们得到了一个Matcher对象。使用Matcher上的方法，我们将能够判断各种不同类型的匹配是否成功：

![334-2](../Images/image03091.jpeg)

其中的matches()方法用来判断整个输入字符串是否匹配正则表达式模式，而lookingAt()则用来判断该字符串（不必是整个字符串）的始部分是否能够匹配模式。

练习10：（2）对字符串Java now has regular expressions验证下列正则表达式是否能够发现一个匹配：

![334-3](../Images/image03092.jpeg)

练习11：（2）试用正则表达式

![334-4](../Images/image03093.jpeg)

匹配字符串Arline ate eight apples and one orange while Anita hadn't any。

![334-5](../Images/image03094.jpeg)

find()

Matcher.find()方法可用来在CharSequence中查找多个匹配。例如：

![334-6](../Images/image03095.jpeg)

模式\\w+将字符串划分为单词。find()像迭代器那样前向遍历输入字符串。而第二个find()能够接收一个整数作为参数，该整数表示字符串中字符的位置，并以其作为搜索的起点。从结果中可以看出，后一个版本的find()方法能根据其参数的值，不断重新设定搜索的起始位置。

组（Groups）

组是用括号划分的正则表达式，可以根据组的编号来引用某个组。组号为0表示整个表达式，组号1表示被第一对括号括起的组，依此类推。因此，在下面这个表达式，

![335-1](../Images/image03096.jpeg)

中有三个组：组0是ABCD，组1是BC，组2是C。

Matcher对象提供了一系列方法，用以获取与组相关的信息：public int groupCount()返回该匹配器的模式中的分组数目，第0组不包括在内。public String group()返回前一次匹配操作（例如find()）的第0组（整个匹配）。public String group（int i）返回在前一次匹配操作期间指定的组号，如果匹配成功，但是指定的组没有匹配输入字符串的任何部分，则将会返回null。public int start（int group）返回在前一次匹配操作中寻找到的组的起始索引。public int end（int group）返回在前一次匹配操作中寻找到的组的最后一个字符索引加一的值。

下面是正则表达式组的例子：

![335-2](../Images/image03097.jpeg)

这首诗来自于Lewis Carroll的《Through the Looking Glass》中的Jabberwocky。可以看到这个正则表达式模式有许多圆括号分组，由任意数目的非空格字符（\S+）及随后的任意数目的空格字符（\s+）所组成。目的是捕获每行的最后3个词，每行最后以$结束。不过，在正常情况下是将$与整个输入序列的末端相匹配。所以我们一定要显式地告知正则表达式注意输入序列中的换行符。这可以由序列开头的模式标记（？m）来完成（模式标记马上就会介绍）。

练习12：（5）修改Goups.java类，找出所有不以大写字母开头的词，不重复地计算其个数。

start()与end()

在匹配操作成功之后，start()返回先前匹配的起始位置的索引，而end()返回所匹配的最后字符的索引加一的值。匹配操作失败之后（或先于一个正在进行的匹配操作去尝试）调用start()或end()将会产生IllegalStateException。下面的示例还同时展示了matches()和lookingAt()的用法[^3]：

![336-1](../Images/image03098.jpeg)

![337-1](../Images/image03099.jpeg)

注意，find()可以在输入的任意位置定位正则表达式，而lookingAt()和matches()只有在正则表达式与输入的最开始处就开始匹配时才会成功。matches()只有在整个输入都匹配正则表达式时才会成功，而lookingAt()[^4]只要输入的第一部分匹配就会成功。

练习13：（2）修改StartEnd.java，让它使用Groups.POEM为输入，必要时修改正则表达式，使find()、lookingAt()和matches()都有机会匹配成功。

Pattern标记

Pattern类的compile()方法还有另一个版本，它接受一个标记参数，以调整匹配的行为：

![337-2](../Images/image03100.jpeg)

其中的flag来自以下Pattern类中的常量：

![337-3](../Images/image03101.jpeg)

在这些标记中，Pattern.CASE_INSENSITIVE、Pattern.MULTILINE以及Pattern.COMMENTS（对声明或文档有用）特别有用。请注意，你可以直接在正则表达式中使用其中的大多数标记，只需要将上表中括号括起的字符插入到正则表达式中，你希望它起作用的位置即可。

你还可以通过“或”（|）操作符组合多个标记的功能：

![338-2](../Images/image03102.jpeg)

在这个例子中，我们创建了一个模式，它将匹配所有以“java”、“Java”和“JAVA”等开头的行，并且是在设置了多行标记的状态下，对每一个行（从字符序列的第一个字符开始，至每一个行终结符）都进行匹配。注意，group()方法只返回已匹配的部分。