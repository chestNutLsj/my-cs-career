### 17.10.5　对Map的选择

下面的程序对于Map的不同实现，在性能开销方面给出了指示：

![542-2](../Images/image03443.jpeg)

![543-1](../Images/image03444.jpeg)

除了IdentityHashMap，所有的Map实现的插入操作都会随着Map尺寸的变大而明显变慢。但是，查找的代价通常比插入要小得多，这是个好消息，因为我们执行查找元素的操作要比执行插入元素的操作多得多。

Hashtable的性能大体上与HashMap相当。因为HashMap是用来替代Hashtable的，因此它们使用了相同的底层存储和查找机制（你稍后就会学习它），这并没有什么令人吃惊的。

TreeMap通常比HashMap要慢。与使用TreeSet一样，TreeMap是一种创建有序列表的方式。树的行为是：总是保证有序，并且不必进行特殊的排序。一旦你填充了一个TreeMap，就可以调用keySet()方法来获取键的Set视图，然后调用toArray()来产生由这些键构成的数组。之后，你可以使用静态方法Arrays.binarySearch()在排序数组中快速查找对象。当然，这只有在HashMap的行为不可接受的情况下才有意义，因为HashMap本身就被设计为可以快速查找键。你还可以很方便地通过单个的对象创建操作，或者是调用putAll()，从TreeMap中创建HashMap。最后，当使用Map时，你的第一选择应该是HashMap，只有在你要求Map始终保持有序时，才需要使用TreeMap。

LinkedHashMap在插入时比HashMap慢一点，因为它维护散列数据结构的同时还要维护链表（以保持插入顺序）。正是由于这个列表，使得其迭代速度更快。

IdentityHashMap则具有完全不同的性能，因为它使用==而不是equals()来比较元素。WeakHashMap将在本章稍后介绍。

练习35：（1）修改MapPerformance.java，令其包含对SlowMap的测试。

练习36：（5）修改SlowMap，使之不再使用两个ArrayList，而是只持有一个以MPair对象组成的ArrayList。验证修改后的版本是否工作正常。使用MapPerformance.java测试新Map的速度。然后修改put()方法，令其插入键值对后就执行sort()；修改get()，令其使用Collections.binarySearch()查询键。比较新旧版本的性能。

练习37：（2）修改SimpleHashMap，令其使用ArrayList代替LinkedList。修改MapPerformance.java，令其比较两种不同实现的性能。

HashMap的性能因子

我们可以通过手工调整HashMap来提高其性能，从而满足我们特定应用的需求。为了在调整HashMap时让你理解性能问题，某些术语是必需了解的：

- 容量：表中的桶位数。
- 初始容量：表在创建时所拥有的桶位数。HashMap和HashSet都具有允许你指定初始容量的构造器。
- 尺寸：表中当前存储的项数。
- 负载因子：尺寸/容量。空表的负载因子是0，而半满表的负载因子是0.5，依此类推。负载轻的表产生冲突的可能性小，因此对于插入和查找都是最理想的（但是会减慢使用迭代器进行遍历的过程）。HashMap和HashSet都具有允许你指定负载因子的构造器，表示当负载情况达到该负载因子的水平时，容器将自动增加其容量（桶位数），实现方式是使容量大致加倍，并重新将现有对象分布到新的桶位集中（这被称为再散列）。

HashMap使用的默认负载因子是0.75（只有当表达到四分之三满时，才进行再散列），这个因子在时间和空间代价之间达到了平衡。更高的负载因子可以降低表所需的空间，但是会增加查找代价，这很重要，因为查找是我们在大多数时间里所做的操作（包括get()和put()）。

如果你知道将要在HashMap中存储多少项，那么创建一个具有恰当大小的初始容量将可以避免自动再散列的开销[^11]。

练习38：（3）在JDK文档中查找HashMap。创建一个HashMap，用元素填充它，并确定其负载因子。测试这个映射表的查找速度，然后尝试着通过创建具有更大的初始容量的新的HashMap，并将旧映射表中的元素复制到这个新表中，来创建提高查找速度，之后在这个新表上再次运行查找速度测试程序。

练习39：（6）在SimpleHashMap中添加private rehash()方法，它将在负载因子超过0.75时被调用。在再散列过程中，先求出桶位数量加倍的值，然后搜索大于这个值的第一个质数，将其作为新的桶位数。