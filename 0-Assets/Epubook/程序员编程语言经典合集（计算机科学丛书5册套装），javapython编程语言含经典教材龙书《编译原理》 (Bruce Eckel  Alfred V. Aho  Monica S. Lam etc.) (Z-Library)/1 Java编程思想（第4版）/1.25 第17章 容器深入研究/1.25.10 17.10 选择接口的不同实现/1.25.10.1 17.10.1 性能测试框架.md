### 17.10.1　性能测试框架

为了防止代码重复以及为了提供测试的一致性，我将测试过程的基本功能放置到了一个测试框架中。下面的代码建立了一个基类，从中可以创建一个匿名内部类列表，其中每个匿名内部类都用于每种不同的测试，它们每个都被当作测试过程的一部分而被调用。这种方式使得你可以很方便地添加或移除新的测试种类。

这是模版方法设计模式的另一个示例。尽管你遵循了典型的模版方法模式，覆盖了每个特定测试的Test.test()方法，但是在本例中，其核心代码（不会发生变化）在一个单独的Tester类中[^10]。待测容器类型是泛型参数C：

![533-1](../Images/image03429.jpeg)

每个Test对象都存储了该测试的名字。当你调用test()方法时，必须给出待测容器，以及“信使”或“数据传输对象”，它们保存有用于该特定测试的各种参数。这些参数包括size，它表示在容器中的元素数量；以及loops，它用来控制该测试迭代的次数。这些参数在每个测试中都有可能会用到，也有可能会用不到。

每个容器都要经历一系列对test()的调用，每个都带有不同的TestParam，因此TestParam还包含静态的array()方法，使得创建TestParam对象数组变得更容易。array()的第一个版本接受的是可变参数列表，其中包括可互换的size和loops的值；而第二个版本接受相同类型的列表，但是它的值都在String中——通过这种方式，它可以用来解析命令行参数：

![533-2](../Images/image03430.jpeg)

为了使用这个框架，你需要将待测容器以及Test对象列表传递给Tester.run()方法（这些都是重载的泛型便利方法，它们可以减少在使用它们时所必需的类型检查）。Tester.run()方法调用适当的重载构造器，然后调用timedTest()，它会执行针对该容器的列表中的每一个测试。timedTest()会使用paramList中的每个TestParam对象进行重复测试。因为paramList是从静态的defaultParams数组中初始化出来的，因此你可以通过重新赋值defaultParams，来修改用于所有测试的paramList，或者可以通过传递针对某个测试的定制的paramList，来修改用于该测试的paramList：

![533-3](../Images/image03431.jpeg)

![534-1](../Images/image03432.jpeg)

![535-1](../Images/image03433.jpeg)

stringField()和numberField()方法会产生用于输出结果的格式化字符串，格式化的标准宽度可以通过修改静态的fieldWidth的值进行调整。displayHeader()方法为每个测试格式化和打印头信息。

如果你需要执行特殊的初始化，那么可以覆盖initialize()方法，这将产生具有恰当尺寸的容器对象——你可以修改现有的容器对象，或者创建新的容器对象。在test()方法中可以看到，其结果被捕获在一个被称为kontainer的局部引用中，这使得你可以将所存储的成员container替换为完全不同的被初始化的容器。

每个Test.test()方法的返回值都必须是该测试执行的操作的数量，这些测试都会计算其所有操作所需的纳秒数。你应该意识到，通常System.nanoTime()所产生的值的粒度都会大于1（这个粒度会随机器和操作系统的不同而不同），因此，在结果中可能会存在某些时间点上的重合。

执行的结果可能会随机器的不同而不同，这些测试只是想要比较不同容器的性能。