### 17.10.2　对List的选择

下面是对List操作中最本质部分的性能测试。为了进行比较，它还展示了Queue中最重要的操作。该程序创建了两个分离的用于测试每一种容器类的测试列表。在本例中，Queue操作只应用到了LinkedList之上。

![535-2](../Images/image03434.jpeg)

![536-1](../Images/image03435.jpeg)

![537-1](../Images/image03436.jpeg)

![538-1](../Images/image03437.jpeg)

每个测试都需要仔细地思考，以确保可以产生有意义的结果。例如，add测试首先清除List，然后重新填充它到指定的列表尺寸。因此，对clear()的调用也就成了该测试的一部分，并且可能会对执行时间产生影响，尤其是对小型的测试。尽管这里的结果看起来相当合理，但是你可以设想重写测试框架，使得在计时循环之外有一个对准备方法的调用（在本例中将包括clear()调用）。

注意，对于每个测试，你都必须准确地计算将要发生的操作的数量以及从test()种返回的值，因此计时是正确的。

get和set测试都使用了随机数生成器来执行对List的随机访问。在输出中，你可以看到，对于背后有数组支撑的List和ArrayList，无论列表的大小如何，这些访问都很快速和一致；而对于LinkedList，访问时间对于较大的列表将明显增加。很显然，如果你需要执行大量的随机访问，链接链表不会是一种好的选择。

iteradd测试使用迭代器在列表中间插入新的元素。对于ArrayList，当列表变大时，其开销将变得很高昂，但是对于LinkedList，相对来说比较低廉，并且不随列表尺寸而发生变化。这是因为ArrayList在插入时，必须创建空间并将它的所有引用向前移动，这会随ArrayList的尺寸增加而产生高昂的代价。LinkedList只需链接新的元素，而不必修改列表中剩余的元素，因此你可以认为无论列表尺寸如何变化，其代价大致相同。

insert和remove测试都使用了索引位置5作为插入或移除点，而没有选择List两端的元素。LinkedList对List的端点会进行特殊处理——这使得在将LinkedList用作Queue时，速度可以得到提高。但是，如果你在列表的中间增加或移除元素，其中会包含随机访问的代价，我们已经看到了，这在不同的List实现中变化很大。当执行在位置5的插入和移除时，随机访问的代价应该可以被忽略，但是我们将看不到对LinkedList端点所做的任何特殊优化操作。从输出中可以看出，在LinkedList中的插入和移除代价相当低廉，并且不随列表尺寸发生变化，但是对于ArrayList，插入操作代价特别高昂，并且其代价将随列表尺寸的增加而增加。

从Queue测试中，你可以看到LinkedList可以多么快速地从列表的端点插入和移除元素，这正是对Queue行为所做的优化。

通常，你可以只调用Tester.run()，传递容器和tests列表。但是，在这里我们必须覆盖initialize()方法，使得List在每次测试之前，都会被清空并重新填充，否则在不同的测试过程中，对于List尺寸的控制将丧失。ListTester继承自Tester，并使用CountingIntegerList执行这种初始化。run()便捷方法也被覆盖了。

我们还想将数组访问与容器访问进行比较（主要是与ArrayList比较）。在main()的第一个测试中，使用匿名内部类创建了一个特殊的Test对象。initialize()方法被覆盖为在每次被调用时都创建一个新对象（此时会忽略container对象，因此对于这个Tester构造器来说，null就是传递进来的container参数）。这个新对象是使用Generated.array()（这是在第16章中定义的）和Arrays.asList()创建的。在本例中，只有两个测试可以执行，因为你不能在使用背后有数组支撑的List时，插入或移除元素，因此List.subList()方法被用来在tests列表中选取想要执行的测试。

对于随机访问的get()和set()操作，背后有数组支撑的List只比ArrayList稍快一点，但是对于LinkedList，相同的操作会变得异常引人注目的高昂，因为它本来就不是针对随机访问操作而设计的。

应该避免使用Vector，它只存在于支持遗留代码的类库中（在此程序中它能正常工作的唯一原因，只是因为为了向前兼容，它被适配成了List）。

最佳的做法可能是将ArrayList作为默认首选，只有你需要使用额外的功能，或者当程序的性能因为经常从表中间进行插入和删除而变差的时候，才去选择LinkedList。如果使用的是固定数量的元素，那么既可以选择使用背后有数组支撑的List（就像Arrays.asList()产生的列表），也可以选择真正的数组。

CopyOnWriteArrayList是List的一个特殊实现，专门用于并发编程，我们将在第21章中讨论它。

练习29：（2）修改ListPerformance.java，使得List持有String对象而不是Integer。使用第16章中的Generator来创建测试值。

练习30：（3）在ArrayList和LinkedList之间比较Collections.sort()的性能。

练习31：（5）创建一个封装String数组的容器，该容器只允许添加和读取String，因此在使用过程中不存在任何转型问题。如果在添加下一个元素时，内部数据没有足够的空间，该容器应该自动调整其尺寸。在main()中，比较你的容器与ArrayList<String>的性能。

练习32：（2）重复前一个练习，使容器中包含int，并与与ArrayList<String>比较性能。在性能比较中，包括递增容器中每个对象的处理。

练习33：（5）创建一个FastTraversalLinkedList，为了快速插入与移除，它的内部使用了一个LinkedList，而为了快速遍历和get()操作，则使用了一个ArrayList。通过修改ListPerformance.java来测试它。