### 17.8.1　性能

性能是映射表中的一个重要问题，当在get()中使用线性搜索时，执行速度会相当地慢，而这正是HashMap提高速度的地方。HashMap使用了特殊的值，称作散列码，来取代对键的缓慢搜索。散列码是“相对唯一”的、用以代表对象的int值，它是通过将该对象的某些信息进行转换而生成的。hashCode()是根类Object中的方法，因此所有Java对象都能产生散列码。HashMap就是使用对象的hashCode()进行快速查询的，此方法能够显著提高性能[^6]。

下面是基本的Map实现。在HashMap上打星号表示如果没有其他的限制，它就应该成为你的默认选择，因为它对速度进行了优化。其他实现强调了其他的特性，因此都不如HashMap快。

![518-1](../Images/image03410.jpeg)

散列是映射中存储元素时最常用的方式。稍后你将会了解散列机制是如何工作的。

对Map中使用的键的要求与对Set中的元素的要求一样，在TypesForSets.java中展示了这一点。任何键都必须具有一个equals()方法；如果键被用于散列Map，那么它必须还具有恰当的hashCode()方法；如果键被用于TreeMap，那么它必须实现Comparable。

下面的示例展示了通过Map接口可用的操作，这里使用了前面定义过的CountingMapData测试数据集：

![518-2](../Images/image03411.jpeg)

![519-1](../Images/image03412.jpeg)

printKeys()展示了如何生成Map的Collection视图。keySet()方法返回由Map的键组成的Set。因为在Java SE5提供了改进的打印支持，你可以直接打印values()方法的结果，该方法会产生一个包含Map中所有“值”的Collection。（注意，键必须是唯一的，而值可以有重复。）由于这些Collection背后是由Map支持的，所以对Collection的任何改动都会反映到与之相关联的Map。

此程序的剩余部分提供了每种Map操作的简单示例，并测试了每种基本类型的Map。

练习14：（3）说明java.util.Properties在上面的程序中可以工作。