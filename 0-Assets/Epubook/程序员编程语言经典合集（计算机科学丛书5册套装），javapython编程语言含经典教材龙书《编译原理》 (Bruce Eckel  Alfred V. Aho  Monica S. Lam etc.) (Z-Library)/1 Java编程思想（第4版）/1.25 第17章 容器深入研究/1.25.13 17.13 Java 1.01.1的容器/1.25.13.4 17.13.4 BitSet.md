### 17.13.4　BitSet

如果想要高效率地存储大量“开/关”信息，BitSet是很好的选择。不过它的效率仅是对空间而言；如果需要高效的访问时间，BitSet比本地数组稍慢一点。

此外，BitSet的最小容量是long：64位。如果存储的内容比较小，例如8位，那么BitSet就浪费了一些空间。因此如果空间对你很重要，最好撰写自己的类，或者直接采用数组来存储你的标志信息（只有在创建包含开关信息列表的大量对象，并且促使你做出决定的依据仅仅是性能和其他度量因素时，才属于这种情况。如果你做出这个决定只是因为你认为某些对象太大了，那么你最终会产生不需要的复杂性，并会浪费掉大量的时间）。

普通的容器都会随着元素的加入而扩充其容量，BitSet也是。以下示范了BitSet是如何工作的：

![556-1](../Images/image03461.jpeg)

![557-1](../Images/image03462.jpeg)

随机数发生器被用来生成随机的byte、short和int，每一个都被转换为BitSet中相应的位模式。因为BitSet是64位的，所以任何生成的随机数都不会导致BitSet扩充容量。然后创建了一个更大的BitSet。你可以看到，BitSet在必要时会进行扩充。

如果拥有一个可以命名的固定的标志集合，那么EnumSet（查看第19章）与BitSet相比，通常是一种更好的选择，因为EnumSet允许你按照名字而不是数字位的位置进行操作，因此可以减少错误。EnumSet还可以防止你因不注意而添加新的标志位置，这种行为能够引发严重的、难以发现的缺陷。你应该使用BitSet而不是EnumSet的理由只包括：只有在运行时才知道需要多少个标志；对标志命名不合理；需要BitSet中的某种特殊操作（查看BitSet和EnumSet的JDK文档）。