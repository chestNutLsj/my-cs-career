### 17.2.1　一种Generator解决方案

事实上，所有的Collection子类型都有一个接收另一个Collection对象的构造器，用所接收的Collection对象中的元素来填充新的容器。为了更加容易地创建测试数据，我们需要做的是构建接收Generator（在第15章中定义并在第16章中深入探讨过）和quantity数值并将它们作为构造器参数的类：

![494-1](../Images/image03376.jpeg)

这个类使用Generator在容器中放置所需数量的对象，然后所产生的容器可以传递给任何Collection的构造器，这个构造器会把其中的数据复制到自身中。addAll()方法是所有Collection子类型的一部分，它也可以用来组装现有的Collection。

泛型便利方法可以减少在使用类时所必需的类型检查数量。

CollectionData是适配器设计模式[^1]的一个实例，它将Generator适配到Collection的构造器上。

下面是初始化LinkedHashSet的一个示例：

![494-2](../Images/image03377.jpeg)

这些元素的顺序与它们的插入顺序相同，因为LinkedHashSet维护的是保持了插入顺序的链接列表。

在第16章中定义的所有操作符现在通过CollectionData适配器都是可用的。下面是使用了其中两个操作符的示例：

![495-1](../Images/image03378.jpeg)

RandomGenerator.String所产生的String长度是通过构造器参数控制的。