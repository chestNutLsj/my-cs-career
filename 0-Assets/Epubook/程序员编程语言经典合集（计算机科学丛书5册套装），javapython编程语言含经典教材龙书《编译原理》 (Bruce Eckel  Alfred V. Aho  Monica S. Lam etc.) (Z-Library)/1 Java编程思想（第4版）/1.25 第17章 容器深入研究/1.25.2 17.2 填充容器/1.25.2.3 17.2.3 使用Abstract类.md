### 17.2.3　使用Abstract类

对于产生用于容器的测试数据问题，另一种解决方式是创建定制的Collection和Map实现。每个java.util容器都有其自己的Abstract类，它们提供了该容器的部分实现，因此你必须做的只是去实现那些产生想要的容器所必需的方法。如果所产生的容器是只读的，就像它通常用的测试数据那样，那么你需要提供的方法数量将减少到最少。

尽管在本例中不是特别需要，但是下面的解决方案还是提供了一个机会来演示另一种设计模式：享元。你可以在普通的解决方案需要过多的对象，或者产生普通对象太占用空间时使用享元。享元模式使得对象的一部分可以被具体化，因此，与对象中的所有事物都包含在对象内部不同，我们可以在更加高效的外部表中查找对象的一部分或整体（或者通过某些其他节省空间的计算来产生对象的一部分或整体）。

这个示例的关键之处在于演示通过继承java.util.Abstract来创建定制的Map和Collection到底有多简单。为了创建只读的Map，可以继承AbstractMap并实现entrySet()。为了创建只读的Set，可以继承AbstractSet并实现iterator()和size()。

本例中使用的数据集是由世界上的国家以及它们的首都构成的Map[^2]方法产生国名的List。在两种情况中，你都可以通过提供表所需尺寸的int参数来获取部分列表：

![497-2](../Images/image03384.jpeg)

![498-1](../Images/image03385.jpeg)

![499-1](../Images/image03386.jpeg)

![500-1](../Images/image03387.jpeg)

![501-1](../Images/image03388.jpeg)

二维数组String DATA是public的，因此它可以在其他地方使用。FlyweightMap必须实现entrySet()方法，它需要定制的Set实现和定制的Map.Entry类。这里正是享元部分：每个Map.Entry对象都只存储了它的索引，而不是实际的键和值。当你调用getKey()和getValue()时，它们会使用该索引来返回恰当的DATA元素。EntrySet可以确保它的size不会大于DATA。

你可以在EntrySet.Iterator中看到享元其他部分的实现。与为DATA中的每个数据对都创建Map.Entry对象不同，每个迭代器只有一个Map.Entry。Entry对象被用作数据的视窗，它只包含在静态字符串数组中的索引。你每次调用迭代器的next()方法时，Entry中的index都会递增，使其指向下一个元素对，然后从next()返回该Iterator所持有的单一的Entry对象[^3]。

select()方法将产生一个包含指定尺寸的EntrySet的FlyweightMap，它会被用于重载过的capitals()和names()方法，正如在main()中所演示的那样。

对于某些测试，Countries的尺寸受限会成为问题。我们可以采用与产生定制容器相同的方式来解决，其中定制容器是经过初始化的，并且具有任意尺寸的数据集。下面的类是一个List，它可以具有任意尺寸，并且用Integer数据（有效地）进行了预初始化：

![502-1](../Images/image03389.jpeg)

为了从AbstractList创建只读的List，你必须实现get()和size()。这里再次使用了享元解决方案：当你寻找值时，get()将产生它，因此这个List实际上并不必组装。

下面是包含经过预初始化，并且都是唯一的Integer和String对的Map，它可以具有任意尺寸：

![502-2](../Images/image03390.jpeg)

![503-1](../Images/image03391.jpeg)

这里使用的是LinkedHashSet，而不是定制的Set类，因此享元并未完全实现。

练习1：（1）创建一个List（用ArrayList和LinkedList都尝试一下），然后用Countries来填充。对该列表排序并打印，然后将Collections.shuffle()方法重复地应用于该列表，并且每次都打印它，这样你就可以看到shuffle()方法是如何每次都将列表随机打乱的了。

练习2：（2）生成一个Map和Set，使其包含所有以字母A开头的国家。

练习3：（1）使用Countries，用同样的数据多次填充Set，然后验证此Set中没有重复的元素。使用HashSet、LinkedHashSet和TreeSet做此测试。

练习4：（2）创建一个Collection初始化器，它将打开一个文件，并用TextFile将其断开为单词，然后将这些单词作为所产生的Collection的数据源使用。请演示它是可以工作的。

练习5：（3）修改CountingMapData.java，通过添加像Countries.java中那样的定制EntrySet类，来完全实现享元。