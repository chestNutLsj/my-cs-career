### 17.2.2　Map生成器

我们可以对Map使用相同的方式，但是这需要有一个Pair类，因为为了组装Map，每次调用Generator的next()方法都必须产生一个对象对（一个键和一个值）：

![495-2](../Images/image03379.jpeg)

key和value域都是public和final的，这是为了使Pair成为只读的数据传输对象（或信使）。

Map适配器现在可以使用各种不同的Generator、Iterator和常量值的组合来填充Map初始化对象：

![495-3](../Images/image03380.jpeg)

![496-1](../Images/image03381.jpeg)

这给了你一个机会，去选择使用单一的Generator<Pair<K，V>>、两个分离的Generator、一个Generator和一个常量值、一个Iterable（包括任何Collection）和一个Generator，还是一个Iterable和一个单一值。泛型便利方法可以减少在创建MapData类时所必需的类型检查数量。

下面是一个使用MapData的示例。LettersGenerator通过产生一个Iterator还实现了Iterable，通过这种方式，它可以被用来测试MapData.map()方法，而这些方法都需要用到Iterable：

![496-2](../Images/image03382.jpeg)

![497-1](../Images/image03383.jpeg)

这个示例也使用了第16章中的生成器。

可以使用工具来创建任何用于Map或Collection的生成数据集，然后通过构造器或Map.putAll()和Collection.addAll()方法来初始化Map和Collection。