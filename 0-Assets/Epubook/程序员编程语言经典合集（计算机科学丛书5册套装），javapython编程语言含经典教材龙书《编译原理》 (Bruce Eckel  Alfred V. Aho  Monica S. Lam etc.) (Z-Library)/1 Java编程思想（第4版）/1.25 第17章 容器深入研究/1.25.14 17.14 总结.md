## 17.14　总结

可以证明，容器类库对于面向对象语言来说是最重要的类库。大多数编程工作对容器的使用比对其他类库中的构件都要多。某些语言（例如Python）甚至包含内建的基本容器构件（列表、映射表和集）。

正如你在第11章中所看到的，通过使用容器，无须费力，就可以完成大量非常有趣的操作。但是，在某些时候，你必须更多地了解容器，以便正确地使用它们。特别是，你必须对散列操作有足够的了解，从而能够编写自己的hashCode()方法（并且你必须知道何时需要这么做），你还必须对各种不同的容器实现有足够的了解，这样才能够为你的需要进行恰当的选择。本章覆盖了有关容器类库的这些概念，并讨论了其他有用的细节。至此，你应该已经为在每天的编程任务中使用Java容器做好了充足的准备。

容器类库的设计非常艰难（大多数类库设计问题都是如此）。在C++中，用许多不同的类覆盖了容器类的基础。这与C++容器类之前的可用情况（无任何类可用）相比是一种进步，但是它没有被很好地转译到Java中。在另一个极端情况中，我看到过容器类库由单一的类构成，即Container，它同时起到了线性序列和关联数组的作用。Java容器类库在这二者之间达到了一种平衡：具有成熟的容器类库应该具有的完备的功能，但是比C++容器类和其他类似的容器类库易于学习和使用。这样产生的结果在若干方面看起来都有些奇异，与早期Java类库中所作的某些决策不同，这些奇异性不是偶然的，而是基于复杂性的利弊而仔细权衡的产物。

所选习题的答案都可以在名为The Thinking in Java Annotated Solution Guide的电子文档中找到，读者可以从www.MindView.net购买此文档。

---

[^1]: 与《设计模式》这本书中所定义的适配器相比，这也许并非是适配器的严格定义，但是我认为它符合适配器思想的基本精神。该书中文版、英文影印版与双语版均已由机械工业出版社出版。——编辑注

[^2]: 这个数据是从Internet上找到的，读者们已经提交了各种各样的校正。

[^3]: 来执行成批复制，因此这样是可以工作的。如果定制的Map直接复制完整的Map.Entry，那么这种方法就会有问题。

[^4]: 我在这里使用术语“接口”来描述正式的interface关键字和“任何类或子类支持的方法”这一更通用的含义。

[^5]: 尽管当我以这种方式来描述时，听起来会感觉很奇怪，并且显得有些无用，但是正如你所看到的，特别是在第14章中，这种类型的动态行为会显得非常强大。

[^6]: 如果这仍不能满足你对性能的要求，那么你还可以通过创建自己的Map来进一步提高查询速度，并且令新的Map只针对你使用的特定类型，这样可以避免与Object之间的类型转换操作。要到达更高的性能，速度狂们可以参考Donald Knuth的The Art of Computer Programming，Volume 3：Sorting and Searching，Second Edition。使用数组代替溢出桶，这有两个好处：第一，可以针对磁盘存储方式做优化；第二，在创建和回收单独的记录时，能节约很多时间。

[^7]: 完美的散列函数在Java SE5的EnumMap和EnumSet中得到了实现，因为enum定义了固定数量的实例。请查看第19章。

[^8]: 有些影响）。

[^9]: 或者实现为EnumSet和CopyOnWriteArraySet，它们是特例。尽管我承认各种不同的容器接口都可能拥有额外的特殊实现，但是本节还是试图只浏览那些更加通用的情况。

[^10]: Krzysztof Sobolewski帮助我设计了本例中的泛型。

[^11]: 在一份私人通讯中，Joshua Bloch写道：“……我相信在API中暴露实现细节（例如散列表尺寸和负载因子）使我们误入歧途。客户端应用可以告诉我们集合的最大期望尺寸，并且我们应该在接口中接受这个参数。但是，让客户端选择这些参数值很容易变得弊大于利。例如，考虑一个极端的例子，Vector的capacityIncrement。不应该有人能够设置这个值，我们也不应该提供这个方法。如果将这个值设置为任何非零值，那么在序列中追加空间的渐进代价将从线性关系变为二次关系。换句话说，它会摧毁程序的性能。随着时间的推移，我们开始渐渐地了解这类事情。如果你看看IdentityHashMap，那么就会发现它没有任何低级别的调整参数。”