### 17.11.3　Collection或Map的同步控制

关键字synchronized是多线程议题中的重要部分，第21章将讨论这种较为复杂的主题。这里，我只提醒读者注意，Collections类有办法能够自动同步整个容器。其语法与“不可修改的”方法相似：

![550-1](../Images/image03452.jpeg)

最好是如上所示，直接将新生成的容器传递给了适当的“同步”方法；这样做就不会有任何机会暴露出不同步的版本。

快速报错

Java容器有一种保护机制，能够防止多个进程同时修改同一个容器的内容。如果在你迭代遍历某个容器的过程中，另一个进程介入其中，并且插入、删除或修改此容器内的某个对象，那么就会出现问题：也许迭代过程已经处理过容器中的该元素了，也许还没处理，也许在调用size()之后容器的尺寸收缩了——还有许多灾难情景。Java容器类类库采用快速报错（fail-fast）机制。它会探查容器上的任何除了你的进程所进行的操作以外的所有变化，一旦它发现其他进程修改了容器，就会立刻抛出ConcurrentModificationException异常。这就是“快速报错”的意思——即，不是使用复杂的算法在事后来检查问题。

很容易就可以看出“快速报错”机制的工作原理：只需创建一个迭代器，然后向迭代器所指向的Collection添加点什么，就像这样：

![550-2](../Images/image03453.jpeg)

程序运行时发生了异常，因为在容器取得迭代器之后，又有东西被放入到了该容器中。当程序的不同部分修改同一个容器时，就可能导致容器的状态不一致，所以，此异常提醒你，应该修改代码。在此例中，应该在添加完所有的元素之后，再获取迭代器。

ConcurrentHashMap、CopyOnWriteArrayList和CopyOnWriteArraySet都使用了可以避免ConcurrentModificationException的技术。