### 17.9.3　覆盖hashCode()

在明白了如何散列之后，编写自己的hashCode()就更有意义了。

首先，你无法控制bucket数组的下标值的产生。这个值依赖于具体的HashMap对象的容量，而容量的改变与容器的充满程度和负载因子（本章稍后会介绍这个术语）有关。hashCode()生成的结果，经过处理后成为桶位的下标（在SimpleHashMap中，只是对其取模，模数为bucket数组的大小）。

设计hashCode()时最重要的因素就是：无论何时，对同一个对象调用hashCode()都应该生成同样的值。如果在将一个对象用put()添加进HashMap时产生一个hashCode()值，而用get()取出时却产生了另一个hashCode()值，那么就无法重新取得该对象了。所以，如果你的hashCode()方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode()就会生成一个不同的散列码，相当于产生了一个不同的键。

此外，也不应该使hashCode()依赖于具有唯一性的对象信息，尤其是使用this的值，这只能产生很糟糕的hashCode()。因为这样做无法生成一个新的键，使之与put()中原始的键值对中的键相同。这正是SpringDetector.java的问题所在，因为它默认的hashCode()使用的是对象的地址。所以，应该使用对象内有意义的识别信息。

下面以String类为例。String有个特点：如果程序中有多个String对象，都包含相同的字符串序列，那么这些String对象都映射到同一块内存区域。所以new String（“hello”）生成的两个实例，虽然是相互独立的，但是对它们使用hashCode()应该生成同样的结果。通过下面的程序可以看到这种情况：

![528-1](../Images/image03423.jpeg)

对于String而言，hashCode()明显是基于String的内容的。

因此，要想使hashCode()实用，它必须速度快，并且必须有意义。也就是说，它必须基于对象的内容生成散列码。记得吗，散列码不必是独一无二的（应该更关注生成速度，而不是唯一性），但是通过hashCode()和equals()，必须能够完全确定对象的身份。

因为在生成桶的下标前，hashCode()还需要做进一步的处理，所以散列码的生成范围并不重要，只要是int即可。

还有另一个影响因素：好的hashCode()应该产生分布均匀的散列码。如果散列码都集中在一块，那么HashMap或者HashSet在某些区域的负载会很重，这样就不如分布均匀的散列函数快。

在Effective Java Programming Language Guide（Addison-Wesley 2001）这本书中，Joshua Bloch为怎样写出一份像样的hashCode()给出了基本的指导：

1）给int变量result赋予某个非零值常量，例如17。

2）为对象内每个有意义的域f（即每个可以做equals()操作的域）计算出一个int散列码c：

![529-1](../Images/image03424.jpeg)

3）合并计算得到的散列码：

result = 37 * result + c；

4）返回result。

5）检查hashCode()最后生成的结果，确保相同的对象有相同的散列码。

下面便是遵循这些指导的一个例子：

![529-2](../Images/image03425.jpeg)

![530-1](../Images/image03426.jpeg)

CountedString由一个String和一个id组成，此id代表包含相同String的CountedString对象的编号。所有的String都被存储在static ArrayList中，在构造器中通过迭代遍历此ArrayList完成对id的计算。

hashCode()和equals()都基于CountedString的这两个域来生成结果；如果它们只基于String或者只基于id，不同的对象就可能产生相同的值。

在main()中，使用相同的String创建了多个CountedString对象。这说明，虽然String相同，但是由于id不同，所以使得它们的散列码并不相同。在程序中，HashMap被打印了出来，因此可以看到它内部是如何存储元素的（以无法辨别的次序），然后单独查询每一个键，以此证明查询机制工作正常。

作为第二个示例，请考虑Individual类，它被用作第14章中所定义的typeinfo.pet类库的基类。Individual类在那一章中就用到了，而它的定义则放到了本章，因此你可以正确地理解其实现：

![531-1](../Images/image03427.jpeg)

compareTO()方法有一个比较结构，因此它会产生一个排序序列，排序的规则首先按照实际类型排序，然后如果有名字的话，按照name排序，最后按照创建的顺序排序。下面的示例说明了它是如何工作的：

![531-2](../Images/image03428.jpeg)

由于所有的宠物都有名字，因此它们首先按照类型排序，然后在同类型中按照名字排序。

为新类编写正确的hashCode()和equals()是很需要技巧的。Apache的Jakarta Commons项目中有许多工具可以帮助你完成此事，该项目可在jakarta.apache.org/commons的lang下面找到。（此项目还包括许多其他有用的类库，而且它似乎是Java社区对C++的www.boost.org作出的回应）。

练习26：（2）在CountedString中添加一个char域，它也将在构造器中初始化，然后修改hashCode()和equals()方法，使它们都包含这个char域的值。

练习27：（3）修改CountedString.java中的hashCode()，移除与id的绑定，并且证明CountedString仍能正常作为键使用。这种方式有没有问题？

练习28：（4）修改net/mindview/util/Tuple.java，通过添加hashCode()和equals()方法，并为每种Tuple类型都实现一个Comparable，使其成为一个通用类。