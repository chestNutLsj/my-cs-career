### 17.9.1　理解hashCode()

前面的例子只是正确解决问题的第一步。它只说明，如果不为你的键覆盖hashCode()和equals()，那么使用散列的数据结构（HashSet，HashMap，LinkedHashSet或LinkedHashMap）就无法正确处理你的键。然而，要很好地解决此问题，你必须了解这些数据结构的内部构造。

首先，使用散列的目的在于：想要使用一个对象来查找另一个对象。不过使用TreeMap或者你自己实现的Map也可以达到此目的。与散列实现相反，下面的示例用一对ArrayLists实现了一个Map。与AssociativeArray.java不同，这其中包含了Map接口的完整实现，因此提供了entrySet()方法：

![523-2](../Images/image03418.jpeg)

![524-1](../Images/image03419.jpeg)

put()方法只是将键与值放入相应的ArrayList。为了与Map接口保持一致，它必须返回旧的键，或者在没有任何旧键的情况下返回null。

同样遵循了Map规范，get()会在键不在SlowMap中的时候产生null。如果键存在，它将被用来查找表示它在keys列表中的位置的数值型索引，并且这个数字被用作索引来产生与values列表相关联的值。注意，在get()中key的类型是Object，而不是你所期望的参数化类型K（并且是在AssociativeArray.java中真正使用的类型）。这是将泛型注入到Java语言中的时刻如此之晚所导致的结果——如果泛型是Java语言最初就具备的属性，那么get()就可以执行其参数的类型。

Map.entrySet()方法必须产生一个Map.Entry对象集。但是，Map.Entry是一个接口，用来描述依赖于实现的结构，因此如果你想要创建自己的Map类型，就必须同时定义Map.Entry的实现：

![524-2](../Images/image03420.jpeg)

这里，这个被称为MapEntry的十分简单的类可以保存和读取键与值，它在entrySet()中用来产生键-值对Set。注意，entrySet()使用了HashSet来保存键-值对，并且MapEntry采用了一种简单的方式，即只使用key的hashCode()方法。尽管这个解决方案非常简单，并且看起来在SlowMap.main()的琐碎测试中可以工作，但是这并不是一个恰当的实现，因为它创建了键和值的副本。entrySet()的恰当实现应该在Map中提供视图，而不是副本，并且这个视图允许对原始映射表进行修改（副本就不行）。练习16提供了修正这个问题的机会。

注意，在MapEntry中的equals()方法必须同时检查键和值，而hashCode()方法的含义稍后就会介绍。SlowMap的内容的String表示是由在AbstractMap中定义的toString()方法自动产生的。

练习15：（1）使用SlowMap重复练习13。

练习16：（7）将Map.java中的测试应用于SlowMap，验证并修改它，使其能正常工作。

练习17：（2）令SlowMap实现完整的Map接口。

练习18：（3）参考SlowMap.java，创建一个SlowSet。