## 4.7　臭名昭著的goto

编程语言中一开始就有goto关键词了。事实上，goto起源于汇编语言的程序控制：“若条件A成立，则跳到这里；否则跳到那里”。如果阅读由编译器最终生成的汇编代码，就会发现程序控制里包含了许多跳转。（Java编译器生成它自己的“汇编代码”，但是这个代码是运行在Java虚拟机上的，而不是直接运行在CPU硬件上。）

goto语句是在源码级上的跳转，这使其招致了不好的声誉。若一个程序总是从一个地方跳到另一个地方，还有什么办法能识别程序的控制流程呢？自从Edsger Dijkstra发表了著名论文《Goto considered harmful》（Goto有害），众人开始痛斥goto的不是，甚至建议将它从关键词集合中扫地出门。

对于这个问题，中庸之道是最好解决方法。真正的问题并不在于使用goto，而在于goto的滥用；而且少数情况下，goto还是组织控制流程的最佳手段。

尽管goto仍是Java中的一个保留字，但在语言中并未使用它；Java没有goto。然而，Java也能完成一些类似于跳转的操作，这与break和continue这两个关键词有关。它们其实不是一个跳转，而是中断迭代语句的一种方法。之所以把它们纳入goto问题中一起讨论，是由于它们使用了相同的机制：标签。

标签是后面跟有冒号的标识符，就像下面这样：

![104-3](../Images/image02709.jpeg)

在Java中，标签起作用的唯一的地方刚好是在迭代语句之前。“刚好之前”的意思表明，在标签和迭代之间置入任何语句都不好。而在迭代之前设置标签的唯一理由是：我们希望在其中嵌套另一个迭代或者一个开关（你很快就会学习到它）。这是由于break和continue关键词通常只中断当前循环，但若随同标签一起使用，它们就会中断循环，直到标签所在的地方：

![104-1](../Images/image02710.jpeg)

在（1）中，break中断内部迭代，回到外部迭代。在（2）中，continue使执行点移回内部迭代的起始处。在（3）中，continue label1同时中断内部迭代以及外部迭代，直接转到label1处；随后，它实际上是继续迭代过程，但却从外部迭代开始。在（4）中，break label1也会中断所有迭代，并回到label1处，但并不重新进入迭代。也就是说，它实际是完全中止了两个迭代。

下面是标签用于for循环的例子：

![104-2](../Images/image02711.jpeg)

![105-1](../Images/image02712.jpeg)

注意，break会中断for循环，而且在抵达for循环的末尾之前，递增表达式不会执行。由于break跳过了递增表达式，所以在i==3的情况下直接对i执行递增运算。在i==7的情况下，continue outer语句会跳到循环顶部，而且也会跳过递增，所以这里也对i直接递增。

如果没有break outer语句，就没有办法从内部循环里跳出外部循环。这是由于break本身只能中断最内层的循环（continue同样也是如此）。

当然，如果想在中断循环的同时退出，简单地用一个return即可。

下面这个例子向大家展示了带标签的break以及continue语句在while循环中的用法：

![105-2](../Images/image02713.jpeg)

![106-1](../Images/image02714.jpeg)

同样的规则亦适用于while：

1）一般的continue会退回最内层循环的开头（顶部），并继续执行。

2）带标签的continue会到达标签的位置，并重新进入紧接在那个标签后面的循环。

3）一般的break会中断并跳出当前循环。

4）带标签的break会中断并跳出标签所指的循环。

要记住的重点是：在Java里需要使用标签的唯一理由就是因为有循环嵌套存在，而且想从多层嵌套中break或continue。

在Dijkstra的《Goto有害》的论文中，他最反对的就是标签，而非goto。他发现在一个程序里随着标签的增多，产生的错误也会越来越多，并且标签和goto使得程序难以分析。但是，Java的标签不会造成这种问题，因为它们的应用场合已经受到了限制，没有特别的方式用于改变程序的控制。由此也引出了一个有趣的现象：通过限制语句的能力，反而能使一项语言特性更加有用。