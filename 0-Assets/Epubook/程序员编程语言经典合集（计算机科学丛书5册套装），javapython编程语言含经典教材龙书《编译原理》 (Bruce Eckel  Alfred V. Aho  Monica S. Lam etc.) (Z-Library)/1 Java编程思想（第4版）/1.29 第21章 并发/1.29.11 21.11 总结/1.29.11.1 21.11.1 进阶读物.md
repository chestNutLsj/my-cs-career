### 21.11.1　进阶读物

遗憾的是，关于并发有大量的误导信息——这强调了它会多么地令人困惑，以及你会多么轻易地认为自己理解了这些问题（我了解这一点，因为我自己有深刻的印象，过去我无数次地认为自己已经理解了线程机制，但是我并不怀疑在将来我还会产生更多的顿悟之感）。当你获得了一篇关于并发的新文献时，总是需要一些警惕，以努力了解作者本人理解哪些和不理解哪些。下面这些书籍，我认为我可以放心大胆地说它们是可靠的：

《Java Concurrency in Practice》，作者Brian Goetz、Tim Peierls、Joshua Bloch、Joseph Bowbeer、David Holmes和Doug Lea（Addison-Wesley，2006）。基本上，这就是Java线程机制世界中的名人录。

《Concurrent Programming in Java，Second Edition》，作者Doug Lea（Addison-Wesley，2000）。尽管这本书远早于Java SE5，但是Doug的许多成果都成为了新的java.util.concurrent类库，因此本书对于全面理解并发问题至关重要。它超越了Java并发，探讨了当前跨语言和技术的并发思想。尽管在一些地方它显得有些愚钝，但是它值得多次阅读（最好是每次重读都间隔数月，这样有助于你消化其中的信息）。Doug是确实理解并发的少数人之一，因此这是绝对值得一看的书籍。

《The Java Language Specification，Third Edition》（第17章），作者Gosling、Joy、Steele和Bracha（Addison-Wesley，2005）。这是一个技术规范，更方便的获取方式是到http://java.sun.com/docs/books/jls处下载其电子文档。

所选习题的答案都可以在名为The Thinking in Java Annotated Solution Guide的电子文档中找到，读者可以从https://www.mindviewllc.com处购买此文档。

---

[^1]: 例如，Eric Raymond在《The Art of UNIX Programming》（Addison-Wesley，2004）中提出了这种极端情况。

[^2]: 可能有人会有异议，认为将并发绑定到顺序型语言上是一种糟糕的方式，但是你必须得出自己的结论。

[^3]: 这个要求从来都没有完全实现过，Sun也不再大肆吹捧了。具有讽刺意味的是，“编写一次，到处运行”并不能完全工作的原因也许是因为多线程系统中的问题而导致的——这在Java SE5中可能已经修复了。

[^4]: 当系统使用时间切片机制时，情况确实如此（例如Windows）。Solaris使用了FIFO并发模型：除非有高优先级的线程被唤醒，否则当前线程将一直运行，直至它被阻塞或终止。这意味着具有相同优先级的其他线程在当前线程放弃处理器之前，将不会运行。

[^5]: ）在创建所有的LiftOff线程。但是，如果多个线程在创建LiftOff线程，那么就有可能会有多个LiftOff拥有相同的id。在本章稍后你会了解到这是为什么。

[^6]: 对于某些最早版本的Java来说，情况并非如此。

[^7]: 它还提供了一种重要的并发保证，其他线程不会（即没有两个线程会）被并发调用。这会改变任务的加锁需求（你将在本章稍后学习锁机制）。

[^8]: 《Effective JavaTM Programming Language Guide》，Joshua Bloch著，Addison-Wesley，2001，第211页。本书中文版已由机械工业出版社出版。——编辑注

[^9]: 以及贯穿于Java有生以来的其他许多问题。嗯，问什么止步于此呢？因为我已经参考过很多存在这个问题的项目了。

[^10]: 引自Brian Goetz，《Java Concurrency in Practice》的作者，这本书的作者包括Brian Goetz、Tim Peierls、Joshua Bloch、Joseph Bowbeer、David Holmes和Doug Lea（Addison-Wesley，2006）。

[^11]: 以前提到的Brian Goetz命名的测试。Brian Goetz是一位并发专家，他对本章有所贡献，这都源自他那些半开玩笑的评论。

[^12]: 这个测试的一个推论是：“如果某人表示线程机制很容易并且很简单，那么请确保这个人没有对你的项目做出重要的决策。如果这个人已经在这么做了，那么你就已经陷入麻烦之中了。”

[^13]: 这在即将产生的C++标准中得到了补救。

[^14]: 受Joshua Bloch的《Effective Java Programming Language Guide》（Addison-Wesley，2001，190页）的启发，本书中文版已由机械工业出版社出版。——编辑注

[^15]: 参考《设计模式》（Design Pattern），作者Gamma等（Addison-Wesley，1995）。本书英文版、中文版及双语版均已由机械工业出版社出版——编辑注。

[^16]: 但是，异常从来都不能异步地传递。因此，在指令/方法调用的中间突然中断没有任何危险。只要在使用对象互斥机制（与synchronized关键字相对）时使用try-finally惯用法，如果抛出异常，这些互斥就会自动被释放。

[^17]: 某些版本的JDK还提供对InterruptedIOException的支持。但是，这只是部分实现，而且只在某些平台上可用。如果抛出这个异常，它会导致IO对象不可用。未来的版本不太可能继续支持这个异常。

[^18]: Ervin Varga协助我研究了本节。

[^19]: 的调用之前。

[^20]: （或者与它们等价的新的Condition对象）来提示。这个线程表面上看起来是由其自身唤醒的。伪唤醒之所以存在，是因为实现POSIX线程，或者其等价物，在某些平台上，并非总是如它们应该表现出的那样简单直观。伪唤醒机制使得在这些平台上执行诸如构建像pthreads这样的类库的工作会容易一些。

[^21]: 当两个任务可以修改它们的状态（它们不会阻塞）时，你还可以使用活锁，但是这么做不会得到什么有用的改进。

[^22]: 那时我还是高中的新生，教室里有一台ASR-33电传打字机，通过波特率为110的声音耦合调制解调器来访问一台HP-1000。

[^23]: Brian Goetz在向我解释这些问题时提供了很多帮助。请查看在www-128.ibm.com/developerworks/library/jjtp12214上的他的文章，以了解更多的性能度量方面的知识。

[^24]: 查看www.MindView.net上的《Thinking in Patterns》。

[^25]: 对于在Java动态编译影响下的基准测试的简介，可以查看www-128.ibm.com/developerworks/library/j-jtp12214。

[^26]: 感谢Allen Holub花时间向我解释了这些。

[^27]: 作业，我建议读者将其作为课程大作业。解答指南中不包含此类作业的解决方案。