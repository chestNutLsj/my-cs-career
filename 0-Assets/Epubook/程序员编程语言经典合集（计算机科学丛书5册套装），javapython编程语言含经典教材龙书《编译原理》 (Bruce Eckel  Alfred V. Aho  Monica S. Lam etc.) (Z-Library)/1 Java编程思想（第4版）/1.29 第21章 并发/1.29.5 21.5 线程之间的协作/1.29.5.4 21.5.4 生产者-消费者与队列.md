### 21.5.4　生产者-消费者与队列

wait()和notifyAll()方法以一种非常低级的方式解决了任务互操作问题，即每次交互时都握手。在许多情况下，你可以瞄向更高的抽象级别，使用同步队列来解决任务协作问题，同步队列在任何时刻都只允许一个任务插入或移除元素。在java.util.concurrent.BlockingQueue接口中提供了这个队列，这个接口有大量的标准实现。你通常可以使用LinkedBlockingQueue，它是一个无届队列，还可以使用ArrayBlockingQueue，它具有固定的尺寸，因此你可以在它被阻塞之前，向其中放置有限数量的元素。

如果消费者任务试图从队列中获取对象，而该队列此时为空，那么这些队列还可以挂起消费者任务，并且当有更多的元素可用时恢复消费者任务。阻塞队列可以解决非常大量的问题，而其方式与wait()和notifyAll()相比，则简单并可靠得多。

下面是一个简单的测试，它将多个LiftOff对象的执行串行化了。消费者是LiftOffRunner，它将每个LiftOff对象从BlockingQueue中推出并直接运行。（即，它通过显式地调用run()而使用自己的线程来运行，而不是为每个任务启动一个新线程。）

![747-1](../Images/image03739.jpeg)

各个任务由main()放置到了BlockingQueue中，并且由LiftOffRunner从BlockingQueue中取出。注意，LiftOffRunner可以忽略同步问题，因为它们已经由BlockingQueue解决了。

练习28：（3）修改TestBlockingQueue.java，添加一个将LiftOff放置到BlockingQueue中的任务，而不要放置在main()中。

吐司BlockingQueue

考虑下面这个使用BlockingQueue的示例，有一台机器具有三个任务：一个制作吐司、一个给吐司抹黄油，另一个在抹过黄油的吐司上涂果酱。我们可以通过各个处理过程之间的BlockingQueue来运行这个吐司制作程序：

![748-2](../Images/image03740.jpeg)

![749-1](../Images/image03741.jpeg)

![750-1](../Images/image03742.jpeg)

Toast是一个使用enum值的优秀示例。注意，这个示例中没有任何显式的同步（即使用Lock对象或synchronized关键字的同步），因为同步由队列（其内部是同步的）和系统的设计隐式地管理了——每片Toast在任何时刻都只由一个任务在操作。因为队列的阻塞，使得处理过程将被自动地挂起和恢复。你可以看到由BlockingQueue产生的简化十分明显。在使用显式的wait()和notifyAll()时存在的类和类之间的耦合被消除了，因为每个类都只和它的BlockingQueue通信。

练习29：（8）修改ToastOMatic.java，使用两个单独的组装线来创建涂有花生黄油和果冻的吐司三明治（一个用于花生黄油，第二个用于果冻，然后把两条线合并）。