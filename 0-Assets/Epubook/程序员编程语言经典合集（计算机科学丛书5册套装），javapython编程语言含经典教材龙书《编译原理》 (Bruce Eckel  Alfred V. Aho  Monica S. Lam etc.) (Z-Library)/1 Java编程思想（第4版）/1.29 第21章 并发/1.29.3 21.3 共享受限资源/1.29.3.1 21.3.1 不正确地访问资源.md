### 21.3.1　不正确地访问资源

考虑下面的例子，其中一个任务产生偶数，而其他任务消费这些数字。这里，消费者任务的唯一工作就是检查偶数的有效性。

首先，我们定义EvenChecker，即消费者任务，因为它将在随后所有的示例中被复用。为了将EvenChecker与我们要试验的各种类型的生成器解耦，我们将创建一个名为IntGenerator的抽象类，它包含EvenChecker必须了解的必不可少的方法：即一个next()方法，和一个可以执行撤销的方法。这个类没有实现Generator接口，因为它必须产生一个int，而泛型不支持基本类型的参数：

![707-2](../Images/image03688.jpeg)

IntGenerator有一个cancel()方法，可以修改boolean类型的canceled标志的状态；还有一个isCanceled()方法，可以查看该对象是否已经被取消。因为canceled标志是boolean类型的，所以它是原子性的，即诸如赋值和返回值这样的简单操作在发生时没有中断的可能，因此你不会看到这个域处于在执行这些简单操作的过程中的中间状态。为了保证可视性，canceled标志还是volatile的。你将在本章稍后学习原子性和可视性。

任何IntGenerator都可以用下面的EvenChecker类来测试：

![708-1](../Images/image03689.jpeg)

注意，在本例中可以被撤销的类不是Runnable，而所有依赖于IntGenerator对象的EvenChecker任务将测试它，以查看它是否已经被撤销，正如你在run()中所见。通过这种方式，共享公共资源（IntGenerator）的任务可以观察该资源的终止信号。这可以消除所谓竞争条件，即两个或更多的任务竞争响应某个条件，因此产生冲突或不一致结果的情况。你必须仔细考虑并防范并发系统失败的所有可能途径，例如，一个任务不能依赖于另一个任务，因为任务关闭的顺序无法得到保证。这里，通过使任务依赖于非任务对象，我们可以消除潜在的竞争条件。

test()方法通过启动大量使用相同的IntGenerator的EvenChecker，设置并执行对任何类型的IntGenerator的测试。如果IntGenerator引发失败，那么test()将报告它并返回，否则，你必须按下Control-C来终止它。

EvenChecker任务总是读取和测试从与其相关的IntGenerator返回的值。注意，如果generator.isCanceled()为true，则run()将返回，这将告知EvenChecker.test()中的Executor该任务完成了。任何EvenChecker任务都可以在与其相关联的IntGenerator上调用cancel()，这将导致所有其他使用该IntGenerator的EvenChecker得体地关闭。在后面各节中，你将看到Java包含的用于线程终止的各种更通用的机制。

我们看到的第一个IntGenerator有一个可以产生一系列偶数值的next()方法：

![708-2](../Images/image03690.jpeg)

一个任务有可能在另一个任务执行第一个对currentEvenValue的递增操作之后，但是没有执行第二个操作之前，调用next()方法（即，代码中被注释为“Danger point here！”的地方）。这将使这个值处于“不恰当”的状态。为了证明这是可能发生的，EvenChecker.test()创建了一组EvenChecker对象，以连续地读取并输出同一个EvenGenerator，并测试检查每个数值是否都是偶数。如果不是，就会报告错误，而程序也将关闭。

这个程序最终将失败，因为各个EvenChecker任务在EvenGenerator处于“不恰当的”状态时，仍能够访问其中的信息。但是，根据你使用的特定的操作系统和其他实现细节，直到EvenCenerator完成多次循环之前，这个问题都不会被探测到。如果你希望更快地发现失败，可以尝试着将对yield()的调用放置到第一个和第二个递增操作之间。这只是并发程序的部分问题——如果失败的概率非常低，那么即使存在缺陷，它们也可能看起来是正确的。

有一点很重要，那就是要注意到递增程序自身也需要多个步骤，并且在递增过程中任务可能会被线程机制挂起——也就是说，在Java中，递增不是原子性的操作。因此，如果不保护任务，即使单一的递增也不是安全的。