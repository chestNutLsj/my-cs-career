### 21.3.4　原子类

Java SE5引入了诸如AtomicInteger、AtomicLong、AtomicReference等特殊的原子性变量类，它们提供下面形式的原子性条件更新操作：

![717-2](../Images/image03702.jpeg)

这些类被调整为可以使用在某些现代处理器上的可获得的，并且是在机器级别上的原子性，因此在使用它们时，通常不需要担心。对于常规编程来说，它们很少会派上用场，但是在涉及性能调优时，它们就大有用武之地了。例如，我们可以使用AtomicInteger来重写AtomicityTest.java：

![717-3](../Images/image03703.jpeg)

这里我们通过使用AtomicInteger而消除了synchronized关键字。因为这个程序不会失败，所以添加了一个Timer，以便在5秒钟之后自动地终止。

下面是用AtomicInteger重写的MutexEvenGenerator.java：

![718-2](../Images/image03704.jpeg)

所有其他形式的同步再次通过使用AtomicInteger得到了根除。

应该强调的是，Atomic类被设计用来构建java.util.concurrent中的类，因此只有在特殊情况下才在自己的代码中使用它们，即便使用了也需要确保不存在其他可能出现的问题。通常依赖于锁要更安全一些（要么是synchronized关键字，要么是显式的Lock对象）。

练习14：（4）创建一个程序，它可以生成许多Timer对象，这些对象在定时时间到达后将执行某个简单的任务。用这个程序来证明java.util.Timer可以扩展到很大的数目。