### 21.8.3　分发工作

下面的仿真示例将本章的许多概念都结合在了一起。考虑一个假想的用于汽车的机器人组装线，每辆Car都将分多个阶段构建，从创建底盘开始，紧跟着是安装发动机、车厢和轮子。

![777-2](../Images/image03777.jpeg)

![778-1](../Images/image03778.jpeg)

![779-1](../Images/image03779.jpeg)

![780-1](../Images/image03780.jpeg)

Car是经由CarQueue从一个地方传送到另一个地方的，CarQueue是一种LinkedBlockingQueue类型。ChassisBuilder创建了一个未加修饰的Car，并将它放到了一个CarQueue中。Assembler从一个CarQueue中取走Car，并雇请Robot对其加工。CyclicBarrier使Assembler等待，直至所有的Robot都完成，并且在那一时刻它会将Car放置到即将离开它的CarQueue中，然后被传送到下一个操作。最终的CarQueue的消费者是一个Reporter对象，它只是打印Car，以显示所有的任务都已经正确的完成了。

Robot是在池中管理的，当需要完成工作时，就会从池中雇请适当的Robot。在工作完成时，这个Robot会返回到池中。

在main()中创建了所有必需的对象，并初始化了各个任务，最后启动ChassisBuilder，从而启动整个过程（但是，由于LinkedBlockingQueue的行为，使得最先启动它也没有问题）。注意，这个程序遵循了本章描述的所有有关对象和任务生命周期的设计原则，因此关闭这个过程将是安全的。

你会注意到，Car将其所有方法都设置成了synchronized的。正如它所表现出来的那样，在本例中，这是多余的，因为在工厂的内部，Car是通过队列移动的，并且在任何时刻，只有一个任务能够在某辆车上工作。基本上，队列可以强制串行化地访问Car。但是这正是你可能会落入的陷阱——你可能会说“让我们尝试着通过不对Car类同步来进行优化，因为看起来Car在这里并不需要同步。”但是稍后，当这个系统连接到另一个需要Car被同步的系统时，它就会崩溃。

Brian Goetz的注释：

进行这样的声明会简单得多：“Car可能会被多个线程使用，因此我们需要以明显的方式使其成为线程安全的。”我把这种方式描绘为：在公园中，你会在陡峭的坡路上发现一些保护围栏，并且可能会发现标记声明：“不要倚靠围栏。”当然，这条规则的真实目的不是要阻止你借助围栏，而是防止你跌落悬崖。但是“不要倚靠围栏”与“不要跌落悬崖”相比，是一条遵循起来要容易得多的规则。

练习37：（2）修改CarBuilder.java，在汽车构建过程中添加一个阶段，即添加排气系统、车身和保险杠。与第二个阶段相同，假设这些处理可以由机器人同时执行。

练习38：（3）使用CarBuilder.java中的方式，对本章中给出的房屋构建过程建模。