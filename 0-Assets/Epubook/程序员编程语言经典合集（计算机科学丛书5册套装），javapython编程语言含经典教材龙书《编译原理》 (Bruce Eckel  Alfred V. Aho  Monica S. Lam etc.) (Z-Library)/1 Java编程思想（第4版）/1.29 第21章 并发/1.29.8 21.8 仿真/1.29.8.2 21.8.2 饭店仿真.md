### 21.8.2　饭店仿真

这个仿真添加了更多的仿真组件，例如Order和Plate，从而充实了本章前面描述的Restaurant.java示例，并且它重用了第19章中的menu类。它还引入了Java SE5的SynchronousQueue，这是一种没有内部容量的阻塞队列，因此每个put()都必须等待一个take()，反之亦然。这就好像是你在把一个对象交给某人——没有任何桌子可以放置这个对象，因此只有在这个人伸出手，准备好接收这个对象时，你才能工作。在本例中，SynchronousQueue表示设置在用餐者面前的某个位置，以加强在任何时刻只能上一道菜这个概念。

本例中剩下的类和功能都遵循Restaurant.java的结构，或者是对实际的饭店操作的相当直接的映射：

![774-1](../Images/image03773.jpeg)

![775-1](../Images/image03774.jpeg)

![776-1](../Images/image03775.jpeg)

![777-1](../Images/image03776.jpeg)

关于这个示例，需要观察的一项非常重要的事项，就是使用队列在任务间通信所带来的管理复杂度。这个单项技术通过反转控制极大地简化了并发编程的过程：任务没有直接地互相干涉，而是经由队列互相发送对象。接收任务将处理对象，将其当作一个消息来对待，而不是向它发送消息。如果只要可能就遵循这项技术，那么你构建出健壮的并发系统的可能性就会大大增加。

练习36：（10）修改RestaurantWithQueues.java，使得每个桌子都有一个OrderTicket对象。将order修改为orderTickes，并添加一个Table类，每个桌子上可以有多个Customer。