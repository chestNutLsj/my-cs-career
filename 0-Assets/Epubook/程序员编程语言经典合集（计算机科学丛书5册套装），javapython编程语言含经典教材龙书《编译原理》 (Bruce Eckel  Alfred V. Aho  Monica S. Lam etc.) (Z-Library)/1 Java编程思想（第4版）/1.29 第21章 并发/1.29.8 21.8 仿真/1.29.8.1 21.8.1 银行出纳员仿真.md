### 21.8.1　银行出纳员仿真

这个经典的仿真可以表示任何属于下面这种类型的情况：对象随机地出现，并且要求由数量有限的服务器提供随机数量的服务时间。通过构建仿真可以确定理想的服务器数量。

在本例中，每个银行顾客要求一定数量的服务时间，这是出纳员必须花费在顾客身上，以服务顾客需求的时间单位的数量。服务时间的数量对每个顾客来说都是不同的，并且是随机确定的。另外，你不知道在每个时间间隔内有多少顾客会到达，因此这也是随机确定的：

![770-2](../Images/image03769.jpeg)

![771-1](../Images/image03770.jpeg)

![772-1](../Images/image03771.jpeg)

![773-1](../Images/image03772.jpeg)

Customer对象非常简单，只包含一个final int域。因为这些对象从来都不发生变化，因此它们是只读对象，并且不需要同步或使用volatile。在这之上，每个Teller任务在任何时刻都只从输入队列中移除一个Customer，并且在这个Customer上工作直至完成，因此Customer在任何时刻都只由一个任务访问。

CustomerLine表示顾客在等待被某个Teller服务时所排成的单一的行。这只是一个ArrayBlockingQueue，它具有一个toString()方法，可以按照我们希望的形式打印结果。

CustomerGenerator附着在CustomerLine上，按照随机的时间间隔向这个队列中添加Customer。

Teller从CustomerLine中取走Customer，在任何时刻他都只能处理一个顾客，并且跟踪在这个特定的班次中有他服务的Customer的数量。当没有足够多的顾客时，他会被告知去执行doSomethingElse()，而当出现了许多顾客时，他会被告知去执行serveCustomerLine()。为了选择下一个出纳员，让其回到服务顾客的业务上，compareTo()方法将查看出纳员服务过的顾客数量，使得PriorityQueue可以自动地将工作量最小的出纳员推向前台。

TellerManager是各种活动的中心，它跟踪所有的出纳员以及等待服务的顾客。这个仿真中有一件有趣的事情，即它试图发现对于给定的顾客流，最优的出纳员数量是多少。你可以在adjustTellerNumber()中看到这一点，这是一个控制系统，它能够以稳定的方式添加或移除出纳员。所有的控制系统都具有稳定性问题，如果它们对变化反映过快，那么它们就是不稳定的，而如果它们反映过慢，则系统会迁移到它的某种极端情况。

练习35：（8）修改BankTellerSimulation.java，使它表示Web客户端，向具有固定数量的服务器发送请求。这么做的目标是要确定这个服务器组可以处理的负载大小。