### 21.2.8　后台线程

所谓后台（daemon）线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非后台线程结束时，程序也就终止了，同时会杀死进程中的所有后台线程。反过来说，只要有任何非后台线程还在运行，程序就不会终止。比如，执行main()的就是一个非后台线程。

![695-1](../Images/image03669.jpeg)

必须在线程启动之前调用setDaemon()方法，才能把它设置为后台线程。

一旦main()完成其工作，就没什么能阻止程序终止了，因为除了后台线程之外，已经没有线程在运行了。main()线程被设定为短暂睡眠，所以可以观察到所有后台线程启动后的结果。不这样的话，你就只能看见一些后台线程创建时得到的结果（试试调整sleep()休眠的时间，以观察这个行为）。

SimpleDaemons.java创建了显式的线程，以便可以设置它们的后台标志。通过编写定制的ThreadFactory可以定制由Executor创建的线程的属性（后台、优先级、名称）：

![696-1](../Images/image03670.jpeg)

这与普通的ThreadFactory的唯一差异就是它将后台状态全部设置为了true。你现在可以用一个新的DaemonThreadFactory作为参数传递给Executor.newCachedThreadPool()：

![696-2](../Images/image03671.jpeg)

每个静态的ExecutorService创建方法都被重载为接受一个ThreadFactory对象，而这个对象将被用来创建新的线程：

![696-3](../Images/image03672.jpeg)

可以通过调用isDaemon()方法来确定线程是否是一个后台线程。如果是一个后台线程，那么它创建的任何线程将被自动设置成后台线程，如下例所示：

![696-4](../Images/image03673.jpeg)

![697-1](../Images/image03674.jpeg)

Daemon线程被设置成了后台模式，然后派生出许多子线程，这些线程并没有被显式地设置为后台模式，不过它们的确是后台线程。接着，Daemon线程进入了无限循环，并在循环里调用yield()方法把控制权交给其他进程。

你应该意识到后台进程在不执行finally子句的情况下就会终止其run()方法：

![697-2](../Images/image03675.jpeg)

当你运行这个程序时，你将看到finally子句就不会执行，但是如果你注释掉对setDaemon()的调用，就会看到finally子句将会执行。

这种行为是正确的，即便你基于前面对finally给出的承诺，并不希望出现这种行为，但情况仍将如此。当最后一个非后台线程终止时，后台线程会“突然”终止。因此一旦main()退出，JVM就会立即关闭所有的后台进程，而不会有任何你希望出现的确认形式。因为你不能以优雅的方式来关闭后台线程，所以它们几乎不是一种好的思想。非后台的Executor通常是一种更好的方式，因为Executor控制的所有任务可以同时被关闭。正如你将要在本章稍后看到的，在这种情况下，关闭将以有序的方式执行。

练习7：（2）在Daemons.java中使用不同的休眠时间，并观察结果。

练习8：（1）把SimpleThread.java中的所有线程修改成后台线程，并验证一旦main()退出，程序立刻终止。

练习9：（3）修改SimplePriorities.java，使得定制的ThreadFactory可以设置线程的优先级。