### 21.2.9　编码的变体

到目前为止，在你所看到的示例中，任务类都实现了Runnable。在非常简单的情况下，你可能会希望使用直接从Thread继承这种可替换的方式，就像下面这样：

![698-2](../Images/image03676.jpeg)

你可以通过调用适当的Thread构造器为Thread对象赋予具体的名称，这个名称可以通过使用getName()从toString()中获得。

另一种可能会看到的惯用法是自管理的Runnable：

![699-2](../Images/image03677.jpeg)

这与从Thread继承并没有什么特别的差异，只是语法稍微晦涩一些。但是，实现接口使得你可以继承另一个不同的类，而从Thread继承将不行。

注意，start()是在构造器中调用的。这个示例相当简单，因此可能是安全的，但是你应该意识到，在构造器中启动线程可能会变得很有问题，因为另一个任务可能会在构造器结束之前开始执行，这意味着该任务能够访问处于不稳定状态的对象。这是优选Executor而不是显式地创建Thread对象的另一个原因。

有时通过使用内部类来将线程代码隐藏在类中将会很有用，就像下面这样：

![699-3](../Images/image03678.jpeg)

![700-1](../Images/image03679.jpeg)

![701-1](../Images/image03680.jpeg)

InnerThread1创建了一个扩展自Thread的匿名内部类，并且在构造器中创建了这个内部类的一个实例。如果内部类具有你在其他方法中需要访问的特殊能力（新方法），那这么做将会很有意义。但是，在大多数时候，创建线程的原因只是为了使用Thread的能力，因此不必创建匿名内部类。InnerThread2展示了可替换的方式：在构造器中创建一个匿名的Thread子类，并且将其向上转型为Thread引用t。如果类中的其他方法需要访问t，那它们可以通过Thread接口来实现，并且不需要了解该对象的确切类型。

该示例的第三个和第四个类重复了前面的两个类，但是它们使用的是Runnable接口而不是Thread类。

ThreadMethod类展示了在方法内部如何创建线程。当你准备好运行线程时，就可以调用这个方法，而在线程开始之后，该方法将返回。如果该线程只执行辅助操作，而不是该类的重要操作，那么这与在该类的构造器内部启动线程相比，可能是一种更加有用而适合的方式。

练习10：（4）按照ThreadMethod类修改练习5，使得runTask()方法将接受一个参数，表示要计算总和的斐波纳契数字的数量，并且，每次调用runTask()时，它将返回对submit()的调用所产生的Future。