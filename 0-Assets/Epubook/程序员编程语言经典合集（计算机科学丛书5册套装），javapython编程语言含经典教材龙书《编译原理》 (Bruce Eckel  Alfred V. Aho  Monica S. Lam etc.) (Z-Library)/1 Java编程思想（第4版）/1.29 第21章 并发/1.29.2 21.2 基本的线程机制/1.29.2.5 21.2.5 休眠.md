### 21.2.5　休眠

影响任务行为的一种简单方法是调用sleep()，这将使任务中止执行给定的时间。在LiftOff类中，要是把对yield()的调用换成是调用sleep()，将得到如下结果：

![692-2](../Images/image03666.jpeg)

对sleep()的调用可以抛出InterruptedException异常，并且你可以看到，它在run()中被捕获。因为异常不能跨线程传播回main()，所以你必须在本地处理所有在任务内部产生的异常。

Java SE5引入了更加显式的sleep()版本，作为TimeUnit类的一部分，就像上面示例所示的那样。这个方法允许你指定sleep()延迟的时间单元，因此可以提供更好的可阅读性。TimeUnit还可以被用来执行转换，就像稍后你会在本书中看到的那样。

你可能会注意到，这些任务是按照“完美的分布”顺序运行的，即从0到4，然后再回过头从0开始，当然这取决于你的平台。这是有意义的，因为在每个打印语句之后，每个任务都将要睡眠（即阻塞），这使得线程调度器可以切换到另一个线程，进而驱动另一个任务。但是，顺序行为依赖于底层的线程机制，这种机制在不同的操作系统之间是有差异的，因此，你不能依赖于它。如果你必须控制任务执行的顺序，那么最好的押宝就是使用同步控制（稍候描述），或者在某些情况下，压根不使用线程，但是要编写自己的协作例程，这些例程将会按照指定的顺序在互相之间传递控制权。

练习6：（2）创建一个任务，它将睡眠1至10秒之间的随机数量的时间，然后显示它的睡眠时间并退出。创建并运行一定数量的这种任务。