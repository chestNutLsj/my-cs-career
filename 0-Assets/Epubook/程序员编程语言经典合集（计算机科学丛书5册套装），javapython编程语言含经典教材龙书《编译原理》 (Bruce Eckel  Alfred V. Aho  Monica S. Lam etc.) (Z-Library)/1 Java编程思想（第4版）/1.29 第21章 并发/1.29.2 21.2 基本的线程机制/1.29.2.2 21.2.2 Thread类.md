### 21.2.2　Thread类

将Runnable对象转变为工作任务的传统方式是把它提交给一个Thread构造器，下面的示例展示了如何使用Thread来驱动LiftOff对象：

![688-2](../Images/image03660.jpeg)

Thread构造器只需要一个Runnable对象。调用Thread对象的start()方法为该线程执行必需的初始化操作，然后调用Runnable的run()方法，以便在这个新线程中启动该任务。尽管start()看起来是产生了一个对长期运行方法的调用，但是从输出中可以看到，start()迅速地返回了，因为Waiting for LiftoOff消息在倒计时完成之前就出现了。实际上，你产生的是对LiftOff.run()的方法调用，并且这个方法还没有完成，但是因为LiftOff.run()是由不同的线程执行的，因此你仍旧可以执行main()线程中的其他操作（这种能力并不局限于main()线程，任何线程都可以启动另一个线程）。因此，程序会同时运行两个方法，main()和LiftOff.run()是程序中与其他线程“同时”执行的代码。

你可以很容易地添加更多的线程去驱动更多的任务。下面，你可以看到所有任务彼此之间是如何互相呼应的[^5]：

![688-3](../Images/image03661.jpeg)

输出说明不同任务的执行在线程被换进换出时混在了一起。这种交换是由线程调度器自动控制的。如果在你的机器上有多个处理器，线程调度器将会在这些处理器之间默默地分发线程[^6]。

这个程序一次运行的结果可能与另一次运行的结果不同，因为线程调度机制是非确定性的。事实上，你可以看到，在某个版本的JDK与下个版本之间，这个简单程序的输出会产生巨大的差异。例如，较早的JDK不会频繁对时间切片，因此线程1可能会首先循环到尽头，然后线程2会经历其所有循环，等等。这实际上与调用一个例程去同时执行所有的循环一样，只是启动所有线程的代价要更加高昂。较晚的JDK看起来会产生更好的时间切片行为，因此每个线程看起来都会获得更加正规的服务。通常，Sun并为提及这些种类的JDK的行为变化，因此你不能依赖于任何线程行为的一致性。最好的方式是在编写使用线程的代码时，尽可能地保守。

当main()创建Thread对象时，它并没有捕获任何对这些对象的引用。在使用普通对象时，这对于垃圾回收来说是一场公平的游戏，但是在使用Thread时，情况就不同了。每个Thread都“注册”了它自己，因此确实有一个对它的引用，而且在它的任务退出其run()并死亡之前，垃圾回收器无法清除它。你可以从输出中看到，这些任务确实运行到了结束，因此，一个线程会创建一个单独的执行线程，在对start()的调用完成之后，它仍旧会继续存在。

练习1：（2）实现一个Runnable。在run()内部打印一个消息，然后调用yield()。重复这个操作三次，然后从run()中返回。在构造器中放置一条启动消息，并且放置一条在任务终止时的关闭消息。使用线程创建大量的这种任务并驱动它们。

练习2：（2）遵循generic/Fibonacci.java的形式，创建一个任务，它可以产生由n个斐波纳契数字组成的序列，其中n是通过任务的构造器而提供的。使用线程创建大量的这种任务并驱动它们。