### 21.7.4　PriorityBlockingQueue

这是一个很基础的优先级队列，它具有可阻塞的读取操作。下面是一个示例，其中在优先级队列中的对象是按照优先级顺序从队列中出现的任务。PrioritizedTask被赋予了一个优先级数字，以此来提供这种顺序：

![761-2](../Images/image03756.jpeg)

![762-1](../Images/image03757.jpeg)

![763-1](../Images/image03758.jpeg)

与前一个示例相同，PrioritizedTask对象的创建序列被记录在sequence List中，用于和实际的执行顺序比较。run()方法将休眠一小段随机的时间，然后打印对象信息，而EndSentinel提供了和前面相同的功能，要确保它是队列中最后一个对象。

PrioritizedTaskProducer和PrioritizedTaskComsumer通过PriorityBlockinQueue彼此连接。因为这种队列的阻塞特性提供了所有必需的同步，所以你应该注意到了，这里不需要任何显式的同步——不必考虑当你从这种队列中读取时，其中是否有元素，因为这个队列在没有元素时，将直接阻塞读取者。