### 12.12.4　把“被检查的异常”转换为“不检查的异常”

在编写你自己使用的简单程序时，从main()中抛出异常是很方便的，但这不是通用的方法。问题的实质是，当在一个普通方法里调用别的方法时，要考虑到“我不知道该这样处理这个异常，但是也不想把它‘吞’了，或者打印一些无用的消息”。JDK 1.4的异常链提供了一种新的思路来解决这个问题。可以直接把“被检查的异常”包装进RuntimeException里面，就像这样：

![313-1](../Images/image03048.jpeg)

如果想把“被检查的异常”这种功能“屏蔽”掉的话，这看上去像是一个好办法。不用“吞下”异常，也不必把它放到方法的异常说明里面，而异常链还能保证你不会丢失任何原始异常的信息。

这种技巧给了你一种选择，你可以不写try-catch子句和/或异常说明，直接忽略异常，让它自己沿着调用栈往上“冒泡”。同时，还可以用getCause()捕获并处理特定的异常，就像这样：

![313-2](../Images/image03049.jpeg)

![314-1](../Images/image03050.jpeg)

WrapCheckedException.throwRuntimeException()的代码可以生成不同类型的异常。这些异常被捕获并包装进了RuntimeException对象，所以它们成了这些运行时异常的“cause”了。

在TurnOffChecking里，可以不用try块就调用throwRuntimeException()，因为它没有抛出“被检查的异常”。但是，当你准备好去捕获异常的时候，还是可以用try块来捕获任何你想捕获的异常的。应该捕获try块肯定会抛出的异常，这里就是SomeOtherException。RuntimeException要放到最后去捕获。然后把getCause()的结果（也就是被包装的那个原始异常）抛出来。这样就把原先的那个异常给提取出来了，然后就可以用它们自己的catch子句进行处理。

本书余下部分将会在合适的时候使用这种“用RuntimeException来包装‘被检查的异常’”的技术。另一种解决方案是创建自己的RuntimeException的子类。在这种方式中，不必捕获它，但是希望得到它的其他代码都可以捕获它。

练习27：（1）修改练习3，将异常转变为RuntimeException。

练习28：（1）修改练习4，使客户的异常类继承自RuntimeException，并展示编译器允许你省略try语句块。

练习29：（1）修改StormyInning.java中所有的异常类型，使它们扩展RuntimeException，并展示这里不需要任何异常说明或try语句块。移除“//！”注释并展示这些方法不需要说明就可以编译。

练习30：（2）修改Human.java，使异常继承自RuntimeException修改main()，使其用TurnOffChecking.java类处理不同类型的异常。