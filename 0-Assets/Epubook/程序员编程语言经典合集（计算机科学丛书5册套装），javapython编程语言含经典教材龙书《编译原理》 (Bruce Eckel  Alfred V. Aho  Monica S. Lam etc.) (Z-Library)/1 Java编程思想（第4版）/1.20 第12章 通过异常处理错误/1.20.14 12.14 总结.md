## 12.14　总结

异常是Java程序设计不可分割的一部分，如果不了解如何使用它们，那你只能完成很有限的工作。正因为如此，本书专门在此介绍了异常——对于许多类库（例如提到过的I/O库），如果不处理异常，你就无法使用它们。

异常处理的优点之一就是它使得你可以在某处集中精力处理你要解决的问题，而在另一处处理你编写的这段代码中产生的错误。尽管异常通常被认为是一种工具，使得你可以在运行时报告错误并从错误中恢复，但是我一直怀疑到底有多少时候“恢复”真正得以实现了，或者能够得以实现。我认为这种情况少于10%，并且即便是这10%，也只是将栈展开到某个已知的稳定状态，而并没有实际执行任何种类的恢复性行为。无论这是否正确，我一直相信“报告”功能是异常的精髓所在。Java坚定地强调将所有的错误都以异常形式报告的这一事实，正是它远远超过诸如C++这类语言的长处之一，因为在C++这类语言中，需要以大量不同的方式来报告错误，或者根本就没有提供错误报告功能。一致的错误报告系统意味着，你再也不必对所写的每一段代码，都质问自己“错误是否正在成为漏网之鱼？”（只要你没有“吞咽”异常，这是关键所在！）。

就像你将要在后续章节中看到的，通过将这个问题甩给其他代码——即使你是通过抛出RuntimeException来实现这一点的——你在设计和实现时，便可以专注于更加有趣和富有挑战性的问题了。

所选习题的答案都可以在名为The Thinking in Java Annotated Solution Guide的电子文档中找到，读者可以从https://www.mindviewllc.com处购买此文档。

---

[^1]: 的返回值就是这样。

[^2]: Jim Gray，www.acmqueue.org的一次访谈中提到，由于他的团队在事务方面的杰出贡献而成为图灵奖得主。

[^3]: 这与大多数语言的机制相同，包括C++、C#、Python和D等语言。

[^4]: C++中的异常处理没有finally子句，它依赖析构函数来达到清理的目的。

[^5]: 析构函数是“当对象不再被使用的时候”会被调用的函数。你总能确切地知道析构函数被调用的时间和地点。C++能自动调用析构函数，而C#（它更像Java）里面会有自动进行清理的机制。

[^6]: ISO C++中加上了类似的约束，要求派生类的方法所抛出的异常要与基类方法相同，或者是基类方法抛出的异常的派生类。这是C++真正能够在编译时对异常说明进行检查的唯一情况。

[^7]: Exception Handling in CLU（Barbara Liskov和Alan Snyder：CLU的异常处理），IEEE Transactions on Software Engineering，Vol. SE-5，No. 6，1979年11月。这篇论文在网上是找不到的，只有印刷版本，所以你得去图书馆找。

[^8]: http://discuss.develop.com/archives/wa.exe?A2=ind0011A＆L=DOTNET＆P=R32820。

[^9]: http://discuss.develop.com/archives/wa.exe?A2=ind0011A＆L=DOTNET＆P=R32820。

[^10]: Bjarne Stroustrup，The C++ Programming Language，3rd edition（C++程序设计语言，第3版），Addison-Wesley 1997，第376页。

[^11]: 间接经验来自于与很多资深Smalltalk程序员的谈话；直接经验则得自于使用Python（www.Python.org）。

[^12]: （Kees Koster，CDL语言的设计者，引自Eiffel语言的设计者Bertrand Meyer。）http://www.elj.com/elj/v1/n1/bm/right/。