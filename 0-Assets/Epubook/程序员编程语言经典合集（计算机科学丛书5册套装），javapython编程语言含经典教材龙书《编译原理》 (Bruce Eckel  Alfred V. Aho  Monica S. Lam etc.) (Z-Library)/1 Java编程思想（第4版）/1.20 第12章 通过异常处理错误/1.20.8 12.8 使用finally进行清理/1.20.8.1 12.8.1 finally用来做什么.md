### 12.8.1　finally用来做什么

对于没有垃圾回收和析构函数自动调用机制[^5]的语言来说，finally非常重要。它能使程序员保证：无论try块里发生了什么，内存总能得到释放。但Java有垃圾回收机制，所以内存释放不再是问题。而且，Java也没有析构函数可供调用。那么，Java在什么情况下才能用到finally呢？

当要把除内存之外的资源恢复到它们的初始状态时，就要用到finally子句。这种需要清理的资源包括：已经打开的文件或网络连接，在屏幕上画的图形，甚至可以是外部世界的某个开关，如下面例子所示：

![298-3](../Images/image03031.jpeg)

![299-1](../Images/image03032.jpeg)

程序的目的是要确保main()结束的时候开关必须是关闭的，所以在每个try块和异常处理程序的末尾都加入了对sw.off()方法的调用。但也可能有这种情况：异常被抛出，但没被处理程序捕获，这时sw.off()就得不到调用。但是有了finally，只要把try块中的清理代码移放在一处即可：

![299-2](../Images/image03033.jpeg)

这里sw.off()被移到一处，并且保证在任何情况下都能得到执行。

甚至在异常没有被当前的异常处理程序捕获的情况下，异常处理机制也会在跳到更高一层的异常处理程序之前，执行finally子句：

![300-1](../Images/image03034.jpeg)

当涉及break和continue语句的时候，finally子句也会得到执行。请注意，如果把finally子句和带标签的break及continue配合使用，在Java里就没必要使用goto语句了。

练习13：（2）修改练习9，加一个finally子句。验证一下，即便是抛出NullPointerException异常，finally子句也会得到执行。

练习14：（2）试说明，在OnOffSwitch.java的try块内部抛出RuntimeException，程序可能会出现错误。

练习15：（2）试说明，在WithFinally.java的try块内部抛出RuntimeException，程序不会出现错误。