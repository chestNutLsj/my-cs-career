### 12.6.3　异常链

常常会想要在捕获一个异常后抛出另一个异常，并且希望把原始异常的信息保存下来，这被称为异常链。在JDK 1.4以前，程序员必须自己编写代码来保存原始异常的信息。现在所有Throwable的子类在构造器中都可以接受一个cause（因由）对象作为参数。这个cause就用来表示原始异常，这样通过把原始异常传递给新的异常，使得即使在当前位置创建并抛出了新的异常，也能通过这个异常链追踪到异常最初发生的位置。

有趣的是，在Throwable的子类中，只有三种基本的异常类提供了带cause参数的构造器。它们是Error（用于Java虚拟机报告系统错误）、Exception以及RuntimeException。如果要把其他类型的异常链接起来，应该使用initCause()方法而不是构造器。

下面的例子能让你在运行时动态地向DynamicFields对象添加字段：

![293-2](../Images/image03023.jpeg)

![294-1](../Images/image03024.jpeg)

![295-1](../Images/image03025.jpeg)

每个DynamicFields对象都含有一个数组，其元素是“成对的对象”。第一个对象表示字段标识符（一个字符串），第二个表示字段值，值的类型可以是除基本类型外的任意类型。当创建对象的时候，要合理估计一下需要多少字段。当调用setField()方法的时候，它将试图通过标识修改已有字段值，否则就建一个新的字段，并把值放入。如果空间不够了，将建立一个更长的数组，并把原来数组的元素复制进去。如果你试图为字段设置一个空值，将抛出一个DynamicFieldsException异常，它是通过使用initCause()方法把NullPointerException对象插入而建立的。

至于返回值，setField()将用getField()方法把此位置的旧值取出，这个操作可能会抛出NoSuchFieldException异常。如果客户端程序员调用了getField()方法，那么他就有责任处理这个可能抛出的NoSuchFieldException异常，但如果异常是从setField()方法里抛出的，这种情况将被视为编程错误，所以就使用接受cause参数的构造器把NoSuchFieldException异常转换为RuntimeException异常。

你会注意到，toString()方法使用了一个StringBuilder来创建其结果。在第13章中你将会了解到更多的关于StringBuilder的知识，但是只要你编写设计循环的toString()方法，通常都会想使用它，就像本例一样。

练习10：（2）为一个类定义两个方法：f()和g()。在g()里，抛出一个自定义的新异常。在f()里，调用g()，捕获它抛出的异常，并且在catch子句里抛出另一个异常（自定义的第二种异常）。在main()里测试代码。

练习11：（1）重复上一个练习，但是在catch子句里把g()要抛出的异常包装成一个Runtime Exception。