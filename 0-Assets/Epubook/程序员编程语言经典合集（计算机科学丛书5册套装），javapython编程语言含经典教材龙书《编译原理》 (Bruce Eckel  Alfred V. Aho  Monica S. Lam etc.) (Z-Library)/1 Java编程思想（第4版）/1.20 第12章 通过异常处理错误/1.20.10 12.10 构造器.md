## 12.10　构造器

有一点很重要，即你要时刻询问自己“如果异常发生了，所有东西能被正确的清理吗？”尽管大多数情况下是非常安全的，但涉及构造器时，问题就出现了。构造器会把对象设置成安全的初始状态，但还会有别的动作，比如打开一个文件，这样的动作只有在对象使用完毕并且用户调用了特殊的清理方法之后才能得以清理。如果在构造器内抛出了异常，这些清理行为也许就不能正常工作了。这意味着在编写构造器时要格外细心。

读者也许会认为使用finally就可以解决问题。但问题并非如此简单，因为finally会每次都执行清理代码。如果构造器在其执行过程中半途而废，也许该对象的某些部分还没有被成功创建，而这些部分在finally子句中却是要被清理的。

在下面的例子中，建立了一个InputFile类，它能打开一个文件并且每次读取其中的一行。这里使用了Java标准输入/输出库中的FileReader和BufferedReader类（将在第18章讨论），这些类的基本用法很简单，读者应该很容易明白：

![305-1](../Images/image03041.jpeg)

InputFile的构造器接受字符串作为参数，该字符串表示所要打开的文件名。在try块中，会使用此文件名建立了FileReader对象。FileReader对象本身用处并不大，但可以用它来建立BufferedReader对象。注意，使用InputFile的好处就能是把两步操作合而为一。

如果FileReader的构造器失败了，将抛出FileNotFoundException异常。对于这个异常，并不需要关闭文件，因为这个文件还没有被打开。而任何其他捕获异常的catch子句必须关闭文件，因为在它们捕获到异常之时，文件已经打开了（当然，如果还有其他方法能抛出FileNotFoundException，这个方法就显得有些投机取巧了。这时，通常必须把这些方法分别放到各自的try块里）。close()方法也可能会抛出异常，所以尽管它已经在另一个Catch子句块里了，还是要再用一层try-catch——对Java编译器而言，这只不过是又多了一对花括号。在本地做完处理之后，异常被重新抛出，对于构造器而言这么做是很合适的，因为你总不希望去误导调用方，让他认为“这个对象已经创建完毕，可以使用了”。

在本例中，由于finally会在每次完成构造器之后都执行一遍，因此它实在不该是调用close()关闭文件的地方。我们希望文件在InputFile对象的整个生命周期内都处于打开状态。

getLine()方法会返回表示文件下一行内容的字符串。它调用了能抛出异常的readLine()，但是这个异常已经在方法内得到处理，因此getLine()不会抛出任何异常。在设计异常时有一个问题：应该把异常全部放在这一层处理；还是先处理一部分，然后再向上层抛出相同的（或新的）异常；又或者是不做任何处理直接向上层抛出。如果用法恰当的话，直接向上层抛出的确能简化编程。在这里，getLine()方法将异常转换为RuntimeException，表示一个编程错误。

用户在不再需要InputFile对象时，就必须调用dispose()方法，这将释放BufferedReader和/或FileReader对象所占用的系统资源（比如文件句柄），在使用完InputFile对象之前是不会调用它的。可能你会考虑把上述功能放到finalize()里面，但我在第5章讲过，你不知道finalize()会不会被调用（即使能确定它将被调用，也不知道在什么时候调用）。这也是Java的缺陷：除了内存的清理之外，所有的清理都不会自动发生。所以必须告诉客户端程序员，这是他们的责任。

对于在构造阶段可能会抛出异常，并且要求清理的类，最安全的使用方式是使用嵌套的try子句：

![306-1](../Images/image03042.jpeg)

请仔细观察这里的逻辑：对InputFile对象的构造在其自己的try语句块中有效，如果构造失败，将进入外部的catch子句，而dispose()方法不会被调用。但是，如果构造成功，我们肯定想确保对象能够被清理，因此在构造之后立即创建了一个新的try语句块。执行清理的finally与内部的try语句块相关联。在这种方式中，finally子句在构造失败时是不会执行的，而在构成成功时将总是执行。

这种通用的清理惯用法在构造器不抛出任何异常时也应该运用，其基本规则是：在创建需要清理的对象之后，立即进入一个try-finally语句块：

![307-1](../Images/image03043.jpeg)

在main()中，Section 1相当简单：遵循了在可去除对象之后紧跟try-finally的原则。如果对象构造不能失败，就不需要任何catch。在Section 2中，为了构造和清理，可以看到具有不能失败的构造器的对象可以群组在一起。

Section 3展示了如何处理那些具有可以失败的构造器，且需要清理的对象。为了正确处理这种情况，事情变得很棘手，因为对于每一个构造，都必须包含在其自己的try-finally语句块中，并且每一个对象构造必须都跟随一个try-finally语句块以确保清理。

本例中的异常处理的棘手程度，对于应该创建不能失败的构造器是一个有力的论据，尽管这么做并非总是可行。

注意，如果dispose()可以抛出异常，那么你可能需要额外的try语句块。基本上，你应该仔细考虑所有的可能性，并确保正确处理每一种情况。

练习21：（2）试证明，派生类的构造器不能捕获它的基类构造器所抛出的异常。

练习22：（2）创建一个名为FailingConstructor.java的类，它具有一个可能会在构造过程中失败并且会抛出一个异常的构造器。在main()中，编写能够确保不出现故障的代码。

练习23：（4）在前一个练习中添加一个dispose()方法。修改FailingConstructor，使其构造器可以将那些可去除对象之一当作一个成员对象创建，然后该构造器可能会抛出一个异常，之后它将创建第二个可去除成员对象。编写能够确保不出现故障的代码，并在main()中验证所有可能的故障情形都被覆盖了。

练习24：（2）在FailingConstructor类中添加一个dispose()方法，并编写代码正确使用这个类。