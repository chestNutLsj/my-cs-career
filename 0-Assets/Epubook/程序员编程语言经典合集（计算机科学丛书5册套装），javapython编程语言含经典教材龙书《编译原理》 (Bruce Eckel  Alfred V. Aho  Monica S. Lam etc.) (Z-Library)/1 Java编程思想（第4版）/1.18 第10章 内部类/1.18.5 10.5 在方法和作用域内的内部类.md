## 10.5　在方法和作用域内的内部类

到目前为止，读者所看到的只是内部类的典型用途。通常，如果所读、写的代码包含了内部类，那么它们都是“平凡的”内部类，简单并且容易理解。然而，内部类的语法覆盖了大量其他的更加难以理解的技术。例如，可以在一个方法里面或者在任意的作用域内定义内部类。这么做有两个理由：

1）如前所示，你实现了某类型的接口，于是可以创建并返回对其的引用。

2）你要解决一个复杂的问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的。

在后面的例子中，先前的代码将被修改，以用来实现：

1）一个定义在方法中的类。

2）一个定义在作用域内的类，此作用域在方法的内部。

3）一个实现了接口的匿名类。

4）一个匿名类，它扩展了有非默认构造器的类。

5）一个匿名类，它执行字段初始化。

6）一个匿名类，它通过实例初始化实现构造（匿名类不可能有构造器）。

第一个例子展示了在方法的作用域内（而不是在其他类的作用域内）创建一个完整的类。这被称作局部内部类：

![228-2](../Images/image02924.jpeg)

PDestination类是destination()方法的一部分，而不是Parcel5的一部分。所以，在destination()之外不能访问PDestination。注意出现在return语句中的向上转型——返回的是Destination的引用，它是PDestination的基类。当然，在destination()中定义了内部类PDestination，并不意味着一旦dest()方法执行完毕，PDestination就不可用了。

你可以在同一个子目录下的任意类中对某个内部类使用类标识符PDestination，这并不会有命名冲突。

下面的例子展示了如何在任意的作用域内嵌入一个内部类：

![229-2](../Images/image02925.jpeg)

TrackingSlip类被嵌入在if语句的作用域内，这并不是说该类的创建是有条件的，它其实与别的类一起编译过了。然而，在定义TrackingSlip的作用域之外，它是不可用的；除此之外，它与普通的类一样。

练习9：（1）创建一个至少有一个方法的接口。在某个方法内定义一个内部类以实现此接口，这个方法返回对此接口的引用。

练习10：（1）重复前一个练习，但将内部类定义在某个方法的一个作用域内。

练习11：（2）创建一个private内部类，让它实现一个public接口。写一个方法，它返回一个指向此private内部类的实例的引用，并将此引用向上转型为该接口类型。通过尝试向下转型，说明此内部类被完全隐藏了。