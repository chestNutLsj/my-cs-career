## 10.6　匿名内部类

下面的例子看起来有点奇怪：

![230-1](../Images/image02926.jpeg)

contents()方法将返回值的生成与表示这个返回值的类的定义结合在一起！另外，这个类是匿名的，它没有名字。更糟的是，看起来似乎是你正要创建一个Contents对象。但是然后（在到达语句结束的分号之前）你却说：“等一等，我想在这里插入一个类的定义。”

这种奇怪的语法指的是：“创建一个继承自Contents的匿名类的对象。”通过new表达式返回的引用被自动向上转型为对Contents的引用。上述匿名内部类的语法是下述形式的简化形式：

![230-2](../Images/image02927.jpeg)

在这个匿名内部类中，使用了默认的构造器来生成Contents。下面的代码展示的是，如果你的基类需要一个有参数的构造器，应该怎么办：

![230-3](../Images/image02928.jpeg)

只需简单地传递合适的参数给基类的构造器即可，这里是将x传进new Wrapping（x）。尽管Wrapping只是一个具有具体实现的普通类，但它还是被其导出类当作公共“接口”来使用：

![230-4](../Images/image02929.jpeg)

你会注意到，Wrapping拥有一个要求传递一个参数的构造器，这使得事情变得更加有趣了。

在匿名内部类末尾的分号，并不是用来标记此内部类结束的。实际上，它标记的是表达式的结束，只不过这个表达式正巧包含了匿名内部类罢了。因此，这与别的地方使用的分号是一致的。

在匿名类中定义字段时，还能够对其执行初始化操作：

![231-2](../Images/image02930.jpeg)

如果定义一个匿名内部类，并且希望它使用一个在其外部定义的对象，那么编译器会要求其参数引用是final的，就像你在destination()的参数中看到的那样。如果你忘记了，将会得到一个编译时错误消息。

如果只是简单地给一个字段赋值，那么此例中的方法是很好的。但是，如果想做一些类似构造器的行为，该怎么办呢？在匿名类中不可能有命名构造器（因为它根本没名字！），但通过实例初始化，就能够达到为匿名内部类创建一个构造器的效果，就像这样：

![231-3](../Images/image02931.jpeg)

在此例中，不要求变量i一定是final的。因为i被传递给匿名类的基类的构造器，它并不会在匿名类内部被直接使用。

下例是带实例初始化的“parcel”形式。注意destination()的参数必须是final的，因为它们是在匿名类内部使用的。

![232-2](../Images/image02932.jpeg)

在实例初始化操作的内部，可以看到有一段代码，它们不能作为字段初始化动作的一部分来执行（就是if语句）。所以对于匿名类而言，实例初始化的实际效果就是构造器。当然它受到了限制——你不能重载实例初始化方法，所以你仅有一个这样的构造器。

匿名内部类与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但是不能两者兼备。而且如果是实现接口，也只能实现一个接口。

练习12：（1）重复练习7，这次使用匿名内部类。

练习13：（1）重复练习9，这次使用匿名内部类。

练习14：（1）修改interfaces/HorrorShow.java，用匿名类实现DangerousMonster和Vampire。

练习15：（2）创建一个类，它有非默认的构造器（即需要参数的构造器），并且没有默认构造器（没有无参数的构造器）。创建第二个类，它包含一个方法，能够返回对第一个类的对象的引用。通过写一个继承自第一个类的匿名内部类，来创建一个返回对象。