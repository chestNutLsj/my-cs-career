### 10.8.2　内部类与控制框架

在将要介绍的控制框架（control framework）中，可以看到更多使用内部类的具体例子。

应用程序框架（application framework）就是被设计用以解决某类特定问题的一个类或一组类。要运用某个应用程序框架，通常是继承一个或多个类，并覆盖某些方法。在覆盖后的方法中，编写代码定制应用程序框架提供的通用解决方案，以解决你的特定问题（这是设计模式中模板方法的一个例子（参考www.MindVeiw.net上的《Thinking in Patterns（with Java）》）。模板方法包含算法的基本结构，并且会调用一个或多个可覆盖的方法，以完成算法的动作。设计模式总是将变化的事物与保持不变的事物分离开，在这个模式中，模板方法是保持不变的事物，而可覆盖的方法就是变化的事物。

控制框架是一类特殊的应用程序框架，它用来解决响应事件的需求。主要用来响应事件的系统被称作事件驱动系统。应用程序设计中常见的问题之一是图形用户接口（GUI），它几乎完全是事件驱动的系统。在第22章将会看到，Java Swing库就是一个控制框架，它优雅地解决了GUI的问题，并使用了大量的内部类。

要理解内部类是如何允许简单的创建过程以及如何使用控制框架的，请考虑这样一个控制框架，它的工作就是在事件“就绪”的时候执行事件。虽然“就绪”可以指任何事，但在本例中是指基于时间触发的事件。接下来的问题就是，对于要控制什么，控制框架并不包含任何具体的信息。那些信息是在实现算法的action()部分时，通过继承来提供的。

首先，接口描述了要控制的事件。因为其默认的行为是基于时间去执行控制，所以使用抽象类代替实际的接口。下面的例子包含了某些实现：

![241-1](../Images/image02945.jpeg)

当希望运行Event并随后调用start()时，那么构造器就会捕获（从对象创建的时刻开始的）时间，此时间是这样得来的：start()获取当前时间，然后加上一个延迟时间，这样生成触发事件的时间。start()是一个独立的方法，而没有包含在构造器内，因为这样就可以在事件运行以后重新启动计时器，也就是能够重复使用Event对象。例如，如果想要重复一个事件，只需简单地在action()中调用start()方法。

ready()告诉你何时可以运行action()方法了。当然，可以在导出类中覆盖ready()方法，使得Event能够基于时间以外的其他因素而触发。

下面的文件包含了一个用来管理并触发事件的实际控制框架。Event对象被保存在List<Event>类型（读作“Event的列表”）的容器对象中，容器会在第11章中详细介绍。目前读者只需要知道add()方法用来将一个Object添加到List的尾端，size()方法用来得到List中元素的个数，foreach语法用来连续获联List中的Event，remove()方法用来从List中移除指定的Event。

![241-2](../Images/image02946.jpeg)

run()方法循环遍历eventList，寻找就绪的（ready()）、要运行的Event对象。对找到的每一个就绪的（ready()）事件，使用对象的toString()打印其信息，调用其action()方法，然后从队列中移除此Event。

注意，在目前的设计中你并不知道Event到底做了什么。这正是此设计的关键所在，“使变化的事物与不变的事物相互分离”。用我的话说，“变化向量”就是各种不同的Event对象所具有的不同行为，而你通过创建不同的Event子类来表现不同的行为。

这正是内部类要做的事情，内部类允许：

1）控制框架的完整实现是由单个的类创建的，从而使得实现的细节被封装了起来。内部类用来表示解决问题所必需的各种不同的action()。

2）内部类能够很容易地访问外围类的任意成员，所以可以避免这种实现变得笨拙。如果没有这种能力，代码将变得令人讨厌，以至于你肯定会选择别的方法。

考虑此控制框架的一个特定实现，如控制温室的运作[^4]中编写控制代码。

作为典型的应用程序框架，GreenhouseControls类继承自Controller：

![242-1](../Images/image02947.jpeg)

![243-1](../Images/image02948.jpeg)

注意，light、water和thermostat都属于外围类GreenhouseControls，而这些内部类能够自由地访问那些字段，无需限定条件或特殊许可。而且，action()方法通常都涉及对某种硬件的控制。

大多数Event类看起来都很相似，但是Bell和Restart则比较特别。Bell控制响铃，然后在事件列表中增加一个Bell对象，于是过一会儿它可以再次响铃。读者可能注意到了内部类是多么像多重继承：Bell和Restart有Event的所有方法，并且似乎也拥有外围类GreenhouseContrlos的所有方法。

一个由Event对象组成的数组被递交给Restart，该数组要加到控制器上。由于Restart()也是一个Event对象，所以同样可以将Restart对象添加到Restart.action()中，以使系统能够有规律地重新启动自己。

下面的类通过创建一个GreenhouseControls对象，并添加各种不同的Event对象来配置该系统。这是命令设计模式的一个例子在eventList中的每一个被封装成对象的请求：

![244-2](../Images/image02949.jpeg)

这个类的作用是初始化系统，所以它添加了所有相应的事件。Restart事件反复运行，而且它每次都会将eventList加载到GreenhouseControls对象中。如果提供了命令行参数，系统会以它作为毫秒数，决定什么时候终止程序（这是测试程序时使用的）。当然，更灵活的方法是避免对事件进行硬编码，取而代之的是从文件中读取需要的事件（第12章的练习会要求读者照此方法修改这个例子）。

这个例子应该使读者更了解内部类的价值了，特别是在控制框架中使用内部类的时候。在第18章中，读者将看到内部类如何优雅地描述图形用户界面的行为。到那时，读者应该就完全信服内部类的价值了。

练习24：（2）在GreenhouseControls.java中增加一个Event内部类，用以打开、关闭风扇。配置GreenhouseController.java以使用这些新的Event对象。

练习25：（3）在GreenhouseControls.java中继承GreenhouseControls，增加Event内部类，用以开启、关闭喷水机。写一个新版的GreenhouseController.java以使用这些新的Event对象。