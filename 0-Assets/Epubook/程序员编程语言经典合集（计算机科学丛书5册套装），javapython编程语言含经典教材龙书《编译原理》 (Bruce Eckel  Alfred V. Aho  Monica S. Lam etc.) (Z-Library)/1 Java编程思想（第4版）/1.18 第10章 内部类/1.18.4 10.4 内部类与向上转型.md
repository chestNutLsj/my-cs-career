## 10.4　内部类与向上转型

当将内部类向上转型为其基类，尤其是转型为一个接口的时候，内部类就有了用武之地。（从实现了某个接口的对象，得到对此接口的引用，与向上转型为这个对象的基类，实质上效果是一样的。）这是因为此内部类——某个接口的实现——能够完全不可见，并且不可用。所得到的只是指向基类或接口的引用，所以能够很方便地隐藏实现细节。

我们可以创建前一个示例的接口：

![227-2](../Images/image02922.jpeg)

现在Contents和Destination表示客户端程序员可用的接口。（记住，接口的所有成员自动被设置为public的。）

当取得了一个指向基类或接口的引用时，甚至可能无法找出它确切的类型，看下面的例子：

![227-3](../Images/image02923.jpeg)

Parcel4中增加了一些新东西：内部类PContents是private，所以除了Parcel4，没有人能访问它。PDestination是protected，所以只有Parcel4及其子类、还有与Parcel4同一个包中的类（因为protected也给予了包访问权）能访问PDestination，其他类都不能访问PDestination。这意味着，如果客户端程序员想了解或访问这些成员，那是要受到限制的。实际上，甚至不能向下转型成private内部类（或protected内部类，除非是继承自它的子类），因为不能访问其名字，就像在TestParcel类中看到的那样。于是，private内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全隐藏了实现的细节。此外，从客户端程序员的角度来看，由于不能访问任何新增加的、原本不属于公共接口的方法，所以扩展接口是没有价值的。这也给Java编译器提供了生成更高效代码的机会。

练习6：（2）在第一个包中创建一个至少有一个方法的接口。然后在第二个包内创建一个类，在其中增加一个protected的内部类以实现那个接口。在第三个包中，继承这个类，并在一个方法中返回该protected内部类的对象，在返回的时候向上转型为第一个包中的接口的类型。

练习7：（2）创建一个含有private域和private方法的类。创建一个内部类，它有一个方法可用来修改外围类的域，并调用外围类的方法。在外围类的另一方法中，创建此内部类的对象，并且调用它的方法，然后说明对外围类对象的影响。

练习8：（2）确定外部类是否可以访问其内部类的private元素。