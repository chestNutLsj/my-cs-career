## 3.17　操作符小结

下面这个例子向大家展示了哪些基本数据类型能进行哪些特定的运算。基本上这是同一个不断重复的程序，只是每次使用了不同的基本数据类型。文件编译时不会报错，因为那些会导致编译失败的行已用//！注释掉了。

![089-2](../Images/image02685.jpeg)

![090-1](../Images/image02686.jpeg)

![091-1](../Images/image02687.jpeg)

![092-1](../Images/image02688.jpeg)

![093-1](../Images/image02689.jpeg)

![094-1](../Images/image02690.jpeg)

![095-1](../Images/image02691.jpeg)

注意，能够对布尔型值进行的运算非常有限。我们只能赋予它true和false值，并测试它为真还是为假，而不能将布尔值相加，或对布尔值进行其他任何运算。

在char、byte和short中，我们可看到使用算术操作符中数据类型提升的效果。对这些类型的任何一个进行算术运算，都会获得一个int结果，必须将其显式地类型转换回原来的类型（窄化转换可能会造成信息的丢失），以将值赋给原本的类型。但对于int值，却不必进行类型转化，因为所有数据都已经属于int类型。但不要放松警惕，认为一切事情都是安全的，如果对两个足够大的int值执行乘法运算，结果就会溢出。下面这个例子向大家展示了这一点：

![096-1](../Images/image02692.jpeg)

你不会从编译器那里收到出错或警告信息，运行时也不会出现异常。这说明Java虽然是好东西，但也没有那么好！

对于char、byte或者short，复合赋值并不需要类型转换。尽管它们执行类型提升，但也会获得与直接算术运算相同的结果。而在另一方面，省略类型转换可使代码更加简练。

可以看到，除boolean以外，任何一种基本类型都可通过类型转换变为其他基本类型。再一次提醒读者，当类型转换成一种较小的类型时，必须留意“窄化转换”的结果；否则会在类型转化过程中不知不觉地丢失了信息。

练习14：（3）编写一个接收两个字符串参数的方法，用各种布尔值的比较关系来比较这两个字符串，然后把结果打印出来。做==和！=比较的同时，用equals()作测试。在main()里面用几个不同的字符串对象调用这个方法。