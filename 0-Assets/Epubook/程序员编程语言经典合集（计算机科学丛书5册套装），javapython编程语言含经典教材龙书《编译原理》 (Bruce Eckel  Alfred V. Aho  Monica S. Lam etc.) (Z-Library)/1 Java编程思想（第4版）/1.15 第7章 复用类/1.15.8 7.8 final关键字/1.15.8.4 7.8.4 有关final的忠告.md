### 7.8.4　有关final的忠告

在设计类时，将方法指明是final的，应该说是明智的。你可能会觉得，没人会想要覆盖你的方法。有时这是对的。

但请留意你所作的假设。要预见类是如何被复用的一般是很困难的，特别是对于一个通用类而言更是如此。如果将一个方法指定为final，可能会妨碍其他程序员在项目中通过继承来复用你的类，而这只是因为你没有想到它会以那种方式被运用。

Java标准程序库就是一个很好的例子。特别是Java 1.0/1.1中Vector类被广泛地运用，而且从效率考虑（这近乎是一个幻想），如果所有的方法均未被指定为final的话，它可能会更加有用。很容易想像到，人们可能会想要继承并覆盖如此基础而有用的类，但是设计者却认为这样做不太合适。这里有两个令人意外的原因。第一，Stack继承自Vector，就是说Stack是个Vector，这从逻辑的观点看是不正确的。尽管如此，Java的设计者们自己仍旧继承了Vector。在以这种方式创建Stack时，他们应该意识到final方法显得过于严苛了。

第二，Vector的许多最重要的方法-如addElement()和elementAt()是同步的。正如在第21章中将要看到的那样，这将导致很大的执行开销，可能会抹煞final所带来的好处。这种情况增强了人们关于程序员无法正确猜测优化应当发生于何处的观点。如此蹩脚的设计，却要置于我们每个人都得使用的标准程序库中，这是很糟糕的（幸运的是，现代Java的容器库用ArrayList替代了Vector。ArrayList的行为要合理得多。遗憾的是仍然存在用旧容器库编写新程序代码的情况）。

留心一下Hashtable，这个例子同样有趣，它也是一个重要的Java1.0/1.1标准库类，而且不含任何final方法。如本书其他地方所提到的，某些类明显是由一些互不相关的人设计的（读者会发现，名为Hashtable的方法相对于Vector中的方法要简洁得多，这又是一个证据）。对于类库的使用者来说，这又是一个本不该如此轻率的事物。这种不规则的情况只能使用户付出更多的努力。这是对粗糙的设计和代码的又一讽刺（请注意，现代Java的容器库用HashMap替代了Hashtable）。