### 7.8.1　final数据

许多编程语言都有某种方法，来向编译器告知一块数据是恒定不变的。有时数据的恒定不变是很有用的，比如：

1. 一个永不改变的编译时常量。

2. 一个在运行时被初始化的值，而你不希望它被改变。

对于编译期常量这种情况，编译器可以将该常量值代入任何可能用到它的计算式中，也就是说，可以在编译时执行计算式，这减轻了一些运行时的负担。在Java中，这类常量必须是基本数据类型，并且以关键字final表示。在对这个常量进行定义的时候，必须对其进行赋值。

一个既是static又是final的域只占据一段不能改变的存储空间。

当对对象引用而不是基本类型运用final时，其含义会有一点令人迷惑。对于基本类型，final使数值恒定不变；而用于对象引用，final使引用恒定不变。一旦引用被初始化指向一个对象，就无法再把它改为指向另一个对象。然而，对象其自身却是可以被修改的，Java并未提供使任何对象恒定不变的途径（但可以自己编写类以取得使对象恒定不变的效果）。这一限制同样适用数组，它也是对象。

下面的示例示范了final域的情况。注意，根据惯例，既是static又是final的域（即编译期常量）将用大写表示，并使用下划线分隔各个单词：

![173-1](../Images/image02847.jpeg)

![174-1](../Images/image02848.jpeg)

由于valuOne和VAL_TWO都是带有编译时数值的final基本类型，所以它们二者均可以用作编译期常量，并且没有重大区别。VAL_THREE是一种更加典型的对常量进行定义的方式：定义为public，则可以被用于包之外；定义为static，则强调只有一份；定义为final，则说明它是一个常量。请注意，带有恒定初始值（即，编译期常量）的final static基本类型全用大写字母命名，并且字与字之间用下划线隔开（这就像C常量一样，C常量是这一命名传统的发源地）。

我们不能因为某数据是final的就认为在编译时可以知道它的值。在运行时使用随机生成的数值来初始化i4和INT_5就说明了这一点。示例部分也展示了将final数值定义为静态和非静态的区别。此区别只有当数值在运行时内被初始化时才会显现，这是因为编译器对编译时数值一视同仁（并且它们可能因优化而消失）。当运行程序时就会看到这个区别。请注意，在fd1和fd2中，i4的值是唯一的，但INT_5的值是不可以通过创建第二个FinalData对象而加以改变的。这是因为它是static的，在装载时已被初始化，而不是每次创建新对象时都初始化。

v1到VAL_3这些变量说明了final引用的意义。正如在main()中所看到的，不能因为v2是final的，就认为无法改变它的值。由于它是一个引用，final意味着无法将v2再次指向另一个新的对象。这对数组具有同样的意义，数组只不过是另一种引用（我还不知道有什么办法能使数组引用本身成为final）。看起来，使引用成为final没有使基本类型成为final的用处大。

练习18：（2）创建一个含有static final域和final域的类，说明二者间的区别。

空白final

Java允许生成“空白final”，所谓空白final是指被声明为final但又未给定初值的域。无论什么情况，编译器都确保空白final在使用前必须被初始化。但是，空白final在关键字final的使用上提供了更大的灵活性，为此，一个类中的final域就可以做到根据对象而有所不同，却又保持其恒定不变的特性。下面即为一例：

![175-1](../Images/image02849.jpeg)

必须在域的定义处或者每个构造器中用表达式对final进行赋值，这正是final域在使用前总是被初始化的原因所在。

练习19：（2）创建一个含有指向某对象的空白final引用的类。在所有构造器内部都执行空白final的初始化动作。说明Java确保final在使用前必须被初始化，且一旦被初始化即无法改变。

final参数

Java允许在参数列表中以声明的方式将参数指明为final。这意味着你无法在方法中更改参数引用所指向的对象：

![175-2](../Images/image02850.jpeg)

方法f()和g()展示了当基本类型的参数被指明为final时所出现的结果：你可以读参数，但却无法修改参数。这一特性主要用来向匿名内部类传递数据，我们将在第10章中学习它。