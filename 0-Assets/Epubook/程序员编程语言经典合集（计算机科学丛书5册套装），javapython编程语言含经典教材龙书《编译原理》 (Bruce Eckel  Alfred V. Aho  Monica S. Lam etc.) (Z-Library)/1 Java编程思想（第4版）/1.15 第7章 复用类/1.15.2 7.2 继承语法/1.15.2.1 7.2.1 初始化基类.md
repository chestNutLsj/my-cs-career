### 7.2.1　初始化基类

由于现在涉及基类和导出类这两个类，而不是只有一个类，所以要试着想像导出类所产生的结果对象，会有点困惑。从外部来看，它就像是一个与基类具有相同接口的新类，或许还会有一些额外的方法和域。但继承并不只是复制基类的接口。当创建了一个导出类的对象时，该对象包含了一个基类的子对象。这个子对象与你用基类直接创建的对象是一样的。二者区别在于，后者来自于外部，而基类的子对象被包装在导出类对象内部。

当然，对基类子对象的正确初始化也是至关重要的，而且也仅有一种方法来保证这一点：在构造器中调用基类构造器来执行初始化，而基类构造器具有执行基类初始化所需要的所有知识和能力。Java会自动在导出类的构造器中插入对基类构造器的调用。下例展示了上述机制在三层继承关系上是如何工作的：

![162-1](../Images/image02830.jpeg)

读者会发现，构建过程是从基类“向外”扩散的，所以基类在导出类构造器可以访问它之前，就已经完成了初始化。即使你不为Cartoon()创建构造器，编译器也会为你合成一个默认的构造器，该构造器将调用基类的构造器。

练习3：（2）证明前面这句话。

练习4：（2）证明基类构造器：（a）总是会被调用；（b）在导出类构造器之前被调用。

练习5：（1）创建两个带有默认构造器（空参数列表）的类A和类B。从A中继承产生一个名为C的新类，并在C内创建一个B类的成员。不要给C编写构造器。创建一个C类的对象并观察其结果。

带参数的构造器

上例中各个类均含有默认的构造器，即这些构造器都不带参数。编译器可以轻松地调用它们是因为不必考虑要传递什么样的参数的问题。但是，如果没有默认的基类构造器，或者想调用一个带参数的基类构造器，就必须用关键字super显式地编写调用基类构造器的语句，并且配以适当的参数列表：

![163-1](../Images/image02831.jpeg)

如果不在BoardGame()中调用基类构造器，编译器将“抱怨”无法找到符合Game()形式的构造器。而且，调用基类构造器必须是你在导出类构造器中要做的第一件事（如果你做错了，编译器会提醒你）。

练习6：（1）用Chess.java来证明前一段话。

练习7：（1）修改练习5，使A和B以带参数的构造器取代默认的构造器。为C写一个构造器，并在其中执行所有的初始化。

练习8：（1）创建一个基类，它仅有一个非默认构造器；再创建一个导出类，它带有默认构造器和非默认构造器。在导出类的构造器中调用基类的构造器。

练习9：（2）创建一个Root类，令其含有名为Component 1、Component 2、Component 3的类的各一个实例（这些也由你写）。从Root中派生一个类Stem，也含有上述各“组成部分”。所有的类都应带有可打印出类的相关信息的默认构造器。

练习10：（1）修改练习10，使每个类都仅具有非默认的构造器。