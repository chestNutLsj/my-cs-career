## 7.2　继承语法

继承是所有OOP语言和Java语言不可缺少的组成部分。当创建一个类时，总是在继承，因此，除非已明确指出要从其他类中继承，否则就是在隐式地从Java的标准根类Object进行继承。

组合的语法比较平实，但是继承使用的是一种特殊的语法。在继承过程中，需要先声明“新类与旧类相似”。这种声明是通过在类主体的左边花括号之前，书写后面紧随基类名称的关键字extends而实现的。当这么做时，会自动得到基类中所有的域和方法。例如：

![160-2](../Images/image02828.jpeg)

![161-1](../Images/image02829.jpeg)

这个程序示范了Java的许多特性。首先，在Cleanser的append()方法中，我们用“+=”操作符将几个String对象连接成s，此操作符是被Java设计者重载用以处理String对象的操作符之一（另一个是“+”）。

其次，Cleanser和Detergent均含有main()方法。可以为每个类都创建一个main()方法。这种在每个类中都设置一个main()方法的技术可使每个类的单元测试都变得简便易行。而且在完成单元测试之后，也无需删除main()，可以将其留待下次测试。

即使是一个程序中含有多个类，也只有命令行所调用的那个类的main()方法会被调用。因此，在此例中，如果命令行是java Detergent，那么Detergent.main()将会被调用。即使Cleanser不是一个public类，如果命令行是java Cleanser，那么Cleanser.main()仍然会被调用。即使一个类只具有包访问权限，其public main()仍然是可访问的。

在此例中，可以看到Detergent.main()明确调用了Cleanser.main()，并将从命令行获取的参数传递给了它。当然，也可以向其传递任意的String数组。

Cleanser中所有的方法都必须是public的，这一点非常重要。请记住，如果没有加任何访问权限修饰词，那么成员默认的访问权限是包访问权限，它仅允许包内的成员访问。因此，在此包中，如果没有访问权限修饰词，任何人都可以使用这些方法。例如，Detergent就不成问题。但是，其他包中的某个类若要从Cleanser中继承，则只能访问public成员。所以，为了继承，一般的规则是将所有的数据成员都指定为private，将所有的方法指定为public（稍后将会学到，protected成员也可以借助导出类来访问）。当然，在特殊情况下，必须做出调整，但上述方法的确是一个很有用的规则。

在Cleanser的接口中有一组方法：append()、dilute()、apply()、scrub()和toString()。由于Detergent是由关键字extends从Cleanser导出的，所以它可以在其接口中自动获得这些方法，尽管并不能看到这些方法在Detergent中的显式定义。因此，可以将继承视作是对类的复用。

正如我们在scrub()中所见，使用基类中定义的方法及对它进行修改是可行的。在此例中，你可能想要在新版本中调用从基类继承而来的方法。但是在scrub()中，并不能直接调用scrub()，因为这样做将会产生递归，而这并不是你所期望的。为解决此问题，Java用super关键字表示超类的意思，当前类就是从超类继承来的。为此，表达式super.scrub()将调用基类版本的scrub()方法。

在继承的过程中，并不一定非得使用基类的方法。也可以在导出类中添加新方法，其添加方式与在类中添加任意方法一样，即对其加以定义即可。foam()方法即为一例。

读者在Detergent.main()中会发现，对于一个Detegent对象而言，除了可以调用Detergent的方法（即foam()）之外，还可以调用Cleanser中所有可用的方法。

练习2：（2）从Detergent中继承产生一个新的类。覆盖scrub()并添加一个名为sterilize()的新方法。