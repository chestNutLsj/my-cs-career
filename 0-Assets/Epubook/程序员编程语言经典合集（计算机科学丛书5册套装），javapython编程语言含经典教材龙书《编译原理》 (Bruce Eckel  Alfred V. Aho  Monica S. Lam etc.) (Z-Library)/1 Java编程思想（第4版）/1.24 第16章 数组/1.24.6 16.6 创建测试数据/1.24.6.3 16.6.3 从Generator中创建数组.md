### 16.6.3　从Generator中创建数组

为了接收Generator并产生数组，我们需要两个转换工具。第一个工具使用任意的Generator来产生Object子类型的数组。为了处理基本类型，第二个工具接收任意基本类型的包装器类型数组，并产生相应的基本类型数组。

第一个工具有两种选项，并由重载的静态方法array()来表示。该方法的第一个版本接收一个已有的数组，并使用某个Generator来填充它，而第二个版本接收一个Class对象、一个Generator和所需的元素数量，然后创建一个新数组，并使用所接收的Generator来填充它。注意，这个工具只能产生Object子类型的数组，而不能产生基本类型数组：

![480-2](../Images/image03356.jpeg)

CollectionData类将在第17章中定义，它将创建一个Collection对象，该对象中所填充的元素是由生成器gen产生的，而元素的数量则由构造器的第二个参数确定。所有的Collection子类型都拥有toArray()方法，该方法将使用Collection中的元素来填充参数数组。

第二个方法使用反射来动态创建具有恰当类型和数量的新数组，然后使用与第一个方法相同的技术来填充该数组。

我们可以使用在前一节中定义的CountingGenerator类中的某个生成器来测试Generated：

![480-3](../Images/image03357.jpeg)

即使数组a被初始化过，其中的那些值也在将其传递给Generated.array()之后被覆写了，因为这个方法会替换这些值（但是会保证原数组的正确性）。b的初始化展示了如何从无到有地创建填充了元素的数组。

泛型不能用于基本类型，而我们确实想用生成器来填充基本类型数组。为了解决这个问题，我们创建了一个转换器，它可以接收任意的包装器对象数组，并将其转换为相应的基本类型数组。如果没有这个工具，我们就必须为所有的基本类型创建特殊的生成器。

![481-2](../Images/image03358.jpeg)

primitive()方法的每个版本都可以创建适当的具有恰当长度的基本类型数组，然后向其中复制包装器类型数组in中的元素。注意，在下面的表达式中会进行自动拆包：

![482-1](../Images/image03359.jpeg)

下面的示例展示了如何将ConvertTo应用于两个版本的Generated.array()上：

![482-2](../Images/image03360.jpeg)

最后，下面的程序将使用RandomGenerator中的类来测试这些数组生成工具：

![482-3](../Images/image03361.jpeg)

![483-1](../Images/image03362.jpeg)

这些测试还可以确保ConvertTo.primitive()方法的每个版本都可以正确地工作。

练习11：（2）展示自动包装机制不能应用于数组。

练习12：（1）用CountingGenerator创建一个初始化过的double数组并打印结果。

练习13：（2）用CountingGenerator.Character填充一个String。

练习14：（6）对每个基本类型都创建一个数组，然后用CountingGenerator来填充每个数组并打印所有的数组。

练习15：（2）修改ContainerComparison.java，创建一个用于BerylliumSphere的Generator，并修改main()方法，再将这个Generator作用于Generated.array()。

练习16：（3）从CountingGenerator.java开始，创建一个SkipGenerator类，它可以根据构造器参数，通过递增产生新值。修改TestArrayGeneration.java，以展示新类可以正确地工作。

练习17：（5）创建并测试用于BigDecimal的Generator，并确保它可以用于Generated中的方法。