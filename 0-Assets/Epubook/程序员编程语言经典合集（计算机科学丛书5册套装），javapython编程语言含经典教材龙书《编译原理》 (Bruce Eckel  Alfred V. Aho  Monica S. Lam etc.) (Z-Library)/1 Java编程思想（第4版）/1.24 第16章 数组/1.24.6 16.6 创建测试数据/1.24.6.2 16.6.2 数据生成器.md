### 16.6.2　数据生成器

为了以灵活的方式创建更有意义的数组，我们将使用在第15章中引入的Generator概念。如果某个工具使用了Generator，那么你就可以通过选择Generator的类型来创建任何类型的数据（这是策略设计模式的一个实例——每个不同的Generator都表示一个不同的策略[^1]）。

本节将提供一些Generator，并且，就像之前看到的，你还可以很容易地定义自己的Generator。

首先给出的是可以用于所有基本类型的包装器类型，以及String类型的最基本的计数生成器集合。这些生成器类都嵌套在CountingGenerator类中，从而使得它们能够使用与所要生成的对象类型相同的名字。例如，创建Integer对象的生成器可以通过表达式new CountingGenerator.Integer()来创建：

![476-2](../Images/image03349.jpeg)

![477-1](../Images/image03350.jpeg)

上面的每个类都实现了某种意义的“计数”。在CountingGenerator.Character中，计数只是不断地重复大写和小写字母；CountingGenerator.String类使用CountingGenerator.Character来填充一个字符数组，该数组将被转换为String，数组的尺寸取决于构造器参数。请注意，CountingGenerator.String使用的是基本的Generator<java.lang.Character>，而不是具体的对CountingGenerator.Character的引用。稍后，我们可以替换这个生成器，以生成RandomGenerator.java中的RandomGenerator.String。

下面是一个测试工具，针对嵌套的Generator这一惯用法，因为使用了反射所以这个工具可以遵循下面的形式来测试Generator的任何集合。

![477-2](../Images/image03351.jpeg)

![478-1](../Images/image03352.jpeg)

这里假设待测类包含一组嵌套的Generator对象，其中每个都有一个默认构造器（无参构造器）。反射方法getClasses()可以生成所有的嵌套类，而test()方法可以为这些生成器中的每一个都创建一个实例，然后打印通过调用10次next()方法而产生的结果。

下面是一组使用随机数生成器的Generator。因为Random构造器使用常量进行初始化，所以，每次用这些Generator中的一个来运行程序时，所产生的输出都是可重复的：

![478-2](../Images/image03353.jpeg)

![479-1](../Images/image03354.jpeg)

你可以看到，RandomGenerator.String继承自CountingGenerator.String，并且只是插入了新的Character生成器。

为了不生成过大的数字，RandomGenerator.Integer默认使用的模数为10 000，但是重载的构造器允许你选择更小的值。同样的方式也应用到了RandomGenerator.Long上。对于Float和Double生成器，小数点之后的数字被截掉了。

我们复用GeneratorTest来测试RandomGenerator：

![479-2](../Images/image03355.jpeg)

你可以通过修改public的GeneratorTest.size的值，来改变所产生的数值数量。