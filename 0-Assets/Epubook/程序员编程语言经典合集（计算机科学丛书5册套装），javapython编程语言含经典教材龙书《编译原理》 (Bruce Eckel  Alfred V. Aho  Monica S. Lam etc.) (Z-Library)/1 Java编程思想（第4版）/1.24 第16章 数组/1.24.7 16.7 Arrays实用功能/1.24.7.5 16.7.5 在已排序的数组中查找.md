### 16.7.5　在已排序的数组中查找

如果数组已经排好序了，就可以使用Arrays.binarySearch()执行快速查找。如果要对未排序的数组使用binarySearch()，那么将产生不可预料的结果。下面的例子使用RandIntGenerator.Integer填充数组，然后再使用同样的生成器生成要查找的值：

![489-1](../Images/image03371.jpeg)

在while循环中随机生成一些值作为查找的对象，直到找到一个才停止循环。

如果找到了目标，Arrays.binarySearch()产生的返回值等于或大于0。否则，它产生负返回值，表示若要保持数组的排序状态此目标元素所应该插入的位置。这个负值的计算方式是：

-（插入点） - 1

“插入点”是指，第一个大于查找对象的元素在数组中的位置，如果数组中所有的元素都小于要查找的对象，“插入点”就等于a.size()。

如果数组包含重复的元素，则无法保证找到的是这些副本中的哪一个。搜索算法确实不是专为包含重复元素的数组而设计的，不过仍然可用。如果需要对没有重复元素的数组排序，可以使用TreeSet（保持排序顺序），或者LinkedHashSet（保持插入顺序），后面我们将会介绍它们。这些类会自动处理所有的细节。除非它们成为程序性能的瓶颈，否则不需要自己维护数组。

如果使用Comparator排序了某个对象数组（基本类型数组无法使用Comparator进行排序），在使用binarySearch()时必须提供同样的Comparator（使用binarySearch()方法的重载版本）。例如，可以修改StringSorting.java程序以进行某种查找：

![489-2](../Images/image03372.jpeg)

这里的Comparator必须接受重载过的binarySearch()作为其第三个参数。在这个例子中，由于要查找的目标就是从数组中选出来的元素，所以肯定能查找到。

练习22：（2）通过程序说明在未排序数组上执行binarySearch()方法的结果是不可预知的。

练习23：（2）创建一个Integer数组，用随机的int数值填充它（使用自动包装机制），再使用Comparator将其进行反向排序。

练习24：（3）通过程序说明练习19中的类是可查找的。