## 16.5　数组与泛型

通常，数组与泛型不能很好地结合。你不能实例化具有参数化类型的数组：

![473-2](../Images/image03342.jpeg)

擦除会移除参数类型信息，而数组必须知道它们所持有的确切类型，以强制保证类型安全。

但是，你可以参数化数组本身的类型：

![473-3](../Images/image03343.jpeg)

注意，使用参数化方法而不使用参数化类的方便之处在于：你不必为需要应用的每种不同的类型都使用一个参数去实例化这个类，并且你可以将其定义为静态的。当然，你不能总是选择使用参数化方法而不是参数化类，但是它应该成为首选。

正如上例所证明的那样，不能创建泛型数组这一说法并不十分准确。诚然，编译器确实不让你实例化泛型数组，但是，它允许你创建对这种数组的引用。例如：

![474-1](../Images/image03344.jpeg)

这条语句可以顺利地通过编译器而不报任何错误。而且，尽管你不能创建实际的持有泛型的数组对象，但是你可以创建非泛型的数组，然后将其转型：

![474-2](../Images/image03345.jpeg)

一旦拥有了对List<String>[]的引用，你就会看到你将得到某些编译器检查。问题是数组是协变类型的，因此List<String>[]也是一个Object[]，并且你可以利用这一点，将一个ArrayList<Integer>赋值到你的数组中，而不会有任何编译期或运行时错误。

如果你知道将来不会向上转型，并且需求也相对比较简单，那么你仍旧可以创建泛型数组，它可以提供基本的编译期类型检查。但是，事实上，泛型容器总是比泛型数据更好的选择。

一般而言，你会发现泛型在类或方法的边界处很有效，而在类或方法的内部，擦除通常会使泛型变得不适用。例如，你不能创建泛型数组：

![474-3](../Images/image03346.jpeg)

擦除再次成为了障碍——本例试图创建的类型已被擦除，因而是类型未知的数组。注意，你可以创建Object数组，然后将其转型，但是如果没有@SuppressWarnings注解，你将在编译期得到一个“不受检查”的警告消息，因为这个数组没有真正持有或动态检查类型T。也就是说，如果我创建一个String[]，Java在编译期和运行时都会强制要求我只能将String对象置于该数组中。但是，如果创建的是Object[]，那么我就可以将除基本类型之外的任何对象置于该数组中。

练习8：（1）证明前一段话中的断言。

练习9：（3）创建Peel<Banana>所必需的类，并展示编译器不会接受它。使用ArrayList来改正此问题。

练习10：（2）修改ArrayOfGenerics.java，在其中使用容器而不是数组。展示你可以根除编译期警告信息。