## 15.8　擦除的补偿

正如我们看到的，擦除丢失了在泛型代码中执行某些操作的能力。任何在运行时需要知道确切类型信息的操作都将无法工作：

![413-2](../Images/image03233.jpeg)

偶尔可以绕过这些问题来编程，但是有时必须通过引入类型标签来对擦除进行补偿。这意味着你需要显式地传递你的类型的Class对象，以便你可以在类型表达式中使用它。

例如，在前面示例中对使用instanceof的尝试最终失败了，因为其类型信息已经被擦除了。如果引入类型标签，就可以转而使用动态的isInstance()：

![413-3](../Images/image03234.jpeg)

编译器将确保类型标签可以匹配泛型参数。

练习21：（4）修改ClassTypeCapture.java，添加一个Map<String，Class<？>>，一个addType（String typename，Class<？>kind）方法和一个createNew（String typename）方法。createNew()将产生一个与其参数字符串相关联的类的新实例，或者产生一条错误消息。