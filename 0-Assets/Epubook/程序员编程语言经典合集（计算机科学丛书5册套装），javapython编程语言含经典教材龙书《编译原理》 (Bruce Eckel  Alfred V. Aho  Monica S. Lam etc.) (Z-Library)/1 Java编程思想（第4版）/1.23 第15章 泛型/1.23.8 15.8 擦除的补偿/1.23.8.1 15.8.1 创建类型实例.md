### 15.8.1　创建类型实例

在Erased.java中对创建一个new T()的尝试将无法实现，部分原因是因为擦除，而另一部分原因是因为编译器不能验证T具有默认（无参）构造器。但是在C++中，这种操作很自然、很直观，并且很安全（它是在编译期受到检查的）：

![414-2](../Images/image03235.jpeg)

Java中的解决方案是传递一个工厂对象，并使用它来创建新的实例。最便利的工厂对象就是Class对象，因此如果使用类型标签，那么你就可以使用newInstance()来创建这个类型的新对象：

![414-3](../Images/image03236.jpeg)

这可以编译，但是会因ClassAsFactory<Integer>而失败，因为Integer没有任何默认的构造器。因为这个错误不是在编译期捕获的，所以Sun的伙计们对这种方式并不赞成，他们建议使用显式的工厂，并将限制其类型，使得只能接受实现了这个工厂的类：

![415-2](../Images/image03237.jpeg)

注意，这确实只是传递Class<T>的一种变体。两种方式都传递了工厂对象，Class<T>碰巧是内建的工厂对象，而上面的方式创建了一个显式的工厂对象，但是你却获得了编译期检查。

另一种方式是模版方法设计模式。在下面的示例中，get()是模版方法，而create()是在子类中定义的、用来产生子类类型的对象：

![415-3](../Images/image03238.jpeg)

练习22：（6）使用类型标签与反射来创建一个方法，它将使用newInstance()的参数版本来创建某个类的对象，这个类拥有一个具有参数的构造器。

练习23：（1）修改FactoryConstraint.java，使得create()可以接受一个参数。

练习24：（3）修改练习21，使得工厂对象是由一个Map而不是Class<？>持有的。