### 15.8.2　泛型数组

正如你在Erased.java中所见，不能创建泛型数组。一般的解决方案是在任何想要创建泛型数组的地方都使用ArrayList：

![416-2](../Images/image03239.jpeg)

这里你将获得数组的行为，以及由泛型提供的编译期的类型安全。

有时，你仍旧希望创建泛型类型的数组（例如，ArrayList内部使用的是数组）。有趣的是，可以按照编译器喜欢的方式来定义一个引用，例如：

![416-3](../Images/image03240.jpeg)

编译器将接受这个程序，而不会产生任何警告。但是，永远都不能创建这个确切类型的数组（包括类型参数），因此这有一点令人困惑。既然所有数组无论它们持有的类型如何，都具有相同的结构（每个数组槽位的尺寸和数组的布局），那么看起来你应该能够创建一个Object数组，并将其转型为所希望的数组类型。事实上这可以编译，但是不能运行，它将产生ClassCaseException：

![416-4](../Images/image03241.jpeg)

问题在于数组将跟踪它们的实际类型，而这个类型是在数组被创建时确定的，因此，即使gia已经被转型为Generic<Integer>[]，但是这个信息只存在于编译期（并且如果没有@Suppress Warnings注解，你将得到有关这个转型的警告）。在运行时，它仍旧是Object数组，而这将引发问题。成功创建泛型数组的唯一方式就是创建一个被擦除类型的新数组，然后对其转型。

让我们看一个更复杂的示例。考虑一个简单的泛型数组包装器：

![417-2](../Images/image03242.jpeg)

与前面相同，我们并不能声明T[] array = new T[sz]，因此我们创建了一个对象数组，然后将其转型。

rep()方法将返回T[]，它在main()中将用于gai，因此应该是Integer[]，但是如果调用它，并尝试着将结果作为Integer[]引用来捕获，就会得到ClassCastException，这还是因为实际的运行时类型是Object[]。

如果在注释掉@SuppressWarnings注解之后再编译GenericArray.java，编译器就会产生警告：

![417-3](../Images/image03243.jpeg)

在这种情况下，我们将只获得单个的警告，并且相信这事关转型。但是如果真的想要确定是否是这么回事，就应该用-Xlint：unchecked来编译：

![417-4](../Images/image03244.jpeg)

这确实是对转型的抱怨。因为警告会变得令人迷惑，所以一旦我们验证某个特定警告是可预期的，那么我们的上策就是用@SuppressWarnings关闭它。通过这种方式，当警告确实出现时，我们就可以真正地展开对它的调查了。

因为有了擦除，数组的运行时类型就只能是Object[]。如果我们立即将其转型为T[]，那么在编译期该数组的实际类型就将丢失，而编译器可能会错过某些潜在的错误检查。正因为这样，最好是在集合内部使用Object[]，然后当你使用数组元素时，添加一个对T的转型。让我们看看这是如何作用于GenericArray.java示例的：

![418-2](../Images/image03245.jpeg)

初看起来，这好像没多大变化，只是转型挪了地方。如果没有@SuppressWarnings注解，你仍旧会得到unchecked警告。但是，现在的内部表示是Object[]而不是T[]。当get()被调用时，它将对象转型为T，这实际上是正确的类型，因此这是安全的。然而，如果你调用rep()，它还是尝试着将Object[]转型为T[]，这仍旧是不正确的，将在编译期产生警告，在运行时产生异常。因此，没有任何方式可以推翻底层的数组类型，它只能是Object[]。在内部将array当作Object[]而不是T[]处理的优势是：我们不太可能忘记这个数组的运行时类型，从而意外地引入缺陷（尽管大多数也可能是所有这类缺陷都可以在运行时快速地探测到）。

对于新代码，应该传递一个类型标记。在这种情况下，GenericArray看起来会像下面这样：

![419-1](../Images/image03246.jpeg)

类型标记Class<T>被传递到构造器中，以便从擦除中恢复，使得我们可以创建需要的实际类型的数组，尽管从转型中产生的警告必须用@SuppressWarnings压制住。一旦我们获得了实际类型，就可以返回它，并获得想要的结果，就像在main()中看到的那样。该数组的运行时类型是确切类型T[]。

遗憾的是，如果查看Java SE5标准类库中的源代码，你就会看到从Object数组到参数化类型的转型遍及各处。例如，下面是经过整理和简化之后的从Collection中复制ArrayList的构造器：

![419-2](../Images/image03247.jpeg)

如果你通读ArrayList.java，就会发现它充满了这种转型。如果我们编译它，又会发生什么呢？

![419-3](../Images/image03248.jpeg)

可以十分肯定，标准类库会产生大量的警告。如果你曾经用过C++，特别是ANSI C之前的版本，你就会记得警告的特殊效果：当你发现可以忽略它们时，你就可以忽略。正是因为这个原因，最好是从编译器中不要发出任何消息，除非程序员必须对其进行响应。

Neal Gafter（Java SE5的领导开发者之一）在他的博客[^3]中指出，在重写Java类库时，他十分懒散，而我们不应该像他那样。Neal还指出，在不破坏现有接口的情况下，他将无法修改某些Java类库代码。因此，即使在Java类库源代码中出现了某些惯用法，也不能表示这就是正确的解决之道。当查看类库代码时，你不能认为它就是应该在自己的代码中遵循的示例。