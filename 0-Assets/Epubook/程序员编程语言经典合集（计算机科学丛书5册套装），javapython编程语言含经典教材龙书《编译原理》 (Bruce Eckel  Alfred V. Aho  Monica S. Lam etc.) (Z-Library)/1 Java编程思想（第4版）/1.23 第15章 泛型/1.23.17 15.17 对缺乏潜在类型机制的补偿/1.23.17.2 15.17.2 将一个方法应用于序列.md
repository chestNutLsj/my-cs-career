### 15.17.2　将一个方法应用于序列

反射提供了一些有趣的可能性，但是它将所有的类型检查都转移到了运行时，因此在许多情况下并不是我们所希望的。如果能够实现编译期类型检查，这通常会更符合要求。但是有可能实现编译期类型检查和潜在类型机制吗？

让我们看一个说明这个问题的示例。假设想要创建一个apply()方法，它能够将任何方法应用于某个序列中的所有对象。这是接口看起来并不适合的情况，因为你想要将任何方法应用于一个对象集合，而接口对于描述“任何方法”存在过多的限制。如何用Java来实现这个需求呢？

最初，我们可以用反射来解决这个问题，由于有了Java SE5的可变参数，这种方式被证明是相当优雅的：

![454-2](../Images/image03315.jpeg)

![455-1](../Images/image03316.jpeg)

在Apply中，我们运气很好，因为碰巧在Java中内建了一个由Java容器类库使用的Iterable接口。正由于此，apply()方法可以接受任何实现了Iterable接口的事物，包括诸如List这样的所有Collection类。但是它还可以接受其他任何事物，只要能够使这些事物是Iterable的——例如，在main()中使用的下面定义的SimpleQueue类：

![455-2](../Images/image03317.jpeg)

在Apply.java中，异常被转换为RuntimeException，因为没有多少办法可以从这种异常中恢复——在这种情况下，它们实际上代表着程序员的错误。

注意，我必须放置边界和通配符，以便使Apply和FilledList在所有需要的情况下都可以使用。可以试验一下，将这些边界和通配符拿出来，你就会发现某些Apply和FilledList应用将无法工作。

FilledList表示有点进退两难的情况。为了使某种类型可用，它必须有默认（无参）构造器，但是Java没有任何方式可以在编译期断言这种事情，因此这就变成了一个运行时问题。确保编译期检查的常见建议是定义一个工厂接口，它有一个可以生成对象的方法，然后FilledList将接受这个接口而不是这个类型标记的“原生工厂”，而这样做的问题是在FilledList中使用的所有类都必须实现这个工厂接口。唉，大多数的类都是在不了解你的接口的情况下创建的，因此也就没有实现这个接口。稍后，我将展示一种使用适配器的解决方案。

但是上面所展示的使用类型标记的方法可能是一种合理的折中（至少是一种马上就能想到解决方案）。通过这种方式，使用像FilledList这样的东西就会非常容易，我们会马上想到要使用它而不是会忽略它。当然，因为错误是在运行时报告的，所以你要有把握，这些错误将在开发过程的早期出现。

注意，类型标记技术是Java文献推荐的技术，例如Gilad Bracha在他的论文《Generics in Java Programming Language》[^9]中写道“这是一种惯用法，例如，在操作注解的新API中得到了广泛的应用”。但是，我发现人们对这种技术的适应程度不一，有些人强烈地首选本章前面描述的工厂方式。

尽管Java解决方案被证明很优雅，但是我们必须知道使用反射（尽管反射在最近版本的Java中已经明显地改善了）可能比非反射的实现要慢一些，因为有太多的动作都是在运行时发生的。这不应该阻止你使用这种解决方案的脚步，至少可以将其作为一种马上就能想到的解决方案（以防止陷入不成熟的优化中），但这毫无疑问是这两种方法之间的一个差异。

练习40：（3）向typeinfo.java中的所有宠物中添加一个speak()方法。修改Apply.java，使得我们可以对Pet的异构集合调用speak()。