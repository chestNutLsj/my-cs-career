### 15.17.3　当你并未碰巧拥有正确的接口时

上面的示例是受益的，因为Iterable接口已经是内建的，而它正是我们需要的。但是更一般的情况又会怎样呢？如果不存在刚好适合你的需求的接口呢？

例如，让我们泛化FilledList中的思想，创建一个参数化的方法fill()，它接受一个序列，并使用Generator填充它。当我们尝试着用Java来编写时，就会陷入问题之中，因为没有任何像前面示例中的Iterable接口那样的“Addable”便利接口。因此你不能说：“可以在任何事物上调用add()。”而必须说：“可以在Collection的子类型上调用add()。”这样产生的代码并不是特别泛化，因为它必须限制为只能工作于Collection实现。如果我试图使用没有实现Collection的类，那么我的泛化代码将不能工作。下面是这段代码的样子：

![456-1](../Images/image03318.jpeg)

![457-1](../Images/image03319.jpeg)

这正是具有潜在类型机制的参数化类型机制的价值所在，因为你不会受任何特定类库的创建者过去所作的设计决策的支配，因此不需要在每次碰到一个没有考虑到你的具体情况的新类库时，都去重写代码（因此这样的代码才是真正“泛化的”）。在上面的情况中，因为Java设计者（可以理解地）没有预见到对“Addable”接口的需要，所以我们被限制在Collection继承层次结构之内，即便SimpleQueue有一个add()方法，它也不能工作。因为这会将代码限制为只能工作于Collection，因此这样的代码不是特别“泛化”。有了潜在类型机制，情况就会不同了。