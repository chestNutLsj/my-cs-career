### 15.17.4　用适配器仿真潜在类型机制

Java泛型并不没有潜在类型机制，而我们需要像潜在类型机制这样的东西去编写能够跨类边界应用的代码（也就是“泛化”代码）。存在某种方式可以绕过这项限制吗？

潜在类型机制将在这里实现什么？它意味着你可以编写代码声明：“我不关心我在这里使用的类型，只要它具有这些方法即可。”实际上，潜在类型机制创建了一个包含所需方法的隐式接口。因此它遵循这样的规则：如果我们手工编写了必需的接口（因为Java并没有为我们做这些事），那么它就应该能够解决问题。

从我们拥有的接口中编写代码来产生我们需要的接口，这是适配器设计模式的一个典型示例。我们可以使用适配器来适配已有的接口，以产生想要的接口。下面这种使用前面定义的Coffee继承结构的解决方案演示了编写适配器的不同方式：

![457-2](../Images/image03320.jpeg)

![458-1](../Images/image03321.jpeg)

Fill2对Collection的要求与Fill不同，它只需要实现了Addable的对象，而Addable已经为Fill编写了——它是我希望编译器帮我创建的潜在类型的一种体现。

在这个版本中，我还添加了一个重载的fill()，它接受一个Generator而不是类型标记。Generator在编译期是类型安全的：编译器将确保传递的是正确的Generator，因此不会抛出任何异常。

第一个适配器，AddableCollectionAdapter，可以工作于基类型Collection，这意味着Collection的任何实现都可以使用。这个版本直接存储Collection引用，并使用它来实现add()。

如果有一个具体类型而不是继承结构的基类，那么当使用继承来创建适配器时，你可以稍微少编写一些代码，就像在AddableSimpleQueue中看到的那样。

在Fill2Test.main()中，你可以看到各种不同类型的适配器在运行。首先，Collection类型是由AddableCollectionAdapter适配的。这个第二个版本使用了一个泛化的辅助方法，你可以看到这个泛化方法是如何捕获类型并因此而不必显式地写出来的——这是产生更优雅的代码的一种惯用技巧。

接下来，使用了预适配的AddableSimpleQueue。注意，在两种情况下，适配器都允许前面没有实现Addable的类用于Fill2.fill()中。

使用像这样的适配器看起来是对缺乏潜在类型机制的一种补偿，因此允许编写出真正的泛化代码。但是，这是一个额外的步骤，并且是类库的创建者和消费者都必须理解的事物，而缺乏经验的程序员可能还没有能够掌握这个概念。潜在类型机制通过移除这个额外的步骤，使得泛化代码更容易应用，这就是它的价值所在。

练习41：（1）修改Fill2.java，用typeinfo.java中的类取代Coffee中的类。