## 15.3　泛型接口

泛型也可以应用于接口。例如生成器（generator），这是一种专门负责创建对象的类。实际上，这是工厂方法设计模式的一种应用。不过，当使用生成器创建新的对象时，它不需要任何参数，而工厂方法一般需要参数。也就是说，生成器无需额外的信息就知道如何创建新对象。

一般而言，一个生成器只定义一个方法，该方法用以产生新的对象。在这里，就是next()方法。我将它收录在我的标准工具类库中：

![391-2](../Images/image03186.jpeg)

方法next()的返回类型是参数化的T。正如你所见到的，接口使用泛型与类使用泛型没什么区别。

为了演示如何实现Generator接口，我们还需要一些别的类。例如，Coffee类层次结构如下：

![391-3](../Images/image03187.jpeg)

现在，我们可以编写一个类，实现Generator<Coffee>接口，它能够随机生成不同类型的Coffee对象：

![392-2](../Images/image03188.jpeg)

参数化的Generator接口确保next()的返回值是参数的类型。CoffeeGenerator同时还实现了Iterable接口，所以它可以在循环语句中使用。不过，它还需要一个“末端哨兵”来判断何时停止，这正是第二个构造器的功能。

下面的类是Generator<T>接口的另一个实现，它负责生成Fibonacci数列：

![393-1](../Images/image03189.jpeg)

虽然我们在Fibonacci类的里里外外使用的都是int类型，但是其类型参数却是Integer。这个例子引出了Java泛型的一个局限性：基本类型无法作为类型参数。不过，Java SE5具备了自动打包和自动拆包的功能，可以很方便地在基本类型和其相应的包装器类型之间进行转换。通过这个例子中Fibonacci类对int的使用，我们已经看到了这种效果。

如果还想更进一步，编写一个实现了Iterable的Fibonacci生成器。我们的一个选择是重写这个类，令其实现Iterable接口。不过，你并不是总能拥有源代码的控制权，并且，除非必须这么做，否则，我们也不愿意重写一个类。而且我们还有另一种选择，就是创建一个适配器（adapter）来实现所需的接口，我们在前面介绍过这个设计模式。

有多种方法可以实现适配器。例如，可以通过继承来创建适配器类：

![393-2](../Images/image03190.jpeg)

如果要在循环语句中使用IterableFibonacci，必须向IterableFibonacci的构造器提供一个边界值，然后hasNext()方法才能知道何时应该返回false。

练习7：（2）使用组合代替继承，适配Fibonacci使其成为Iterable。

练习8：（2）模仿Coffee示例的样子，根据你喜爱的电影人物，创建一个StoryCharacters的类层次结构，将它们划分为GoodGuys和BadGuys。再按照CoffeeGenerator的形式，编写一个StoryCharacters的生成器。