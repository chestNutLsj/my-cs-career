   

# 第15章　泛型

一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大[^1]。

在面向对象编程语言中，多态算是一种泛化机制。例如，你可以将方法的参数类型设为基类，那么该方法就可以接受从这个基类中导出的任何类作为参数。这样的方法更加通用一些，可应用的地方也多一些。在类的内部也是如此，凡是需要说明类型的地方，如果都使用基类，确实能够具备更好的灵活性。但是，考虑到除了final类[^2]不能扩展，其他任何类都可以被扩展，所以这种灵活性大多数时候也会有一些性能损耗。

有时候，拘泥于单继承体系，也会使程序受限太多。如果方法的参数是一个接口，而不是一个类，这种限制就放松了许多。因为任何实现了该接口的类都能够满足该方法，这也包括暂时还不存在的类。这就给予客户端程序员一种选择，他可以通过实现一个接口来满足类或方法。因此，接口允许我们快捷地实现类继承，也使我们有机会创建一个新类来做到这一点。

可是有的时候，即便使用了接口，对程序的约束也还是太强了。因为一旦指明了接口，它就要求你的代码必须使用特定的接口。而我们希望达到的目的是编写更通用的代码，要使代码能够应用于“某种不具体的类型”，而不是一个具体的接口或类。

这就是Java SE5的重大变化之一：泛型的概念。泛型实现了参数化类型的概念，使代码可以应用于多种类型。“泛型”这个术语的意思是：“适用于许多许多的类型”。泛型在编程语言中出现时，其最初的目的是希望类或方法能够具备最广泛的表达能力。如何做到这一点呢，正是通过解耦类或方法与所使用的类型之间的约束。稍后你将看到，Java中的泛型并没有这么高的追求，实际上，你可能会质疑，Java中的术语“泛型”是否适合用来描述这一功能。

如果你从未接触过参数化类型机制，那么，在学习了Java中的泛型之后，你会发现，对这门语言而言，泛型确实是一个很有益的补充。在你创建参数化类型的一个实例时，编译器会为你负责转型操作，并且保证类型的正确性。这应该是一个进步。

然而，如果你了解其他语言（例如C++）中的参数化类型机制，你就会发现，有些以前能做到的事情，使用Java的泛型机制却无法做到。使用别人已经构建好的泛型类型会相当容易。但是如果你要自己创建一个泛型实例，就会遇到许多令你吃惊的事情。在本章中，我的任务之一就是向你解释，Java中的泛型是怎样发展成现在这样的。

这并非是说Java的泛型毫无用处。在很多情况下，它们可以使代码更直接更优雅。不过，如果你具备其他语言的经验，而那种语言实现了更纯粹的泛型，那么，Java可能令你失望了。在本章中，我们会介绍Java泛型的优点与局限，希望这能够帮助你更有效地使用Java的这个新功能。