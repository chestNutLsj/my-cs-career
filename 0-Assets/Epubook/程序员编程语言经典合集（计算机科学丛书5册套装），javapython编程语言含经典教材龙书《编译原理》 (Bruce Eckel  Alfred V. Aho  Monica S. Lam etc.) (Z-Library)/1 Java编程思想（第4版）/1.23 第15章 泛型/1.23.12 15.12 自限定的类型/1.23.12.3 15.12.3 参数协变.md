### 15.12.3　参数协变

自限定类型的价值在于它们可以产生协变参数类型——方法参数类型会随子类而变化。尽管自限定类型还可以产生于子类类型相同的返回类型，但是这并不十分重要，因为协变返回类型是在Java SE5中引入的：

![440-3](../Images/image03293.jpeg)

DerivedGetter中的get()方法覆盖了OrdinaryGetter中的get()，并返回了一个从OrdinaryGetter.get()的返回类型中导出的类型。尽管这是完全合乎逻辑的事情（导出类方法应该能够返回比它覆盖的基类方法更具体的类型）但是这在早先的Java版本中是不合法的。

自限定泛型事实上将产生确切的导出类型作为其返回值，就像在get()中所看到的一样：

![441-1](../Images/image03294.jpeg)

注意，这段代码不能编译，除非是使用囊括了协变返回类型的Java SE5。然而，在非泛型代码中，参数类型不能随子类型发生变化：

![441-2](../Images/image03295.jpeg)

set（derived）和set（base）都是合法的，因此DerivedSetter.set()没有覆盖OrdinarySetter.set()，而是重载了这个方法。从输出中可以看到，在DerivedSetter中有两个方法，因此基类版本仍旧是可用的，因此可以证明它被重载过。

但是，在使用自限定类型时，在导出类中只有一个方法，并且这个方法接受导出类型而不是基类型为参数：

![441-3](../Images/image03296.jpeg)

编译器不能识别将基类型当作参数传递给set()的尝试，因为没有任何方法具有这样的签名。实际上，这个参数已经被覆盖。

如果不使用自限定类型，普通的继承机制就会介入，而你将能够重载，就像在非泛型的情况下一样：

![442-2](../Images/image03297.jpeg)

这段代码在模仿OrdinaryArgument.java，在那个示例中，DerivedSetter继承自包含一个set（Base）的OrdinarySetter。而这里，DerivedGS继承自泛型创建的也包含有一个set（Base）的GenericSetter<Base>。就像OrdinaryArgument.java一样，你可以从输出中看到，DerivedGS包含两个set()的重载版本。如果不使用自限定，将重载参数类型。如果使用了自限定，只能获得某个方法的一个版本，它将接受确切的参数类型。

练习34：（4）创建一个自限定的泛型类型，它包含一个abstract方法，这个方法将接受一个泛型类型参数，并产生具有这个泛型类型参数的返回值。在这个类的非abstract方法中，调用这个abstract方法，并返回其结果。继承这个自限定类型，并测试所产生的类。