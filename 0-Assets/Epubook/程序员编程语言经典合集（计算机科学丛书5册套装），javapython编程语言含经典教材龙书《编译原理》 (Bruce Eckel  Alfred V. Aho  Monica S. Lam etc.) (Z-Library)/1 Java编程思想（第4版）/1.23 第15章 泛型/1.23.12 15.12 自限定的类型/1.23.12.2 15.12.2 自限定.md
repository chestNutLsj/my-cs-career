### 15.12.2　自限定

BasicHolder可以使用任何类型作为其泛型参数，就像下面看到的那样：

![438-4](../Images/image03288.jpeg)

自限定将采取额外的步骤，强制泛型当作其自己的边界参数来使用。观察所产生的类可以如何使用以及不可以如何使用：

![439-2](../Images/image03289.jpeg)

自限定所做的，就是要求在继承关系中，像下面这样使用这个类：

![439-3](../Images/image03290.jpeg)

这会强制要求将正在定义的类当作参数传递给基类。

自限定的参数有何意义呢？它可以保证类型参数必须与正在被定义的类相同。正如你在B类的定义中所看到的，还可以从使用了另一个SelfBounded参数的SelfBounded中导出，尽管在A类看到的用法看起来是主要的用法。对定义E的尝试说明不能使用不是SelfBounded的类型参数。

遗憾的是，F可以编译，不会有任何警告，因此自限定惯用法不是可强制执行的。如果它确实很重要，可以要求一个外部工具来确保不会使用原生类型来替代参数化类型。

注意，可以移除自限定这个限制，这样所有的类仍旧是可以编译的，但是E也会因此而变得可编译：

![440-1](../Images/image03291.jpeg)

因此很明显，自限定限制只能强制作用于继承关系。如果使用自限定，就应该了解这个类所用的类型参数将与使用这个参数的类具有相同的基类型。这会强制要求使用这个类的每个人都要遵循这种形式。

还可以将自限定用于泛型方法：

![440-2](../Images/image03292.jpeg)

这可以防止这个方法被应用于除上述形式的自限定参数之外的任何事物上。