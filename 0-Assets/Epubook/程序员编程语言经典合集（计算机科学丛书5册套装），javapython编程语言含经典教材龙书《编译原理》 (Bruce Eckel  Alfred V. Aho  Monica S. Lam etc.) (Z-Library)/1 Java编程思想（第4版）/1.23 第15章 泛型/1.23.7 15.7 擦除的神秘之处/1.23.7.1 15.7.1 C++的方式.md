### 15.7.1　C++的方式

下面是使用模版的C++示例，你将注意到用于参数化类型的语法十分相似，因为Java是受C++的启发：

![407-1](../Images/image03216.jpeg)

Manipulator类存储了一个类型T的对象，有意思的地方是manipulate()方法，它在obj上调用方法f()。它怎么能知道f()方法是为类型参数T而存在的呢？当你实例化这个模版时，C++编译器将进行检查，因此在Manipulator<HasF>被实例化的这一刻，它看到HasF拥有一个方法f()。如果情况并非如此，就会得到一个编译期错误，这样类型安全就得到了保障。

用C++编写这种代码很简单，因为当模版被实例化时，模版代码知道其模版参数的类型。Java泛型就不同了。下面是HasF的Java版本：

![407-2](../Images/image03217.jpeg)

如果我们将这个示例的其余代码都翻译成Java，那么这些代码将不能编译：

![407-3](../Images/image03218.jpeg)

由于有了擦除，Java编译器无法将manipulate()必须能够在obj上调用f()这一需求映射到HasF拥有f()这一事实上。为了调用f()，我们必须协助泛型类，给定泛型类的边界，以此告知编译器只能接受遵循这个边界的类型。这里重用了extends关键字。由于有了边界，下面的代码就可以编译了：

![408-1](../Images/image03219.jpeg)

边界<T extends HasF>声明T必须具有类型HasF或者从HasF导出的类型。如果情况确实如此，那么就可以安全地在obj上调用f()了。

我们说泛型类型参数将擦除到它的第一个边界（它可能会有多个边界，稍候你就会看到），我们还提到了类型参数的擦除。编译器实际上会把类型参数替换为它的擦除，就像上面的示例一样。T擦除到了HasF，就好像在类的声明中用HasF替换了T一样。

你可能已经正确地观察到，在Manipulation2.java中，泛型没有贡献任何好处。只需很容易地自己去执行擦除，就可以创建出没有泛型的类：

![408-2](../Images/image03220.jpeg)

这提出了很重要的一点：只有当你希望使用的类型参数比某个具体类型（以及它的所有子类型）更加“泛化”时——也就是说，当你希望代码能够跨多个类工作时，使用泛型才有所帮助。因此，类型参数和它们在有用的泛型代码中的应用，通常比简单的类替换要更复杂。但是，不能因此而认为<T extends HasF>形式的任何东西而都是有缺陷的。例如，如果某个类有一个返回T的方法，那么泛型就有所帮助，因为它们之后将返回确切的类型：

![408-3](../Images/image03221.jpeg)

必须查看所有的代码，并确定它是否“足够复杂”到必须使用泛型的程度。

我们将在本章稍后介绍有关边界的更多细节。

练习20：（1）创建一个具有两个方法的接口，以及一个实现了这个接口并添加了另一个方法的类。在另一个类中，创建一个泛型方法，它的参数类型由这个接口定义了边界，并展示该接口中的方法在这个泛型方法中都是可调用的。在main()方法中传递一个实现类的实例给这个泛型方法。