### 15.7.4　边界处的动作

正是因为有了擦除，我发现泛型最令人困惑的方面源自这样一个事实，即可以表示没有任何意义的事物。例如：

![410-3](../Images/image03226.jpeg)

即使kind被存储为Class<T>，擦除也意味着它实际将被存储为Class，没有任何参数。因此，当你在使用它时，例如在创建数组时，Array.newInstance()实际上并未拥有kind所蕴含的类型信息，因此这不会产生具体的结果，所以必须转型，这将产生一条令你无法满意的警告。

注意，对于在泛型中创建数组，使用Array.newInstance()是推荐的方式。

如果我们要创建一个容器而不是数组，情况就有些不同了：

![411-2](../Images/image03227.jpeg)

编译器不会给出任何警告，尽管我们（从擦除中）知道在create()内部的new ArrayList<T>中的<T>被移除了——在运行时，这个类的内部没有任何<T>，因此这看起来毫无意义。但是如果你遵从这种思路，并将这个表达式改为new ArrayList()，编译器就会给出警告。

在本例中，这是否真的毫无意义呢？如果返回list之前，将某些对象放入其中，就像下面这样，情况又会如何呢？

![411-3](../Images/image03228.jpeg)

即使编译器无法知道有关create()中的T的任何信息，但是它仍旧可以在编译期确保你放置到result中的对象具有T类型，使其适合ArrayList<T>。因此，即使擦除在方法或类内部移除了有关实际类型的信息，编译器仍旧可以确保在方法或类中使用的类型的内部一致性。

因为擦除在方法体中移除了类型信息，所以在运行时的问题就是边界：即对象进入和离开方法的地点。这些正是编译器在编译期执行类型检查并插入转型代码的地点。请考虑下面的非泛型示例：

![411-4](../Images/image03229.jpeg)

如果用javap -c SimpleHolder反编译这个类，就可以得到下面的（经过编辑的）内容：

![412-2](../Images/image03230.jpeg)

set()和get()方法将直接存储和产生值，而转型是在调用get()的时候接受检查的。

现在将泛型合并到上面的代码中：

![412-3](../Images/image03231.jpeg)

从get()返回之后的转型消失了，但是我们还知道传递给set()的值在编译期会接受检查。下面是相关的字节码：

![412-4](../Images/image03232.jpeg)

所产生的字节码是相同的。对进入set()的类型进行检查是不需要的，因为这将由编译器执行。而对从get()返回的值进行转型仍旧是需要的，但这与你自己必须执行的操作是一样的——此处它将由编译器自动插入，因此你写入（和读取）的代码的噪声将更小。

由于所产生的get()和set()的字节码相同，所以在泛型中的所有动作都发生在边界处——对传递进来的值进行额外的编译期检查，并插入对传递出去的值的转型。这有助于澄清对擦除的混淆，记住，“边界就是发生动作的地方。”