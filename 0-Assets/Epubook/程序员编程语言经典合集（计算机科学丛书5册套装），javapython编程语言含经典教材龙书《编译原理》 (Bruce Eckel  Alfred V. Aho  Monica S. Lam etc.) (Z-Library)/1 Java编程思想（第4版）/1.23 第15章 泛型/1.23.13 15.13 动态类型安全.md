## 15.13　动态类型安全

因为可以向Java SE5之前的代码传递泛型容器，所以旧式代码仍旧有可能会破坏你的容器，Java SE5的java.util.Collections中有一组便利工具，可以解决在这种强况下的类型检查问题，它们是：静态方法checkedCollection()、checkedList()、checkedMap()、checkedSet()、checkedSortedMap()和checkedSortedSet()。这些方法每一个都会将你希望动态检查的容器当作第一个参数接受，并将你希望强制要求的类型作为第二个参数接受。

受检查的容器在你试图插入类型不正确的对象时抛出ClassCastException，这与泛型之前的（原生）容器形成了对比，对于后者来说，当你将对象从容器中取出时，才会通知你出现了问题。在后一种情况中，你知道存在问题，但是不知道罪魁祸首在哪里，如果使用受检查的容器，就可以发现谁在试图插入不良对象。

让我们用受检查的容器来看看“将猫插入到狗列表中”这个问题。这里，oldStyleMethod()表示遗留代码，因为它接受的是原生的List，而@SuppressWarnings（“unchecked”）注解对于压制所产生的警告是必需的：

![443-1](../Images/image03298.jpeg)

运行这个程序时，你会发现插入一个Cat对于dogs1来说没有任何问题，而dogs2立即会在这个错误类型的插入操作上抛出一个异常。还可以看到，将导出类型的对象放置到将要检查基类型的受检查容器中是没有问题的。

练习35：（1）修改CheckedList.java，使其使用本章中定义的Coffee类。