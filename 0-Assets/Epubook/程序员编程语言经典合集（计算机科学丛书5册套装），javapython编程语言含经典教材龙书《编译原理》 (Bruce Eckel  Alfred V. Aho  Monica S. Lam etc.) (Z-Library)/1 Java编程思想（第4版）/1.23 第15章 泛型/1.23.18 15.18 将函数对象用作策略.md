## 15.18　将函数对象用作策略

最后一个示例通过使用前面一节描述的适配器方式创建了真正泛化的代码。这个示例开始时是一种尝试，要创建一个元素序列的总和，这些元素可以是任何可以计算总和的类型，但是，后来这个示例使用功能型编程风格，演化成了可以执行通用的操作。

如果只查看尝试添加对象的过程，就会看到这是在多个类中的公共操作，但是这个操作没有在任何我们可以指定的基类中表示——有时甚至可以使用“+”操作府，而其他时间可以使用某种add方法。这是在试图编写泛化代码的时候通常会碰到的情况，因为你想将这些代码应用于多个类上——特别是，像本例一样，作用于多个已经存在且我们不能“修正”的类上。即使你可以将这种情况窄化到Number的子类，这个超类也不包括任何有关“可添加性”的东西。

解决方案是使用策略设计模式，这种设计模式可以产生更优雅的代码，因为它将“变化的事物”完全隔离到了一个函数对象中[^10]。函数对象就是在某种程度上行为像函数的对象——一般地，会有一个相关的方法（在支持操作符重载的语言中，可以创建对这个方法的调用，而这个调用看起来就和普通的方法调用一样）。函数对象的价值就在于，与普通方法不同，它们可以传递出去，并且还可以拥有在多个调用之间持久化的状态。当然，可以用类中的任何方法来实现与此相似的操作，但是（与使用任何设计模式一样）函数对象主要是由其目的来区别的。这里的目的就是要创建某种事物，使它的行为就像是一个可以传递出去的单个方法一样，这样，它就和策略设计模式紧耦合了，有时甚至无法区分。

尽管可以发现我使用了大量的设计模式，但是在这里它们之间的界限是模糊的：我们在创建执行适配操作的函数对象，而它们将被传递到用作策略的方法中。

通过采用这种方式，我添加了最初着手创建的各种类型的泛型方法，以及其他的泛型方法。下面是产生的结果：

![460-1](../Images/image03322.jpeg)

![461-1](../Images/image03323.jpeg)

![462-1](../Images/image03324.jpeg)

我是从为不同类型的函数对象定义接口开始的，这些接口都是按需创建的，因为我为每个接口都开发了不同的方法，并发现了每个接口的需求。Combiner类是由一位不知名的作者在我的Web网站上贴出的文章建议构建的。Combiner抽象掉了将两个对象添加在一起的具体细节，并且只是声明它们在某种程度上被结合在一起。因此，可以看到，IntegerAdder和IntegerSubstract可以是Combiner类型。

UnaryFunction接受单一的参数，并产生一个结果；这个参数和结果不需要是相同的类型。Collector被用作“收集参数”，并且当你完成时，可以从中抽取结果。UnaryPredicate将产生一个boolean类型的结果。还可以创建其他类型的函数对象，但是这些已经足够说明问题了。

Functional类包含大量的泛型方法，它们可以将函数对象应用于序列。reduce()将Combiner中的函数应用于序列中的每个元素，以产生单一的结果。

foreach()接受一个Collector，并将其函数应用于每个元素，但同时会忽略每次函数调用的结果。这只能被称为是副作用（这不是“功能型”编程风格，但仍旧是有用的），或者我们可以让Collector维护内部状态，从而变成一个收集参数，就像在本例中看到的那样。

transform()通过在序列中的每个对象上调用UnaryFunction，并捕获调用结果，来产生一个列表。

最后，filter()将UnaryPredicate应用到序列中的每个对象上，并将那些返回true的对象存储到一个List中。

可以定义附加的泛型函数，例如，C++ STL就具有很多这类函数。在诸如JGA（Generic Algorithms for Java）这样的开源类库中，这个问题也解决了。

在C++中，潜在类型机制将在你调用函数时负责协调各个操作，但是在Java中，我们需要编写函数对象来将泛型方法适配为我们特定的需求。因此，这个类接下来的部分展示了函数对象的各种不同的实现。例如，注意，IntegerAdder和BigDecimalAdder通过为它们特定的类型调用恰当的方法，从而解决了相同的问题，即添加两个对象。因此，这是适配器模式和策略模式的结合。

在main()中，你可以看到，在每个方法调用中，都会传递一个序列和适当的函数对象。还有大量的、可能会相当复杂的表达式，例如：

![463-1](../Images/image03325.jpeg)

这将通过选取li中大于4的所有元素而产生一个列表，然后将MultiplyingIntegerCollector()应用于所产生的列表，并抽取result()。我不会再解释剩余代码的细节了，通过通读它们你就可以了解它们的作用。

练习42：（5）创建两个独立的类，它们没有任何共同的东西。每个类都应该持有一个值，并至少有产生这个值和在这个值上执行修改的方法。修改Functional.java，使它可以在由你的类构成的集合上执行函数型操作（这些操作不必像Functional.java中的操作那样是算术型的）。