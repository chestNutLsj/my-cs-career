### 15.11.1　任何基本类型都不能作为类型参数

正如本章早先提到过的，你将在Java泛型中发现的限制之一是，不能将基本类型用作类型参数。因此，不能创建ArrayList<int>之类的东西。

解决之道是使用基本类型的包装器类以及Java SE5的自动包装机制。如果创建一个ArrayList<Integer>，并将基本类型int应用于这个容器，那么你将发现自动包装机制将自动地实现int到Integer的双向转换——因此，这几乎就像是有一个ArrayList<int>一样：

![433-1](../Images/image03267.jpeg)

注意，自动包装机制甚至允许用foreach语法来产生int。

通常，这种解决方案工作得很好——能够成功地存储和读取int，有一些转换碰巧在发生的同时会对你屏蔽掉。但是，如果性能成为了问题，就需要使用专门适配基本类型的容器版本。Org.apache.commons.collections.primitives就是一种开源的这类版本。

下面是另外一种方式，它可以创建持有Byte的Set：

![433-2](../Images/image03268.jpeg)

注意，自动包装机制解决了一些问题，但并不是解决了所有问题。下面的示例展示了一个泛型的Generator接口，它指定next()方法返回一个具有其参数类型的对象。FArray类包含一个泛型方法，它通过使用生成器在数组中填充对象（这使得类泛型在本例中无法工作，因为这个方法是静态的）。Generator实现来自第16章，并且在main()中，可以看到FArray.fill()使用它在数组中填充对象：

![433-3](../Images/image03269.jpeg)

![434-1](../Images/image03270.jpeg)

由于RandomGenerator.Integer实现了Generator<Integer>，所以我的希望是自动包装机制可以自动地将next()的值从Integer转换为int。但是，自动包装机制不能应用于数组，因此这无法工作。

练习30：（2）为每一种基本类型的包装器类型都创建一个Holder，并展示自动包装和自动拆包机制对每个实例的set()和get()方法都起作用。