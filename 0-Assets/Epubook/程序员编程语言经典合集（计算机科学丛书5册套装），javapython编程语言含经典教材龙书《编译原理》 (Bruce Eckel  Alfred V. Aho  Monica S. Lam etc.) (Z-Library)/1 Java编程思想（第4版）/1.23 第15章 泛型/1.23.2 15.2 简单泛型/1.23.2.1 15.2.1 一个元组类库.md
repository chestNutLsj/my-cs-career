### 15.2.1　一个元组类库

仅一次方法调用就能返回多个对象，你应该经常需要这样的功能吧。可是return语句只允许返回单个对象，因此，解决办法就是创建一个对象，用它来持有想要返回的多个对象。当然，可以在每次需要的时候，专门创建一个类来完成这样的工作。可是有了泛型，我们就能够一次性地解决该问题，以后再也不用在这个问题上浪费时间了。同时，我们在编译期就能确保类型安全。

这个概念称为元组（tuple），它是将一组对象直接打包存储于其中的一个单一对象。这个容器对象允许读取其中元素，但是不允许向其中存放新的对象。（这个概念也称为数据传送对象，或信使。）

通常，元组可以具有任意长度，同时，元组中的对象可以是任意不同的类型。不过，我们希望能够为每一个对象指明其类型，并且从容器中读取出来时，能够得到正确的类型。要处理不同长度的问题，我们需要创建多个不同的元组。下面的程序是一个2维元组，它能够持有两个对象：

![387-2](../Images/image03181.jpeg)

构造器捕获了要存储的对象，而toString()是一个便利函数，用来显示列表中的值。注意，元组隐含地保持了其中元素的次序。

第一次阅读上面的代码时，你也许会想，这不是违反了Java编程的安全性原则吗？first和second应该声明为private，然后提供getFirst()和getSecond()之类的访问方法才对呀？让我们仔细看看这个例子中的安全性：客户端程序可以读取first和second对象，然后可以随心所欲地使用这两个对象。但是，它们却无法将其他值赋予first或second。因为final声明为你买了相同的安全保险，而且这种格式更简洁明了。

还有另一种设计考虑，即你确实希望允许客户端程序员改变first或second所引用的对象。然而，采用以上的形式无疑是更安全的做法，这样的话，如果程序员想要使用具有不同元素的元组，就强制要求他们另外创建一个新的TwoTuple对象。

我们可以利用继承机制实现长度更长的元组。从下面的例子中可以看到，增加类型参数是件很简单的事情：

![388-2](../Images/image03182.jpeg)

为了使用元组，你只需定义一个长度适合的元组，将其作为方法的返回值，然后在return语句中创建该元组，并返回即可。

![389-1](../Images/image03183.jpeg)

由于有了泛型，你可以很容易地创建元组，令其返回一组任意类型的对象。而你所要做的，只是编写表达式而已。

通过ttsi.first = "there"语句的错误，我们可以看出，final声明确实能够保护public元素，在对象被构造出来之后，声明为final的元素便不能被再赋予其他值了。

在上面的程序中，new表达式确实有点罗嗦。本章稍后会介绍，如何利用泛型方法简化这样的表达式。

练习3：（1）使用泛型编写一个SixTuple类，并测试它。

练习4：（3）“泛型化”innerclasses/Sequence.java类。