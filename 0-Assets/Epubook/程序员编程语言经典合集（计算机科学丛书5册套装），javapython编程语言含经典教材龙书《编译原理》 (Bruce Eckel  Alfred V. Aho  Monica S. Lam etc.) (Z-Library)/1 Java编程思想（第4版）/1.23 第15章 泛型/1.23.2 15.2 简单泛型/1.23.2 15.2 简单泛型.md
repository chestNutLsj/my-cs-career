## 15.2　简单泛型

有许多原因促成了泛型的出现，而最引人注目的一个原因，就是为了创造容器类。（关于容器类，你可以参考第11章和第17章这两章。）容器，就是存放要使用的对象的地方。数组也是如此，不过与简单的数组相比，容器类更加灵活，具备更多不同的功能。事实上，所有的程序，在运行时都要求你持有一大堆对象，所以，容器类算得上最具重用性的类库之一。

我们先来看看一个只能持有单个对象的类。当然了，这个类可以明确指定其持有的对象的类型：

![386-1](../Images/image03178.jpeg)

不过，这个类的可重用性就不怎么样了，它无法持有其他类型的任何对象。我们可不希望为碰到的每个类型都编写一个新的类。

在Java SE5之前，我们可以让这个类直接持有Object类型的对象：

![386-2](../Images/image03179.jpeg)

现在，Holder2可以存储任何类型的对象，在这个例子中，只用了一个Holder2对象，却先后三次存储了三种不同类型的对象。

有些情况下，我们确实希望容器能够同时持有多种类型的对象。但是，通常而言，我们只会使用容器来存储一种类型的对象。泛型的主要目的之一就是用来指定容器要持有什么类型的对象，而且由编译器来保证类型的正确性。

因此，与其使用Object，我们更喜欢暂时不指定类型，而是稍后再决定具体使用什么类型。要达到这个目的，需要使用类型参数，用尖括号括住，放在类名后面。然后在使用这个类的时候，再用实际的类型替换此类型参数。在下面的例子中，T就是类型参数：

![387-1](../Images/image03180.jpeg)

现在，当你创建Holder3对象时，必须指明想持有什么类型的对象，将其置于尖括号内。就像main()中那样。然后，你就只能在Holder3中存入该类型（或其子类，因为多态与泛型不冲突）的对象了。并且，在你从Holder3中取出它持有的对象时，自动地就是正确的类型。

这就是Java泛型的核心概念：告诉编译器想使用什么类型，然后编译器帮你处理一切细节。

一般而言，你可以认为泛型与其他的类型差不多，只不过它们碰巧有类型参数罢了。稍后我们会看到，在使用泛型时，我们只需指定它们的名称以及类型参数列表即可。

练习1：（1）配合typeinfo.pets类库，用Holder3来证明，如果指定Holder3可以持有某个基类类型，那么它也能持有导出类型。

练习2：（1）创建一个Holder类，使其能够持有具有相同类型的3个对象，并提供相应的读写方法访问这些对象，以及一个可以初始化其持有的3个对象的构造器。