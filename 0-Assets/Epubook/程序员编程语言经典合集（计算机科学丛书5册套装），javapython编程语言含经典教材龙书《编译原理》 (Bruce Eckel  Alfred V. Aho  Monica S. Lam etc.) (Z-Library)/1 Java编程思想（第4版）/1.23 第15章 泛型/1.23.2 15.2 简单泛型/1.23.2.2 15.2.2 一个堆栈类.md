### 15.2.2　一个堆栈类

接下来我们看一个稍微复杂一点的例子：传统的下推堆栈。在第11章中，我们看到，这个堆栈是作为net.mindview.util.Stack类，用一个LinkedList实现的。在那个例子中，LinkedList本身已经具备了创建堆栈所必需的方法，而Stack可以通过两个泛型的类Stack<T>和LinkedList<T>的组合来创建。在那个示例中，我们可以看出，泛型类型也就是另一种类型罢了（稍候我们会看到一些例外的情况）。

现在我们不用LinkedList，来实现自己的内部链式存储机制。

![390-1](../Images/image03184.jpeg)

内部类Node也是一个泛型，它拥有自己的类型参数。

这个例子使用了一个末端哨兵（end sentinel）来判断堆栈何时为空。这个末端哨兵是在构造LinkedStack时创建的。然后，每调用一次push()方法，就会创建一个Node<T>对象，并将其链接到前一个Node<T>对象。当你调用pop()方法时，总是返回top.item，然后丢弃当前top所指的Node<T>，并将top转移到下一个Node<T>，除非你已经碰到了末端哨兵，这时候就不再移动top了。如果已经到了末端，客户端程序还继续调用pop()方法，它只能得到null，说明堆栈已经空了。

练习5：（2）移除Node类上的类型参数，并修改LinkedStack.java的代码，证明内部类可以访问其外部类的类型参数。