### 15.10.4　捕获转换

有一种情况特别需要使用<？>而不是原生类型。如果向一个使用<？>的方法传递原生类型，那么对编译器来说，可能会推断出实际的类型参数，使得这个方法可以回转并调用另一个使用这个确切类型的方法。下面的示例演示了这种技术，它被称为捕获转换，因为未指定的通配符类型被捕获，并被转换为确切类型。这里，有关警告的注释只有在@SuppressWarnings注解被移除之后才能起作用：

![432-1](../Images/image03266.jpeg)

f1()中的类型参数都是确切的，没有通配符或边界。在f2()中，Holder参数是一个无界通配符，因此它看起来是未知的。但是，在f2()中，f1()被调用，而f1()需要一个已知参数。这里所发生的是：参数类型在调用f2()的过程中被捕获，因此它可以在对f1()的调用中被使用。

你可能想知道，这项技术是否可以用于写入，但是这要求要在传递Holder<？>时同时传递一个具体类型。捕获转换只有在这样的情况下可以工作：即在方法内部，你需要使用确切的类型。注意，不能从f2()中返回T，因为T对于f2()来说是未知的。捕获转换十分有趣，但是非常受限。

练习29：（5）创建一个泛型方法，它接受一个Holder<List<？>>参数。对于这个Holder以及这个List，确定哪些方法是可以调用的，哪些方法是不可以调用的。用List<Holder<？>>作为参数重复这个练习。