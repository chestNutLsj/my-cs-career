### 15.10.3　无界通配符

无界通配符<？>看起来意味着“任何事物”，因此使用无界通配符好像等价于使用原生类型。事实上，编译器初看起来是支持这种判断的：

![428-1](../Images/image03261.jpeg)

有很多情况都和你在这里看到的情况类似，即编译器很少关心使用的是原生类型还是<？>。在这些情况中，<？>可以被认为是一种装饰，但是它仍旧是很有价值的，因为，实际上，它是在声明：“我是想用Java的泛型来编写这段代码，我在这里并不是要用原生类型，但是在当前这种情况下，泛型参数可以持有任何类型。”

第二个示例展示了无界通配符的一个重要应用。当你在处理多个泛型参数时，有时允许一个参数可以是任何类型，同时为其他参数确定某种特定类型的这种能力会显得很重要：

![429-1](../Images/image03262.jpeg)

但是，当你拥有的全都是无界通配符时，就像在Map<？，？>中看到的那样，编译器看起来就无法将其与原生Map区分开了。另外，UnboundedWildcards.java展示了编译器处理List<？>和List<？extends Object>时是不同的。

令人困惑的是，编译器并非总是关注像List和List<？>之间的这种差异，因此它们看起来就像是相同的事物。因为，事实上，由于泛型参数将擦除到它的第一个边界，因此List<？>看起来等价于List<Object>，而List实际上也是List<Object>——除非这些语句都不为真。List实际上表示“持有任何Object类型的原生List”，而List<？>表示“具有某种特定类型的非原生List，只是我们不知道那种类型是什么。”

编译器何时才会关注原生类型和涉及无界通配符的类型之间的差异呢？下面的示例使用了前面定义的Holder<T>类，它包含接受Holder作为参数的各种方法，但是它们具有不同的形式：作为原生类型，具有具体的类型参数以及具有无界通配符参数：

![429-2](../Images/image03263.jpeg)

![430-1](../Images/image03264.jpeg)

![431-1](../Images/image03265.jpeg)

在rawArgs()中，编译器知道Holder是一个泛型类型，因此即使它在这里被表示成一个原生类型，编译器仍旧知道向set()传递一个Object是不安全的。由于它是原生类型，你可以将任何类型的对象传递给set()，而这个对象将被向上转型为Object。因此，无论何时，只要使用了原生类型，都会放弃编译期检查。对get()的调用说明了相同的问题：没有任何T类型的对象，因此结果只能是一个Object。

人们很自然地会开始考虑原生Holder与Holder<？>是大致相同的事物。但是unboundedArg()强调它们是不同的——它揭示了相同的问题，但是它将这些问题作为错误而不是警告报告，因为原生Holder将持有任何类型的组合，而Holder<？>将持有具有某种具体类型的同构集合，因此不能只是向其中传递Object。

在exact1()和exact2()中，你可以看到使用了确切的泛型参数——没有任何通配符。你将看到，exact2()与exact1()具有不同的限制，因为它有额外的参数。

在wildSubtype()中，在Holder类型上的限制被放松为包括持有任何扩展自T的对象的Holder。这还是意味着如果T是Fruit，那么holder可以是Holder<Apple>，这是合法的。为了防止将Orange放置到Holder<Apple>中，对set()的调用（或者对任何接受这个类型参数为参数的方法的调用）都是不允许的。但是，你仍旧知道任何来自Holder<？extends Fruit>的对象至少是Fruit，因此get()（或者任何将产生具有这个类型参数的返回值的方法）都是允许的。

wildSupertype()展示了超类型通配符，这个方法展示了与wildSubtype()相反的行为：holder可以是持有任何T的基类型的容器。因此，set()可以接受T，因为任何可以工作于基类的对象都可以多态地作用于导出类（这里就是T）。但是，尝试着调用get()是没有用的，因为由holder持有的类型可以是任何超类型，因此唯一安全的类型就是Object。

这个示例还展示了对于在unbounded()中使用无界通配符能够做什么不能做什么所做出的限制。对于迁移兼容性，rawArgs()将接受所有Holder的不同变体，而不会产生警告。unboundedArg()方法也可以接受相同的所有类型，尽管如前所述，它在方法体内部处理这些类型的方式并不相同。

如果向接受“确切”泛型类型（没有通配符）的方法传递一个原生Holder引用，就会得到一个警告，因为确切的参数期望得到在原生类型中并不存在的信息。如果向exact1()传递一个无界引用，就不会有任何可以确定返回类型的类型信息。

可以看到，exact2()具有最多的限制，因为它希望精确地得到一个Holder<T>，以及一个具有类型T的参数，正由于此，它将产生错误或警告，除非提供确切的参数。有时，这样做很好，但是如果它过于受限，那么就可以使用通配符，这取决于是否想要从泛型参数中返回类型确定的返回值（就像在wildSubtype()中看到的那样），或者是否想要向泛型参数传递类型确定的参数（就像在wildSupertype()中看到的那样）。

因此，使用确切类型来替代通配符类型的好处是，可以用泛型参数来做更多的事，但是使用通配符使得你必须接受范围更宽的参数化类型作为参数。因此，必须逐个情况地权衡利弊，找到更适合你的需求的方法。