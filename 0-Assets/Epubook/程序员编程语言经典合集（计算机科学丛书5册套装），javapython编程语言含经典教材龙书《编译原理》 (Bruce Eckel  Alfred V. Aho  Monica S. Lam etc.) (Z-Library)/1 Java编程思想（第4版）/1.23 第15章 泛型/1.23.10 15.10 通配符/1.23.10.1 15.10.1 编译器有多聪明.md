### 15.10.1　编译器有多聪明

现在，你可能会猜想自己被阻止去调用任何接受参数的方法，但是请考虑下面的程序：

![424-2](../Images/image03256.jpeg)

你可以看到，对contains()和indexOf()的调用，这两个方法都接受Apple对象作为参数，而这些调用都可以正常执行。这是否意味着编译器实际上将检查代码，以查看是否有某个特定的方法修改了它的对象？

通过查看ArrayList的文档，我们可以发现，编译器并没有这么聪明。尽管add()将接受一个具有泛型参数类型的参数，但是contains()和indexOf()将接受Object类型的参数。因此当你指定一个ArrayList<？extends Fruit>时，add()的参数就变成了“？Extends Fruit”。从这个描述中，编译器并不能了解这里需要Fruit的哪个具体子类型，因此它不会接受任何类型的Fruit。如果先将Apple向上转型为Fruit，也无关紧要——编译器将直接拒绝对参数列表中涉及通配符的方法（例如add()）的调用。

在使用contains()和indexOf()时，参数类型是Object，因此不涉及任何通配符，而编译器也将允许这个调用。这意味着将由泛型类的设计者来决定哪些调用是“安全的”，并使用Object类型作为其参数类型。为了在类型中使用了通配符的情况下禁止这类调用，我们需要在参数列表中使用类型参数。

可以在一个非常简单的Holder类中看到这一点：

![425-1](../Images/image03257.jpeg)

Holder有一个接受T类型对象的set()方法，一个get()方法，以及一个接受Object对象的equals()方法。正如你已经看到的，如果创建了一个Holder<Apple>，不能将其向上转型为Holder<Fruit>，但是可以将其向上转型为Holder<？extends Fruit>。如果调用get()，它只会返回一个Fruit——这就是在给定“任何扩展自Fruit的对象”这一边界之后，它所能知道的一切了。如果能够了解更多的信息，那么你可以转型到某种具体的Fruit类型，而这不会导致任何警告，但是你存在着得到ClassCastException的风险。set()方法不能工作于Apple或Fruit，因为set()的参数也是“？Extends Fruit”，这意味着它可以是任何事物，而编译器无法验证“任何事物”的类型安全性。

但是，equals()方法工作良好，因为它将接受Object类型而并非T类型的参数。因此，编译器只关注传递进来和要返回的对象类型，它并不会分析代码，以查看是否执行了任何实际的写入和读取操作。