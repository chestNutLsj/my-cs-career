### 15.10.2　逆变

还可以走另外一条路，即使用超类型通配符。这里，可以声明通配符是由某个特定类的任何基类来界定的，方法是指定<？super MyClass>，甚至或者使用类型参数：<？super T>（尽管你不能对泛型参数给出一个超类型边界；即不能声明<T super MyClass>）。这使得你可以安全地传递一个类型对象到泛型类型中。因此，有了超类型通配符，就可以向Collection写入了：

![426-1](../Images/image03258.jpeg)

参数Apple是Apple的某种基类型的List，这样你就知道向其中添加Apple或Apple的子类型是安全的。但是，既然Apple是下界，那么你可以知道向这样的List中添加Fruit是不安全的，因为这将使这个List敞开口子，从而可以向其中添加非Apple类型的对象，而这是违反静态类型安全的。

因此你可能会根据如何能够向一个泛型类型“写入”（传递给一个方法），以及如何能够从一个泛型类型中“读取”（从一个方法中返回），来着手思考子类型和超类型边界。

超类型边界放松了在可以向方法传递的参数上所作的限制：

![426-2](../Images/image03259.jpeg)

writeExact()方法使用了一个确切参数类型（无通配符）。在f1()中，可以看到这工作良好——只要你只向List<Apple>中放置Apple。但是，writeExact()不允许将Apple放置到List<Fruit>中，即使知道这应该是可以的。

在writeWithWildcard()中，其参数现在是List<？super T>，因此这个List将持有从T导出的某种具体类型，这样就可以安全地将一个T类型的对象或者从T导出的任何对象作为参数传递给List的方法。在f2()中可以看到这一点，在这个方法中我们仍旧可以像前面那样，将Apple放置到List<Apple>中，但是现在我们还可以如你所期望的那样，将Apple放置到List<Fruit>中。

我们可以执行下面这个相同的类型分析，作为对协变和通配符的一个复习：

![427-1](../Images/image03260.jpeg)

与前面一样，第一个方法readExact()使用了精确的类型。因此如果使用这个没有任何通配符的精确类型，就可以向List中写入和读取这个精确类型。另外，对于返回值，静态的泛型方法readExact()可以有效地“适应”每个方法调用，并能够从List<Apple>中返回一个Apple，从List<Fruit>中返回一个Fruit，就像在f1()中看到的那样。因此，如果可以摆脱静态泛型方法，那么当只是读取时，就不需要协变类型了。

但是，如果有一个泛型类，那么当你创建这个类的实例时，要为这个类确定参数。就像在f2()中看到的，fruitReader实例可以从List<Fruit>中读取一个Fruit，因为这就是它的确切类型。但是List<Apple>还应该产生Fruit对象，而fruitReader不允许这么做。

为了修正这个问题，CovariantReader.readCovcariant()方法将接受List<？extends T>，因此，从这个列表中读取一个T是安全的（你知道在这个列表中的所有对象至少是一个T，并且可能是从T导出的某种对象）。在f3()中，你可以看到现在可以从List<Apple>中读取Fruit了。

练习28：（4）创建一个泛型类Generic1<T>，它只有一个方法，将接受一个T类型的参数。创建第二个泛型类Generic2<T>，它也只有一个方法，将返回类型T的参数。编写一个泛型方法，它具有一个调用第一个泛型类的方法的逆变参数。编写第二个泛型方法，它具有一个调用第二个泛型类的方法的协变参数。使用typeinfo.pets类库进行测试。