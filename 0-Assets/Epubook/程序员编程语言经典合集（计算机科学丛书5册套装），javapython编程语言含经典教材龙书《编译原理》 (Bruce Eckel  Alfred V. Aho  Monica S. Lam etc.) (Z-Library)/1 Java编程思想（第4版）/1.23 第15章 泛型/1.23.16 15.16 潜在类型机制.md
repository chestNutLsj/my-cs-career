## 15.16　潜在类型机制

在本章的开头介绍过这样的思想，即要编写能够尽可能广泛地应用的代码。为了实现这一点，我们需要各种途径来放松对我们的代码将要作用的类型所作的限制，同时不丢失静态类型检查的好处。然后，我们就可以编写出无需修改就可以应用于更多情况的代码，即更加“泛化”的代码。

Java泛型看起来是向这一方向迈进了一步。当你在编写或使用只是持有对象的泛型时，这些代码将可以工作于任何类型（除了基本类型，尽管正如你所见到的，自动包装机制可以克服这一点）。或者，换个角度讲，“持有器”泛型能够声明：“我不关心你是什么类型”。如果代码不关心它将要作用的类型，那么这种代码就可以真正地应用于任何地方，并因此而相当“泛化”。

还是正如你所见到的，当要在泛型类型上执行操作（即调用Object方法之前的操作）时，就会产生问题，因为擦除要求指定可能会用到的泛型类型的边界，以安全地调用代码中的泛型对象上的具体方法。这是对“泛化”概念的一种明显的限制，因为必须限制你的泛型类型，使它们继承自特定的类，或者实现特定的接口。在某些情况下，你最终可能会使用普通类或普通接口，因为限定边界的泛型可能会和指定类或接口没有任何区别。

某些编程语言提供的一种解决方案称为潜在类型机制或结构化类型机制，而更古怪的术语称为鸭子类型机制，即“如果它走起来像鸭子，并且叫起来也像鸭子，那么你就可以将它当作鸭子对待。”鸭子类型机制变成了一种相当流行的术语，可能是因为它不像其他的术语那样承载着历史的包袱。

泛型代码典型地将在泛型类型上调用少量方法，而具有潜在类型机制的语言只要求实现某个方法子集，而不是某个特定类或接口，从而放松了这种限制（并且可以产生更加泛化的代码）。正由于此，潜在类型机制使得你可以横跨类继承结构，调用不属于某个公共接口的方法。因此，实际上一段代码可以声明：“我不关心你是什么类型，只要你可以speak()和sit()即可。”由于不要求具体类型，因此代码就可以更加泛化。

潜在类型机制是一种代码组织和复用机制。有了它编写出的代码相对于没有它编写出的代码，能够更容易地复用。代码组织和复用是所有计算机编程的基本手段：编写一次，多次使用，并在一个位置保存代码。因为我并未被要求去命名我的代码要操作于其上的确切接口，所以，有了潜在类型机制，我就可以编写更少的代码，并更容易地将其应用于多个地方。

两种支持潜在类型机制的语言实例是Python（可以从www.Python.org免费下载）和C++[^6]。Python是动态类型语言（事实上所有的类型检查都发生在运行时），而C++是静态类型语言（类型检查发生在编译期），因此潜在类型机制不要求静态或动态类型检查。

如果我们将上面的描述用Python来表示，如下所示：

![450-1](../Images/image03310.jpeg)

Python使用缩进来确定作用域（因此不需要任何花括号），而冒号将表示新的作用域的开始。“#”表示注释到行尾，就像Java中的“//”。类的方法需要显式地指定this引用的等价物作为第一个参数，按惯例成为self。构造器调用不要求任何类型的“new”关键字，并且Python允许正则（非成员）函数，就像perform()所表明的那样。

注意，在perform（anything）中，没有任何针对anything的类型，anything只是一个标识符，它必须能够执行perform()期望它执行的操作，因此这里隐含着一个接口。但是你从来都不必显式地写出这个接口——它是潜在的。perform()不关心其参数的类型，因此我可以向它传递任何对象，只要该对象支持speak()和sit()方法。如果传递给perform()的对象不支持这些操作，那么将会得到运行时异常。

我们可以用C++产生相同的效果：

![451-1](../Images/image03311.jpeg)

在Python和C++中，Dog和Robot没有任何共同的东西，只是碰巧有两个方法具有相同的签名。从类型的观点看，它们是完全不同的类型。但是，perform()不关心其参数的具体类型，并且潜在类型机制允许它接受这两种类型的对象。

C++确保了它实际上可以发送的那些消息，如果试图传递错误类型，编译器就会给你一个错误消息（这些错误消息从历史上看是相当可怕和冗长的，而主要原因是因为C++的模版名声欠佳）。尽管它们是在不同时期实现这一点的，C++在编译期，而Python在运行时，但是这两种语言都可以确保类型不会被误用，因此被认为是强类型的[^7]。潜在类型机制没有损害强类型机制。

因为泛型是在这场竞赛的后期才添加到Java中的，因此没有任何机会可以去实现任何类型的潜在类型机制，因此Java没有对这种特性的支持。所以，初看起来，Java的泛型机制比支持潜在类型机制的语言更“缺乏泛化性”。[^8]例如，如果我们试图用Java实现上面的示例，那么就会被强制要求使用一个类或接口，并在边界表达式中指定它：

![452-1](../Images/image03312.jpeg)

但是要注意，perform()不需要使用泛型来工作，它可以被简单地指定为接受一个Performs对象：

![452-2](../Images/image03313.jpeg)

在本例中，泛型不是必需的，因为这些类已经被强制要求实现Performs接口。