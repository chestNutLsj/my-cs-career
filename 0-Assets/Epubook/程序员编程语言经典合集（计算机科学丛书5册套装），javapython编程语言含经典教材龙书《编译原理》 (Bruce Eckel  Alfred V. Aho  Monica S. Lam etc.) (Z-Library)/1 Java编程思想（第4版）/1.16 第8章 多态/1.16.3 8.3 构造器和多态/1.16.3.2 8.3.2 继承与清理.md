### 8.3.2　继承与清理

通过组合和继承方法来创建新类时，永远不必担心对象的清理问题，子对象通常都会留给垃圾回收器进行处理。如果确实遇到清理的问题，那么必须用心为新类创建dispose()方法（在这里我选用此名称；读者可以提出更好的）。并且由于继承的缘故，如果我们有其他作为垃圾回收一部分的特殊清理动作，就必须在导出类中覆盖dispose()方法。当覆盖被继承类的dispose()方法时，务必记住调用基类版本dispose()方法；否则，基类的清理动作就不会发生。下例就证明了这一点：

![192-1](../Images/image02873.jpeg)

![193-1](../Images/image02874.jpeg)

![194-1](../Images/image02875.jpeg)

层次结构中的每个类都包含Characteristic和Description这两种类型的成员对象，并且它们也必须被销毁。所以万一某个子对象要依赖于其他对象，销毁的顺序应该和初始化顺序相反。对于字段，则意味着与声明的顺序相反（因为字段的初始化是按照声明的顺序进行的）。对于基类（遵循C++中析构函数的形式），应该首先对其导出类进行清理，然后才是基类。这是因为导出类的清理可能会调用基类中的某些方法，所以需要使基类中的构件仍起作用而不应过早地销毁它们。从输出结果可以看到，Frog对象的所有部分都是按照创建的逆序进行销毁的。

在这个例子中可以看到，尽管通常不必执行清理工作，但是一旦选择要执行，就必须谨慎和小心。

练习12：（3）修改练习9，使其能够演示基类和导出类的初始化顺序。然后向基类和导出类中添加成员对象，并说明构建期间初始化发生的顺序。

在上面的示例中还应该注意到，Frog对象拥有其自己的成员对象。Frog对象创建了它自己的成员对象，并且知道它们应该存活多久（只要Frog存活着），因此Frog对象知道何时调用dispose()去释放其成员对象。然而，如果这些成员对象中存在于其他一个或多个对象共享的情况，问题就变得更加复杂了，你就不能简单地假设你可以调用dispose()了。在这种情况下，也许就必需使用引用计数来跟踪仍旧访问着共享对象的对象数量了。下面是相关的代码：

![194-2](../Images/image02876.jpeg)

![195-1](../Images/image02877.jpeg)

static long counter跟踪所创建的Shared的实例的数量，还可以为id提供数值。counter的类型是long而不是int，这样可以防止溢出（这只是一个良好实践，对于本书中的所有示例，这种计数器不可能发生溢出）。id是final的，因为我们不希望它的值在对象生命周期中被改变。

在将一个共享对象附着到类上时，必须记住调用addRef()，但是dispose()方法将跟踪引用数，并决定何时执行清理。使用这种技巧需要加倍地细心，但是如果你正在共享需要清理的对象，那么你就没有太多的选择余地了。

练习13：（3）在ReferenceCounting.java中添加一个finalize()方法，用来校验终止条件（查看第5章）。

练习14：（4）修改练习12，使得其某个成员对象变为具有引用计数的共享对象，并证明它可以正确运行。