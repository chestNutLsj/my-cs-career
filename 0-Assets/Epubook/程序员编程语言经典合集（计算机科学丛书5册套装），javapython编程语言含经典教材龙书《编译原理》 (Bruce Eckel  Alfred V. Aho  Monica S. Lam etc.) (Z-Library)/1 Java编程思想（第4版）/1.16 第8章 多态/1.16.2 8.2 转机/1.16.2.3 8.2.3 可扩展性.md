### 8.2.3　可扩展性

现在，让我们返回到“乐器”（Instrument）示例。由于有多态机制，我们可根据自己的需求对系统添加任意多的新类型，而不需更改tune()方法。在一个设计良好的OOP程序中，大多数或者所有方法都会遵循tune()的模型，而且只与基类接口通信。这样的程序是可扩展的，因为可以从通用的基类继承出新的数据类型，从而新添一些功能。那些操纵基类接口的方法不需要任何改动就可以应用于新类。

考虑一下：对于“乐器”的例子，如果我们向基类中添加更多的方法，并加入一些新类，将会出现什么情况呢？请看下图：

![187-1](../Images/image02866.jpeg)

事实上，不需要改动tune()方法，所有的新类都能与原有类一起正确运行。即使tune()方法是单独存放在某个文件中，并且在Instrument接口中添加了其他的新方法，tune()也不需再编译就能正确运行。下面是上图的具体实现：

![187-2](../Images/image02867.jpeg)

![188-1](../Images/image02868.jpeg)

新添加的方法what()返回一个带有类描述的String引用；另一个新添加的方法adjust()则提供每种乐器的调音方法。

在main()中，当我们将某种引用置入orchestra数组中，就会自动向上转型到Instrument。

可以看到，tune()方法完全可以忽略它周围代码所发生的全部变化，依旧正常运行。这正是我们期望多态所具有的特性。我们所做的代码修改，不会对程序中其他不应受到影响的部分产生破坏。换句话说，多态是一项让程序员“将改变的事物与未变的事物分离开来”的重要技术。

练习6：（1）修改Music3.java，使what()方法成为根Object的toString()方法。试用System.out.println()方法打印Instrument对象（不用向上转型）。

练习7：（2）向Music3.java添加一个新的类型Instrument，并验证多态性是否作用于所添加的新类型。

练习8：（2）修改Music3.java，使其可以像Shapes.java中的方式那样随机创建Instrument对象。

练习9：（3）创建Rodent（啮齿动物）：Mouse（老鼠），Gerbil（鼹鼠），Hamster（大颊鼠），等等这样一个的继承层次结构。在基类中，提供对所有的Rodent都通用的方法，在导出类中，根据特定的Rodent类型覆盖这些方法，以便它们执行不同的行为。创建一个Robent数组，填充不同的Rodent类型，然后调用基类方法，观察发生什么情况。

练习10：（3）创建一个包含两个方法的基类。在第一个方法中可以调用第二个方法。然后产生一个继承自该基类的导出类，且覆盖基类中的第二个方法。为该导出类创建一个对象，将它向上转型到基类型并调用第一个方法，解释发生的情况。