### 8.2.2　产生正确的行为

一旦知道Java中所有方法都是通过动态绑定实现多态这个事实之后，我们就可以编写只与基类打交道的程序代码了，并且这些代码对所有的导出类都可以正确运行。或者换一种说法，发送消息给某个对象，让该对象去断定应该做什么事。

面向对象程序设计中，有一个经典的例子就是“几何形状”（shape）。因为它很直观，所以经常用到；但不幸的是，它可能使初学者认为面向对象程序设计仅适用于图形化程序设计，实际当然不是这样。

在“几何形状”这个例子中，有一个基类Shape，以及多个导出类——如Circle、Square、Triangle等。这个例子之所以好用，是因为我们可以说“圆是一种几何形状”，这种说法也很容易被理解。下面的继承图展示它们之间的关系：

![184-1](../Images/image02861.jpeg)

向上转型可以像下面这条语句这么简单：

![184-2](../Images/image02862.jpeg)

这里，创建了一个Circle对象，并把得到的引用立即赋值给Shape，这样做看似错误（将一种类型赋值给另一种类型）；但实际上是没问题的，因为通过继承，Circle就是一种Shape。因此，编译器认可这条语句，也就不会产生错误信息。

假设你调用一个基类方法（它已在导出类中被覆盖）：

![184-3](../Images/image02863.jpeg)

你可能再次认为调用的是Shape的draw()，因为这毕竟是一个Shape引用，那么编译器是怎样知道去做其他的事情呢？由于后期绑定（多态），还是正确调用了Circle.draw()方法。

下面的例子稍微有所不同：

![185-1](../Images/image02864.jpeg)

![186-1](../Images/image02865.jpeg)

Shape基类为自它那里继承而来的所有导出类建立了一个公用接口——也就是说，所有形状都可以描绘和擦除。导出类通过覆盖这些定义，来为每种特殊类型的几何形状提供单独的行为。

RandomShapeGenerator是一种“工厂”（factory），在我们每次调用next()方法时，它可以为随机选择的Shape对象产生一个引用。请注意向上转型是在return语句里发生的。每个return语句取得一个指向某个Circle、Square或者Triangle的引用，并将其以Shape类型从next()方法中发送出去。所以无论我们在什么时候调用next()方法时，是绝对不可能知道具体类型到底是什么的，因为我们总是只能获得一个通用的Shape引用。

main()包含了一个Shape引用组成的数组，通过调用RandomShapeGenerator.next()来填入数据。此时，我们只知道自己拥有一些Shape，除此之外不会知道更具体的情况（编译器也不知道）。然而，当我们遍历这个数组，并为每个数组元素调用draw()方法时，与类型有关的特定行为会神奇般地正确发生，我们可以从运行该程序时所产生的输出结果中发现这一点。

随机选择几何形状是为了让大家理解：在编译时，编译器不需要获得任何特殊信息就能进行正确的调用。对draw()方法的所有调用都是通过动态绑定进行的。

练习2：（1）在几何图形的示例中添加@Override注解。

练习3：（1）在基类Shape.java中添加一个新方法，用于打印一条消息，但导出类中不要覆盖这个方法。请解释发生了什么。现在，在其中一个导出类中覆盖该方法，而在其他的导出类中不予覆盖，观察又有什么发生。最后，在所有的导出类中覆盖这个方法。

练习4：（2）向Shapes.java中添加一个新的Shape类型，并在main()方法中验证：多态对新类型的作用是否与在旧类型中的一样。

练习5：（1）以练习1为基础，在Cycle中添加wheels()方法，它将返回轮子的数量。修改ride()方法，让它调用wheels()方法，并验证多态起作用了。