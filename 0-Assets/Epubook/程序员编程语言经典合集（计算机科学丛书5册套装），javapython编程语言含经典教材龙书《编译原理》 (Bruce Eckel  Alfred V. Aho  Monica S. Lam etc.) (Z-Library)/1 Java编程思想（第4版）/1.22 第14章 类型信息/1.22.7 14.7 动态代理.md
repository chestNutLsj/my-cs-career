## 14.7　动态代理

代理是基本的设计模式之一，它是你为了提供额外的或不同的操作，而插入的用来代替“实际”对象的对象。这些操作通常涉及与“实际”对象的通信，因此代理通常充当着中间人的角色。下面是一个用来展示代理结构的简单示例：

![370-2](../Images/image03154.jpeg)

![371-1](../Images/image03155.jpeg)

因为consumer()接受的Interface，所以它无法知道正在获得的到底是RealObject还是SimpleProxy，因为这二者都实现了Interface。但是SimpleProxy已经被插入到了客户端和RealObject之间，因此它会执行操作，然后调用RealObject上相同的方法。

在任何时刻，只要你想要将额外的操作从“实际”对象中分离到不同的地方，特别是当你希望能够很容易地做出修改，从没有使用额外操作转为使用这些操作，或者反过来时，代理就显得很有用（设计模式的关键就是封装修改——因此你需要修改事务以证明这种模式的正确性）。例如，如果你希望跟踪对RealObject中的方法的调用，或者希望度量这些调用的开销，那么你应该怎样做呢？这些代码肯定是你不希望将其合并到应用中的代码，因此代理使得你可以很容易地添加或移除它们。

Java的动态代理比代理的思想更向前迈进了一步，因为它可以动态地创建代理并动态地处理对所代理方法的调用。在动态代理上所做的所有调用都会被重定向到单一的调用处理器上，它的工作是揭示调用的类型并确定相应的对策。下面是用动态代理重写的SimpleProxyDemo.java：

![371-2](../Images/image03156.jpeg)

![372-1](../Images/image03157.jpeg)

通过调用静态方法Proxy.newProxyInstance()可以创建动态代理，这个方法需要得到一个类加载器（你通常可以从已经被加载的对象中获取其类加载器，然后传递给它），一个你希望该代理实现的接口列表（不是类或抽象类），以及InvocationHandler接口的一个实现。动态代理可以将所有调用重定向到调用处理器，因此通常会向调用处理器的构造器传递给一个“实际”对象的引用，从而使得调用处理器在执行其中介任务时，可以将请求转发。

invoke()方法中传递进来了代理对象，以防你需要区分请求的来源，但是在许多情况下，你并不关心这一点。然而，在invoke()内部，在代理上调用方法时需要格外当心，因为对接口的调用将被重定向为对代理的调用。

通常，你会执行被代理的操作，然后使用Method.invoke()将请求转发给被代理对象，并传入必需的参数。这初看起来可能有些受限，就像你只能执行泛化操作一样。但是，你可以通过传递其他的参数，来过滤某些方法调用：

![372-2](../Images/image03158.jpeg)

![373-1](../Images/image03159.jpeg)

这里，我们只查看了方法名，但是你还可以查看方法签名的其他方面，甚至可以搜索特定的参数值。

动态代理并非是你日常使用的工具，但是它可以非常好地解决某些类型的问题。你在《Thinking in Patterns》（查看https://www.mindviewllc.com）和Erich Gamma等人撰写的《Design Patterns》[^2]这两本书中了解到有关代理和其他设计模式的更多知识。

练习21：（2）修改SimpleProxyDemo.java，使其可以度量方法调用的次数。

练习22：（3）修改SimpleDynamicProxy.java。使其可以度量方法调用的次数。

练习23：（3）在SimpleDynamicProxy.java中的invoke()内部，尝试打印proxy参数并解释所产生的结果。

项目[^3]：使用动态代理来编写一个系统以实现事务，其中，代理在被代理的调用执行成功时（不抛出任何异常）执行提交，而在其执行失败时执行回滚。你的提交和回滚都针对一个外部的文本文件，该文件不在Java异常的控制范围之内。你必须注意操作的原子性。