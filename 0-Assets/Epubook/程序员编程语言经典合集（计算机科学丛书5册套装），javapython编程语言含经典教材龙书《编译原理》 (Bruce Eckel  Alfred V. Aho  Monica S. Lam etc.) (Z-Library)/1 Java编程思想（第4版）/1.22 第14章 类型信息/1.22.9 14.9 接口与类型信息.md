## 14.9　接口与类型信息

interface关键字的一种重要目标就是允许程序员隔离构件，进而降低耦合性。如果你编写接口，那么就可以实现这一目标，但是通过类型信息，这种耦合性还是会传播出去——接口并非是对解耦的一种无懈可击的保障。下面有一个示例，先是一个接口：

![379-1](../Images/image03169.jpeg)

然后实现这个接口，你可以看到其代码是如何围绕着实际的实现类型潜行的：

![379-2](../Images/image03170.jpeg)

通过使用RTTI，我们发现a是被当作B实现的。通过将其转型为B，我们可以调用不在A中的方法。

这是完全合法和可接受的，但是你也许并不想让客户端程序员这么做，因为这给了他们一个机会，使得他们的代码与你的代码的耦合程度超过你的期望。也就是说，你可能认为interface关键字正在保护着你，但是它并没有，在本例中使用B来实现A这一事实是公开有案可查的[^6]。

一种解决方案是直接声明，如果程序员决定使用实际的类而不是接口，他们需要自己对自己负责。这在很多情况下可能都是合理的，但“可能”还不够，你也许希望应用一些更严苛的控制。

最简单的方式是对实现使用包访问权限，这样在包外部的客户端就不能看到它了：

![380-1](../Images/image03171.jpeg)

在这个包中唯一public的部分，即HiddenC，在被调用时将产生A接口类型的对象。这里有趣之处在于：即使你从makeA()返回的是C类型，你在包的外部仍旧不能使用A之外的任何方法，因为你不能在包的外部命名C。

现在如果你试图将其向下转型为C，则将被禁止，因为在包的外部没有任何C类型可用：

![380-2](../Images/image03172.jpeg)

正如你所看到的，通过使用反射，仍旧可以到达并调用所有方法，甚至是private方法！如果知道方法名，你就可以在其Method对象上调用setAccessible（true），就像在callHiddenMethod()中看到的那样。

你可能会认为，可以通过只发布编译后的代码来阻止这种情况，但是这并不解决问题。因为只需运行javap，一个随JDK发布的反编译器即可突破这一限制。下面是一个使用它的命令行：

![381-2](../Images/image03173.jpeg)

-private标志表示所有的成员都应该显示，甚至包括私有成员。下面是输出：

![381-3](../Images/image03174.jpeg)

因此任何人都可以获取你最私有的方法的名字和签名，然后调用它们。

如果你将接口实现为一个私有内部类，又会怎样呢？下面展示了这种情况：

![381-4](../Images/image03175.jpeg)

这里对反射仍旧没有隐藏任何东西。那么如果是匿名类呢？

![382-2](../Images/image03176.jpeg)

看起来没有任何方式可以阻止反射到达并调用那些非公共访问权限的方法。对于域来说，的确如此，即便是private域：

![382-3](../Images/image03177.jpeg)

但是，final域实际上在遭遇修改时是安全的。运行时系统会在不抛异常的情况下接受任何修改尝试，但是实际上不会发生任何修改。

通常，所有这些违反访问权限的操作并非世上最糟之事。如果有人使用这样的技术去调用标识为private或包访问权限的方法（很明显这些访问权限表示这些人不应该调用它们），那么对他们来说，如果你修改了这些方法的某些方面，他们不应该抱怨。另一方面，总是在类中留下后门的这一事实，也许可以使得你能够解决某些特定类型的问题，但如果不这样做，这些问题将难以或者不可能解决，通常反射带来的好处是不可否认的。

练习25：（2）创建一个包含private、protected和包访问权限方法的类，编写代码在该类所处的包的外部调用访问这些方法。