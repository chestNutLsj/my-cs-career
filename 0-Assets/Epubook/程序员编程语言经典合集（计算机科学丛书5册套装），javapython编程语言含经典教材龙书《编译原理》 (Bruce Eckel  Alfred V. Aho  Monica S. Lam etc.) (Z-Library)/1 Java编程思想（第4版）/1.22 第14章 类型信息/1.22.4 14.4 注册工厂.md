## 14.4　注册工厂

生成Pet继承结构中的对象存在着一个问题，即每次向该继承结构添加新的Pet类型时，必须将其添加为LiteralPetCreator.java中的项。如果在系统中已经存在了继承结构的常规的基础，然后在其上要添加更多的类，那么就有可能会出现问题。

你可能会考虑在每个子类中添加静态初始化器，以使得该初始化器可以将它的类添加到某个List中。遗憾的是，静态初始化器只有在类首先被加载的情况下才能被调用，因此你就碰上了“先有鸡还是先有蛋”的问题：生成器在其列表中不包含这个类，因此它永远不能创建这个类的对象，而这个类也就不能被加载并置于这个列表中。

这主要是因为，你被强制要求自己去手工创建这个列表（除非你想编写一个工具，它可以全面搜索和分析源代码，然后创建和编译这个列表）。因此，你最佳的做法是，将这个列表置于一个位于中心的、位置明显的地方，而我们感兴趣的继承结构的基类可能就是这个最佳位置。

这里我们需要做的其他修改就是使用工厂方法设计模式，将对象的创建工作交给类自己去完成。工厂方法可以被多态地调用，从而为你创建恰当类型的对象。在下面这个非常简单的版本中，工厂方法就是Factory接口中的create()方法：

![364-2](../Images/image03145.jpeg)

泛型参数T使得create()可以在每种Factory实现中返回不同的类型。这也充分利用了协变返回类型。

在下面的示例中，基类Part包含一个工厂对象的列表。对于应这个由createRandom()方法产生的类型，它们的工厂都被添加到了partFactories List中，从而被注册到了基类中：

![364-3](../Images/image03146.jpeg)

![365-1](../Images/image03147.jpeg)

![366-1](../Images/image03148.jpeg)

并非所有在继承结构中的类都应该被实例化，在本例中，Filter和Belt只是分类标识，因此你不应该创建它们的实例，而只应该创建它们的子类的实例。如果某个类应该由createRandom()方法创建，那么它就包含一个内部Factory类。如上所示，重用名字Factory的唯一方式就是限定typeinfo.factory.Factory。

尽管你可以使用Collections.addAll()来向列表中添加工厂，但是这样做编译器就会表达它的不满，抛出一条有关“创建泛型数组”（这被认为是不可能的，正如你将在第15章中所看到的那样）的警告，因此我转而使用add()。createRandom()方法从partFactories中随机地选取一个工厂对象，然后调用其create()方法，从而产生一个新的Part。

练习14：（4）构造器就是一种工厂方法。修改RegisteredFactories.java，使其不要使用显式的工厂，而是将类对象存储到List中，并使用newInstance()来创建对象。

练习15：（4）使用注册工厂来实现一个新的PetCreator，并修改Pets外观，使其使用这个新的Creator而并非另外两个Creator。确保使用Pets.java的其他示例仍可以正常工作。

练习16：（4）修改第15章中的Coffee继承结构，以便可以使用注册工厂。