## 14.8　空对象

当你使用内置的null表示缺少对象时，在每次使用引用时都必须测试其是否为null，这显得枯燥，而且势必产生相当乏味的代码。问题在于null除了在你试图用它执行任何操作来产生NullPointerException之外，它自己没有其他任何行为。有时引入空对象[^4]的思想将会很有用，它可以接受传递给它的所代表的对象的消息，但是将返回表示为实际上并不存在任何“真实”对象的值。通过这种方式，你可以假设所有的对象都是有效的，而不必浪费编程精力去检查null（并阅读所产生的代码）。

尽管想象一种可以自动为我们创建空对象的编程语言显得很有趣，但是实际上，到处使用空对象并没有任何意义——有时检查null就可以了，有时你可以合理地假设你根本不会遇到null，有时甚至通过NullPointerException来探测异常也可以接受的。空对象最有用之处在于它更靠近数据，因为对象表示的是问题空间内的实体。有一个简单的例子，许多系统都有一个Person类，而在代码中，有很多情况是你没有一个实际的人（或者你有，但是你还没有这个人的全部信息），因此，通常你会使用一个null引用并测试它。与此不同的是，我们可以使用空对象。但是即使空对象可以响应“实际”对象可以响应的所有消息，你仍需要某种方式去测试其是否为空。要达到此目的，最简单的方式是创建一个标记接口：

![374-1](../Images/image03160.jpeg)

这使得instanceof可以探测空对象，更重要的是，这并不要求你在所有的类中都添加isNull()方法（毕竟，这只是执行RTTI的一种不同方式——为什么不使用内置的工具呢？）

![374-2](../Images/image03161.jpeg)

通常，空对象都是单例，因此这里将其作为静态final实例创建。这可以正常工作的，因为Person是不可变的——你只能在构造器中设置它的值，然后读取这些值，但是你不能修改它们（因为String自身具备内在的不可变性）。如果你想要修改一个NullPerson，那只能用一个新的Person对象来替换它。注意，你可以选择使用instanceof来探测泛化的Null还是更具体的NullPerson，但是由于使用了单例方式，所以你还可以只使用equals()甚至==来与Person.Null比较。

现在假设你回到了互联网刚出现时的雄心万丈的年代，并且你已经因你惊人的理念而获得了一大笔的风险投资。你现在要招兵买马了，但是在虚位以待时，你可以将Person空对象放在每个Position上：

![375-1](../Images/image03162.jpeg)

有了Position，你就不需要创建空对象了，因为Person.Null的存在就表示这是一个空Position［稍后，你可能会发现需要增加一个显式的用于Position的空对象，但是YAGNI[^5]（You Aren't Going to Need It，你永不需要它）声明：在你的设计草案的初稿中，应该努力使用最简单且可以工作的事物，直至程序的某个方面要求你添加额外的特性，而不是一开始就假设它是必需的］。

Staff类现在可以在你填充职位时查询空对象：

![375-2](../Images/image03163.jpeg)

![376-1](../Images/image03164.jpeg)

注意，你在某些地方仍必须测试空对象，这与检查是否为null没有差异，但是在其他地方（例如本例中的toString()转换）你就不必执行额外的测试了，而可以直接假设所有对象都是有效的。

如果你用接口取代具体类，那么就可以使用DynamicProxy来自动地创建空对象。假设我们有一个Robot接口，它定义了一个名字、一个模型和一个描述Robot行为能力的List<Operation>。Operation包含一个描述和一个命令（这是一种命令模式类型）：

![376-2](../Images/image03165.jpeg)

你可以通过调用operations()来访问Robot的服务：

![377-1](../Images/image03166.jpeg)

这里也使用了嵌套类来执行测试。

我们现在可以创建一个扫雪Robot：

![377-2](../Images/image03167.jpeg)

假设存在许多不同类型的Robot，我们想对每一种Robot类型都创建一个空对象，去执行某些特殊操作——在本例中，即提供空对象所代表的Robot确切类型的信息。这些信息是通过动态代理捕获的：

![378-2](../Images/image03168.jpeg)

无论何时，如果你需要一个空Robot对象，只需调用newNullRobot()，并传递需要代理的Robot的类型。代理会满足Robot和Null接口的需求，并提供它所代理的类型的确切名字。