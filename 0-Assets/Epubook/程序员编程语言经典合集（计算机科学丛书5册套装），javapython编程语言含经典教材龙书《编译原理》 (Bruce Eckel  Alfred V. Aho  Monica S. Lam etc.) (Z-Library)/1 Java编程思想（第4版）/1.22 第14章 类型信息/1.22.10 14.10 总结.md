## 14.10　总结

RTTI允许通过匿名基类的引用来发现类型信息。初学者极易误用它，因为在学会使用多态调用方法之前，这么做也很有效。对有过程化编程背景的人来说，很难让他们不把程序组织成一系列switch语句。你可以用RTTI做到这一点，但是这样就在代码开发和维护过程中损失了多态机制的重要价值。面向对象编程语言的目的是让我们在凡是可以使用的地方都使用多态机制，只在必需的时候使用RTTI。

然而使用多态机制的方法调用，要求我们拥有基类定义的控制权，因为在你扩展程序的时候，可能会发现基类并未包含我们想要的方法。如果基类来别人的类，或者由别人控制，这时候RTTI便是一种解决之道：可继承一个新类，然后添加你需要的方法。在代码的其他地方，可以检查你自己特定的类型，并调用你自己的方法。这样做不会破坏多态性以及程序的扩展能力，因为这样添加一个新的类并不需要在程序中搜索switch语句。但如果在程序主体中添加需要的新特性的代码，就必须使用RTTI来检查你的特定的类型。

如果只是为了某个特定类的利益，而将某个特性放进基类里，这意味着从那个基类派生出的所有其他子类都带有这些可能无意义的东西。这会使得接口更不清晰，因为我们必须覆盖由基类继承而来的所有抽象方法，这是很恼人的。例如，考虑一个表示乐器Instrument的类层次结构。假设我们想清洁管弦乐队中某些乐器残留的口水，一种办法是在基类Instrument中放入clearSpitValve()方法。但这样做会造成混淆，因为它意味着打击乐器Percussion、弦乐器Stringed和电子乐器Electronic也需要清洁口水。在这个例子中，RTTI可以提供了一种更合理的解决方案。可以将clearSpitValve()置于适当的特定类中，在这个例子中是Wind（管乐器）。同时，你可能会发现还有更恰当的解决方法，在这里，就是将prepareInstrument()置于基类中，但是初次面对这个问题时读者可能看不到这样的解决方案，而误认为必须使用RTTI。

最后一点，RTTI有时能解决效率问题。也许你的程序漂亮地运用了多态，但其中某个对象是以极端缺乏效率的方式达到这个目的的。你可以挑出这个类，使用RTTI，并且为其编写一段特别的代码以提高效率。然而必须要注意，不要太早地关注程序的效率问题，这是个诱人的陷阱。最好首先让程序运作起来，然后再考虑它的速度，如果要解决效率问题可以使用profiler（查看http://MindView.net/Books/BetterJava上的补充材料）。

我们已经看到了，由于反射允许更加动态的编程风格，因此它开创了编程的新世界。对有些人来说，反射的动态特性是一种烦扰，对于已经习惯于静态类型检查的安全性的人来说，你可以执行一些只能在运行时进行的检查，并用异常来报告检查结果的行为，这本身就是一种错误的方向。有些人走的更远，他们声称引入运行时异常本身就是一种指示，说明应该避免这种代码。我发现这种意义的安全是一种错觉，因为总是有些事情是在运行时发生并抛出异常的，即使是在不包含任何try语句块或异常规格说明的程序中也是如此。因此，我认为一致的错误报告模型的存在使我们能够通过使用反射编写动态代码。当然，尽力编写能够进行静态检查的代码是值得的，只要你确实能够这么做。但是我相信动态代码是将Java与其他诸如C++这样的语言区分开的重要工具之一。

练习26：（3）实现本章总结中所描述的clearSpitValve()。

所选习题的答案都可以在名为The Thinking in Java Annotated Solution Guide的电子文档中找到，读者可以从https://www.mindviewllc.com购买此文档。

---

[^1]: 特别是在过去，现在Sun已极大地改进了其HTML Java文档，所以查找基类的方法已经简单多了。

[^2]: 本书的英文版、中文版及双语版均已由机械工业出版社出版。——编辑注

[^3]: 项目实际上是被用作术语项目的一些建议，这些项目的解决方案并未包括在解决方案指南中。

[^4]: 由Bobby Woolf和Bruce Anderson发现的。这可以看作是策略模式的特例。空对象的一种变体称为空迭代器模式，它使得在组合层次结构中遍历各个节点的操作对客户端透明（客户端可以使用相同的逻辑来遍历组合和叶子节点）。

[^5]: 这是极限编程（XP）的原则之一，即“做可以工作的最简单的事情”。

[^6]: 这种情况最出名的案例就是Windows操作系统，它有一个发布的API，并假设你会对着它进行编码，另外还有一个未发布的，但是可视的函数集，你可以发现并调用它。为了解决问题，程序员会使用隐藏的API函数，这导致微软必须把它们当作公共API的一部分来维护。因而成为了公司巨额成本和投入的黑洞。