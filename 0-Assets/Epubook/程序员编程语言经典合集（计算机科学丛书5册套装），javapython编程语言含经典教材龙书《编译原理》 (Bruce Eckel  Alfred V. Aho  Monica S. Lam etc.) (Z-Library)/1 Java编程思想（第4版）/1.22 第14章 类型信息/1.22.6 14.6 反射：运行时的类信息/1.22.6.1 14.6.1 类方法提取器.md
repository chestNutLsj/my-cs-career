### 14.6.1　类方法提取器

通常你不需要直接使用反射工具，但是它们在你需要创建更加动态的代码时会很有用。反射在Java中是用来支持其他特性的，例如对象序列化和JavaBean（它们在本书稍后部分都会提到）。但是，如果能动态地提取某个类的信息有的时候还是很有用的。请考虑类方法提取器。浏览实现了类定义的源代码或是其JDK文档，只能找到在这个类定义中被定义或被覆盖的方法。但对你来说，可能有数十个更有用的方法都是继承自基类的。要找出这些方法可能会很乏味且费时[^1]。幸运的是，反射机制提供了一种方法，使我们能够编写可以自动展示完整接口的简单工具。下面就是其工作方式：

![368-1](../Images/image03151.jpeg)

![369-1](../Images/image03152.jpeg)

Class的getMethods()和getConstructors()方法分别返回Method对象的数组和Constructor对象的数组。这两个类都提供了深层方法，用以解析其对象所代表的方法，并获取其名字、输入参数以及返回值。但也可以像这里一样，只使用toString()生成一个含有完整的方法特征签名的字符串。代码其他部分用于提取命令行信息，判断某个特定的特征签名是否与我们的目标字符串相符（使用indexOf()），并使用正则表达式去掉了命名修饰词（正则表达式在第13章中介绍过）。

Class.forName()生成的结果在编译时是不可知的，因此所有的方法特征签名信息都是在执行时被提取出来的。如果研究一下JDK文档中关于反射的部分，就会看到，反射机制提供了足够的支持，使得能够创建一个在编译时完全未知的对象，并调用此对象的方法（在本书后面会有示例）。虽然开始的时候可能认为永远也不需要用到这些功能，但是反射机制的价值是很惊人的。

上面的输出是从下面的命令行产生的：

![370-1](../Images/image03153.jpeg)

你可以看到，输出中包含一个public的默认构造器，即便能在代码中看到根本没有定义任何构造器。所看到的这个包含在列表中的构造器是编译器自动合成的。如果将ShowMethods作为一个非public的类（也就是拥有包访问权限），输出中就不会再显示出这个自动合成的默认构造器了。该自动合成的默认构造器会自动被赋予与类一样的访问权限。

还有一个有趣的例子是，用一个额外的char、int或String等参数来调用java ShowMethods java.lang.String。

在编程时，特别是如果不记得一个类是否有某个方法，或者不知道一个类究竟能做些什么，例如Color对象，而又不想通过索引或类的层次结构去查找JDK文档，这时这个工具确实能节省很多时间。

第22章包含这个程序的GUI版本（专为提取Swing构件的信息而定制的），使你在编写代码的同时能够通过运行它来快速查询有用的信息。

练习17：（2）修改ShowMethods.java中的正则表达式，以去掉native和final关键字（提示：使用“或”运算符“|”）。

练习18：（1）将ShowMethods变为一个非public的类，并验证合成的默认构造器不会再在输出中出现。

练习19：（4）在ToyTest.java中，使用反射机制，通过非默认构造器创建Toy对象。

练习20：（5）请从在http://java.sun.com上提供的JDK文档中找出java.lang.Class的接口。写一个程序，使它能够接受命令行参数所指定的类名称。然后使用Class的方法打印该类所有可以获得的信息。用标准程序库的类和你自己写的类，分别测试这个程序。