## 11.10　Map

将对象映射到其他对象的能力是一种解决编程问题的杀手锏。例如，考虑一个程序，它将用来检查Java的Random类的随机性。理想状态下，Random可以将产生理想的数字分布，但要想测试它，则需要生成大量的随机数，并对落入各种不同范围的数字进行计数。Map可以很容易地解决该问题。在本例中，键是由Random产生的数字，而值是该数字出现的次数：

![267-1](../Images/image02982.jpeg)

在main()中，自动包装机制将随机生成的int转换为HashMap可以使用的Integer引用（不能使用基本类型的容器）。如果键不在容器中，get()方法将返回null（这表示该数字第一次被找到）。否则，get()方法将产生与该键相关联的Integer值，然后这个值被递增（自动包装机制再次简化了表达式，但是确实发生了对Integer的包装和拆包）。

下面的示例允许你使用一个String描述来查找Pet，它还展示了你可以使用怎样的方法通过使用containsKey()和containsValue()来测试一个Map，以便查看它是否包含某个键或某个值。

![267-2](../Images/image02983.jpeg)

Map与数组和其他的Collection一样，可以很容易地扩展到多维，而我们只需将其值设置为Map（这些Map的值可以是其他容器，甚至是其他Map）。因此，我们能够很容易地将容器组合起来从而快速地生成强大的数据结构。例如，假设你正在跟踪拥有多个宠物的人，你所需只是一个Map<Person，List<Pet>>：

![268-1](../Images/image02984.jpeg)

Map可以返回它的键的Set，它的值的Collection，或者它的键值对的Set。keySet()方法产生了由在petPeople中的所有键组成的Set，它在foreach语句中被用来迭代遍历该Map。

练习17：（2）使用练习1中的Gerbil类，将其放入Map中，将每个Gerbil的名字（例如Fuzzy或Spot）String（键）与每个Gerbil（值）关联起来。为keySet()获取Iterator，使用它遍历Map，针对每个“键”查询Gerbil，然后打印出“键”，并让gerbil执行hop()。

练习18：（3）用键值对填充一个HashMap。打印结果，通过散列码来展示其排序。抽取这些键值对，按照键进行排序，并将结果置于一个LinkedHashMap中。展示其所维护的插入顺序。

练习19：（2）使用HashSet和LinkedHashSet重复前一个练习。

练习20：（3）修改练习16，使得你可以跟踪每一个元音字母出现的次数。

练习21：（3）通过使用Map<String.Integer>，遵循UniqueWords.java的形式来创建一个程序，它可以对一个文件中出现的单词计数。使用带有第二个参数String.CASE_INSENSITIVE_ORDER的Collections.sort()方法对结果进行排序（将产生字母序），然后显示结果。

练习22：（5）修改前一个练习，使其用一个包含有一个String域和一个计数域的类来存储每一个不同的单词，并使用一个由这些对象构成的Set来维护单词列表。

练习23：（4）从Statistics.java开始，写一个程序，让它重复做测试，观察是否某个数字比别的数字出现的次数多。

练习24：（2）使用String“键”和你选择的对象填充LinkedHashMap。然后从中提取键值对，以键排序，然后重新插入此Map。

练习25：（3）创建一个Map<String.ArrayList<Integer>>，使用net.mindview.TextFile来打开一个文本文件，并一次读入一个单词（使用“\\W+”作为TextFile构造器的第二个参数）。在读入单词时对它们进行计数，并且对于文件中的每一个单词，都在ArrayList<Integer>中记录下与这个词相关联的单词计数。实际上，它记录的是该单词在文件中被发现的位置。

练习26：（4）拿到前一个练习中所产生的Map，并按照它们在最初的文件中出现的顺序重新创建单词顺序。