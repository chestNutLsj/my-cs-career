### 11.11.1　PriorityQueue

先进先出描述了最典型的队列规则。队列规则是指在给定一组队列中的元素的情况下，确定下一个弹出队列的元素的规则。先进先出声明的是下一个元素应该是等待时间最长的元素。

优先级队列声明下一个弹出元素是最需要的元素（具有最高的优先级）。例如，在飞机场，当飞机临近起飞时，这架飞机的乘客可以在办理登机手续时排到队头。如果构建了一个消息系统，某些消息比其他消息更重要，因而应该更快地得到处理，那么它们何时得到处理就与它们何时到达无关。PriorityQueue添加到Java SE5中，是为了提供这种行为的一种自动实现。

当你在PriorityQueue上调用offer()方法来插入一个对象时，这个对象会在队列中被排序[^5]方法时，获取的元素将是队列中优先级最高的元素。

让PriorityQueue与Integer、String和Character这样的内置类型一起工作易如反掌。在下面的示例中，第一个值集与前一个示例中的随机值相同，因此你可以看到它们从PriorityQueue中弹出的顺序与前一个示例不同：

![270-2](../Images/image02986.jpeg)

![271-1](../Images/image02987.jpeg)

你可以看到，重复是允许的，最小的值拥有最高的优先级（如果是String，空格也可以算作值，并且比字母的优先级高）。为了展示你可以使用怎样的方法通过提供自己的Comparator对象来改变排序，第三个对PriorityQueue<Integer>的构造器调用，和第二个对PriorityQueue<String>的调用使用了由Collection.reverseOrder()（新添加到Java SE5中的）产生的反序的Comparator。

最后一部分添加了一个HashSet来消除重复的Character，这么做只是为了增添点乐趣。

Integer、String和Character可以与PriorityQueue一起工作，因为这些类已经内建了自然排序。如果你想在PriorityQueue中使用自己的类，就必须包括额外的功能以产生自然排序，或者必须提供自己的Comparator。在第17章中有一个更加复杂的示例将演示这种情况。

练习28：（2）用由java.util.Random创建的Double值填充一个PriorityQueue（用offer()方法），然后使用poll()移除并显示它们。

练习29：（2）创建一个继承自Object的简单类，它不包含任何成员，展示你不能将这个类的多个示例成功地添加到一个PriorityQueue中。这个问题将在第17章中详细解释。