## 11.12　Collection和Iterator

Collection是描述所有序列容器的共性的根接口，它可能会被认为是一个“附属接口”，即因为要表示其他若干个接口的共性而出现的接口。另外，java.util.AbstractCollection类提供了Collection的默认实现，使得你可以创建AbstractCollection的子类型，而其中没有不必要的代码重复。

使用接口描述的一个理由是它可以使我们能够创建更通用的代码。通过针对接口而非具体实现来编写代码，我们的代码可以应用于更多的对象类型[^6]方法：

![272-1](../Images/image02988.jpeg)

两个版本的display()方法都可以使用Map或Collection的子类型来工作，而且Collection接口和Iterator都可以将display()方法与底层容器的特定实现解耦。

在本例中，这两种方式都可以奏效。事实上，Collection要更方便一点，因为它是Iterable类型，因此，在display（Collection）实现中，可以使用foreach结构，从而使代码更加清晰。

当你要实现一个不是Collection的外部类时，由于让它去实现Collection接口可能非常困难或麻烦，因此使用Iterator就会变得非常吸引人。例如，如果我们通过继承一个持有Pet对象的类来创建一个Collection的实现，那么我们必须实现所有的Collection方法，即使我们在display()方法中不必使用它们，也必须如此。尽管这可以通过继承AbstractCollection而很容易地实现，但是你无论如何还是要被强制去实现iterator()和size()，以便提供AbstractCollection没有实现，但是AbstractCollection中的其他方法会使用到的方法：

![273-1](../Images/image02989.jpeg)

remove()方法是一个“可选操作”，你将在第17章中了解它。这里不必实现它，如果你调用它，它会抛出异常。

从本例中，你可以看到，如果你实现Collection，就必须实现iterator()，并且只拿实现iterator()与继承AbstractCollection相比，花费的代价只有略微减少。但是，如果你的类已经继承了其他的类，那么你就不能再继承AbstractCollection了。在这种情况下，要实现Collection，就必须实现该接口中的所有方法。此时，继承并提供创建迭代器的能力就会显得容易得多了：

![273-2](../Images/image02990.jpeg)

生成Iterator是将队列与消费队列的方法连接在一起耦合度最小的方式，并且与实现Collection相比，它在序列类上所施加的约束也少得多。

练习30：（5）修改CollectionSequence.java，使其不要继承AbstractCollection，而是实现Collection。