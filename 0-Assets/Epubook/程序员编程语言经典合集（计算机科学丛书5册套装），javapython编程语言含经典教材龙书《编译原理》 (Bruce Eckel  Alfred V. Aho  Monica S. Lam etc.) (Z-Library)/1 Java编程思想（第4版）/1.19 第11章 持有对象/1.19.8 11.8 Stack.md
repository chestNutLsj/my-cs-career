## 11.8　Stack

“栈”通常是指“后进先出”（LIFO）的容器。有时栈也被称为叠加栈，因为最后“压入”栈的元素，第一个“弹出”栈。经常用来类比栈的事物是装有弹簧的储放器中的自助餐托盘，最后装入的托盘总是最先拿出使用的。

LinkedList具有能够直接实现栈的所有功能的方法，因此可以直接将LinkedList作为栈使用。不过，有时一个真正的“栈”更能把事情讲清楚：

![263-1](../Images/image02973.jpeg)

这里通过使用范型，引入了在栈的类定义中最简单的可行示例。类名之后的<T>告诉编译器这将是一个参数化类型，而其中的类型参数，即在类被使用时将会被实际类型替换的参数，就是T。大体上，这个类是在声明“我们在定义一个可以持有T类型对象的Stack。”Stack是用LinkedList实现的，而LinkedList也被告知它将持有T类型对象。注意，push()接受的是T类型的对象，而peek()和pop()将返回T类型的对象。peek()方法将提供栈顶元素，但是并不将其从栈顶移除，而pop()将移除并返回栈顶元素。

如果你只需要栈的行为，这里使用继承就不合适了，因为这样会产生具有LinkedList的其他所有方法的类（就象你将在第17章中所看到的，Java1.0的设计者在创建java.util.Stack时，就犯了这个错误）。

下面演示了这个新的Stack类：

![263-2](../Images/image02974.jpeg)

如果你想在自己的代码中使用这个Stack类，当你在创建其实例时，就需要完整指定包名，或者更改这个类的名称；否则，就有可能与java.util包中的Stack发生冲突。例如，如果我们在上面的例子中导入java.util.*，那么就必须使用包名以防止冲突：

![263-3](../Images/image02975.jpeg)

这两个Stack具有相同的接口，但是在java.util中没有任何公共的Stack接口，这可能是因为在Java1.0中的设计欠佳的最初的java.util.Stack类占用了这个名字。尽管已经有了java.util.Stack，但是LinkedList可以产生更好的Stack，因此net.mindview.util.Stack所采用的方式更是可取的。

你还可以通过显式的导入来控制对“首选”Stack实现的选择：

![264-2](../Images/image02976.jpeg)

现在，任何对Stack的引用都将选择net.mindview.util版本，而在选择java.util.Stack时，必须使用全限定名称。

练习15：（4）栈在编程语言中经常用来对表达式求值。请使用net.mndview.util.Stack对下面的表达式求值，其中“+”表示“将后面的字母压进栈”，而“-”表示“弹出栈顶字母并打印它”：

“+U+n+c---+e+r+t---+a-+i-+n+t+y---+-+r+u--+l+e+s---”