## 11.6　迭代器

任何容器类，都必须有某种方式可以插入元素并将它们再次取回。毕竟，持有事物是容器最基本的工作。对于List，add()是插入元素的方法之一，而get()是取出元素的方法之一。

如果从更高层的角度思考，会发现这里有个缺点：要使用容器，必须对容器的确切类型编程。初看起来这没什么不好，但是考虑下面的情况：如果原本是对着List编码的，但是后来发现如果能够把相同的代码应用于Set，将会显得非常方便，此时应该怎么做？或者打算从头开始编写通用的代码，它们只是使用容器，不知道或者说不关心容器的类型，那么如何才能不重写代码就可以应用于不同类型的容器？

迭代器（也是一种设计模式）的概念可以用于达成此目的。迭代器是一个对象，它的工作是遍历并选择序列中的对象，而客户端程序员不必知道或关心该序列底层的结构。此外，迭代器通常被称为轻量级对象：创建它的代价小。因此，经常可以见到对迭代器有些奇怪的限制；例如，Java的Iterator只能单向移动，这个Iterator只能用来：

1）使用方法iterator()要求容器返回一个Iterator。Iterator将准备好返回序列的第一个元素。

2）使用next()获得序列中的下一个元素。

3）使用hasNext()检查序列中是否还有元素。

4）使用remove()将迭代器新近返回的元素删除。

为了观察它的工作方式，让我们再次使用在第14章中的Pet工具：

![259-1](../Images/image02969.jpeg)

有了Iterator就不必为容器中元素的数量操心了，那是由hasNext()和next()关心的事情。

如果你只是向前遍历List，并不打算修改List对象本身，那么你可以看到foreach语法会显得更加简洁。

Iterator还可以移除由next()产生的最后一个元素，这意味着在调用remove()之前必须先调用next()[^4]。

接受对象容器并传递它，从而在每个对象上都执行操作，这种思想十分强大，并且贯穿于本书。

现在考虑创建一个display()方法，它不必知晓容器的确切类型：

![260-1](../Images/image02970.jpeg)

请注意，display()方法不包含任何有关它所遍历的序列的类型信息，而这也展示了Iterator的真正威力：能够将遍历序列的操作与序列底层的结构分离。正由于此，我们有时会说：迭代器统一了对容器的访问方式。

练习8：（1）修改练习1，以便调用hop()时使用Iterator遍历List。

练习9：（4）修改innerclasses/Sequence.java，使得在Sequence中，用Iterator取代Selector。

练习10：（2）修改第8章中的练习9，使其使用一个ArrayList来存放Rodents，并使用一个Iterator来访问Rodent序列。

练习11：（2）写一个方法，使用Iterator遍历Collection，并打印容器中每个对象的toString()。填充各种类型的Collection，然后对其使用此方法。