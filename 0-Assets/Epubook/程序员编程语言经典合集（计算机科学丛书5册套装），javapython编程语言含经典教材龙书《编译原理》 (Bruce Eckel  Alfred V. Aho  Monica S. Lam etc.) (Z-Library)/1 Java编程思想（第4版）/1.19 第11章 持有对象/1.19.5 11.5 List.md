## 11.5　List

List承诺可以将元素维护在特定的序列中。List接口在Collection的基础上添加了大量的方法，使得可以在List的中间插入和移除元素。

有两种类型的List：

- 基本的ArrayList，它长于随机访问元素，但是在List的中间插入和移除元素时较慢。
- LinkedList，它通过代价较低的在List中间进行的插入和删除操作，提供了优化的顺序访问。LinkedList在随机访问方面相对比较慢，但是它的特性集较ArrayList更大。

下面的示例通过导入typeinfo.pets，超前使用了第14章中的类库。这个类库包含了Pet类的继承层次结构，以及用于随机生成Pet对象的一些工具类。此时，你还不需要了解这个类库的全部内容，而只需要知道两点：（1）有一个Pet类，以及Pet的各种子类型；（2）静态的Pets.arrayList()方法将返回一个填充了随机选取的Pet对象的ArrayList：

![256-1](../Images/image02967.jpeg)

![257-1](../Images/image02968.jpeg)

打印行都编了号，因此输出可以与源码相关。第一行输出展示了最初的由Pet构成的List。与数组不同，List允许在它被创建之后添加元素、移除元素，或者自我调整尺寸。这正是它的重要价值所在：一种可修改的序列。你可以在输出行2中看到添加一个Hamster的结果，即对象被追加到了表尾。

你可以用contains()方法来确定某个对象是否在列表中。如果你想移除一个对象，则可以将这个对象的引用传递给remove()方法。同样，如果你有一个对象的引用，则可以使用indexOf()来发现该对象在List中所处位置的索引编号，就像你在输出行4中所见一样。

当确定一个元素是否属于某个List，发现某个元素的索引，以及从某个List中移除一个元素时，都会用到equals()方法（它是根类Object的一部分）。每个Pet都被定义为唯一的对象，因此即使在列表中已经有两个Cymric，如果我再新创建一个Cymric，并把它传递给indexOf()方法，其结果仍会是-1（表示未找到它），而且尝试调用remove()方法来删除这个对象，也会返回false。对于其他的类，equals()的定义可能有所不同。例如，两个String只有在内容完全一样的情况下才会是等价的。因此为了防止意外，就必须意识到List的行为根据equals()的行为而有所变化。

在输出行7和8中，展示了对精确匹配List中某个对象的对象进行移除是成功的。

在List中间插入元素是可行的，就像你在输出行9和它前面的代码中所看到的一样。但是这带来了一个问题：对于LinkedList，在列表中间插入和删除都是廉价操作（在本例中，除了对列表中间进行的真正的随机访问），但是对于ArrayList，这可是代价高昂的操作。这是否意味着你应该永远都不要在ArrayList的中间插入元素，并最好是切换到LinkedList？不，这仅仅意味着，你应该意识到这个问题，如果你开始在某个ArrayList的中间执行很多插入操作，并且你的程序开始变慢，那么你应该看看你的List实现有可能就是罪魁祸首（发现此类瓶颈的最佳方式是使用仿真器，就像你在http://MindView.net/Books/BetterJava上的补充材料中所看到的一样）。优化是一个很棘手的问题，最好的策略就是置之不顾，直到你发现需要担心它了（尽管理解这些问题总是一种好的思路）。

subList()方法允许你很容易地从较大的列表中创建出一个片断，而将其结果传递给这个较大的列表的containsAll()方法时，很自然地会得到true。还有一点也很有趣，那就是我们注意到顺序并不重要，你可以在输出行11和12中看到，在sub上调用名字很直观的Collections.sort()和Collection.shuffle()方法，不会影响containsAll()的结果。subList()所产生的列表的幕后就是初始列表，因此，对所返回的列表的修改都会反映到初始列表中，反之亦然。

retainAll()方法是一种有效的“交集”操作，在本例中，它保留了所有同时在copy与sub中的元素。请再次注意，所产生的行为依赖于equals()方法。

输出行14展示了用元素的索引值来移除元素的结果。与通过对象引用来移除相比，它显得更加直观，因为在使用索引值时，不必担心equals()的行为。

removeAll()方法的行为也是基于equals()方法的。就像其名称所表示的，它将从List中移除在参数List中的所有元素。

set()方法的命名显得很不合时宜，因为它与Set类存在潜在的冲突。在此处，replace可能会显得更适合，因为它的功能是在指定的索引处（第一个参数），用第二个参数替换整个位置的元素。

输出行17表明，对于List，有一个重载的addAll()方法使得我们可以在初始List的中间插入新的列表，而不仅仅只能用Collection中的addAll()方法将其追加到表尾。

输出行18-20展示了isEmpty()和clear()方法的效果。

输出行22-23展示了你可以如何通过使用toArray()方法，将任意的Collection转换为一个数组。这是一个重载方法，其无参数版本返回的是Object数组，但是如果你向这个重载版本传递目标类型的数据，那么它将产生指定类型的数据（假设它能通过类型检查）。如果参数数组太小，存放不下List中的所有元素（就像本例一样），toArray()方法将创建一个具有合适尺寸的数组。Pet对象具有一个id()方法，如你所见，可以在所产生的数组中的对象上调用这个方法。

练习5：（3）修改ListFeatures.java，让它使用Integer（记住自动包装机制！）而不是Pet，并解释在结果上有何不同。

练习6：（2）修改ListFeatures.java，让它使用String而不是Pet，并解释在结果上有何不同。

练习7：（3）创建一个类，然后创建一个用你的类的对象进行过初始化的数组。通过使用subList()方法，创建你的List的子集，然后在你的List中移除这个子集。