## 11.9　Set

Set不保存重复的元素（至于如何判断元素相同则较为复杂，稍后便会看到）。如果你试图将相同对象的多个实例添加到Set中，那么它就会阻止这种重复现象。Set中最常被使用的是测试归属性，你可以很容易地询问某个对象是否在某个Set中。正因如此，查找就成为了Set中最重要的操作，因此你通常都会选择一个HashSet的实现，它专门对快速查找进行了优化。

Set具有与Collection完全一样的接口，因此没有任何额外的功能，不像前面有两个不同的List。实际上Set就是Collection，只是行为不同。（这是继承与多态思想的典型应用：表现不同的行为。）Set是基于对象的值来确定归属性的，而更加复杂的问题我们将在第17章中介绍。

下面是使用存放Integer对象的HashSet的示例：

![264-3](../Images/image02977.jpeg)

在0到29之间的10000个随机数被添加到了Set中，因此你可以想象，每一个数都重复了许多次。但是你可以看到，每一个数只有一个实例出现在结果中。

你还可以注意到，输出的顺序没有任何规律可循，这是因为出于速度原因的考虑，HashSet使用了散列——散列将在第17章中介绍。HashSet所维护的顺序与TreeSet或LinkedHashSet都不同，因为它们的实现具有不同的元素存储方式。TreeSet将元素存储在红-黑树数据结构中，而HashSet使用的是散列函数。LinkedHashList因为查询速度的原因也使用了散列，但是看起来它使用了链表来维护元素的插入顺序。

如果你想对结果排序，一种方式是使用TreeSet来代替HashSet：

![265-1](../Images/image02978.jpeg)

你将会执行的最常见的操作之一，就是使用contains()测试Set的归属性，但是还有很多操作会让你想起在上小学时所教授的文氏图（译者注：用圆表示集与集之间关系的图）：

![265-2](../Images/image02979.jpeg)

这些方法名都是自解释型的，而有几个方法可以在JDK文档中找到。

能够产生每个元素都唯一的列表是相当有用的功能。例如，在你想要列出在上面的SetOperations.java文件中所有的单词的时候。通过使用本书稍后将要介绍的net.mindview.TextFile工具，可以打开一个文件，并将其读入一个Set中：

![266-1](../Images/image02980.jpeg)

TextFile继承自List<String>，其构造器将打开文件，并根据正则表达式“\\W+”将其断开为单词，这个正则表达式表示“一个或多个字母”（正则表达式将在第13章中介绍）。所产生的结果传递给了TreeSet的构造器，它将把List中的内容添加到自身中。由于它是TreeSet，因此其结果是排序的。在本例中，排序是按字典序进行的，因此大写和小写字母被划分到了不同的组中。如果你想要按照字母序排序，那么可以向TreeSet的构造器传入String.CASE_INSENTIVE_ORDER比较器（比较器就是建立排序顺序的对象）：

![266-2](../Images/image02981.jpeg)

Comparator比较器将在第16章详细介绍。

练习16：（5）创建一个元音字母Set。对UniqueWords.java操作，计数并显示在每一个输入单词中的元音字母数量，并显示输入文件中的所有元音字母的数量总和。