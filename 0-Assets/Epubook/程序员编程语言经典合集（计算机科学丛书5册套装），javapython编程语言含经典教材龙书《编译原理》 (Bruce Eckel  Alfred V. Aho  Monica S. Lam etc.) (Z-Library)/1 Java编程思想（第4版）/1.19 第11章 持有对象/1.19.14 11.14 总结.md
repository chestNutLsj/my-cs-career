## 11.14　总结

Java提供了大量持有对象的方式：

1）数组将数字与对象联系起来。它保存类型明确的对象，查询对象时，不需要对结果做类型转换。它可以是多维的，可以保存基本类型的数据。但是，数组一旦生成，其容量就不能改变。

2）Collection保存单一的元素，而Map保存相关联的键值对。有了Java的泛型，你就可以指定容器中存放的对象类型，因此你就不会将错误类型的对象放置到容器中，并且在从容器中获取元素时，不必进行类型转换。各种Collection和各种Map都可以在你向其中添加更多的元素时，自动调整其尺寸。容器不能持有基本类型，但是自动包装机制会仔细地执行基本类型到容器中所持有的包装器类型之间的双向转换。

3）像数组一样，List也建立数字索引与对象的关联，因此，数组和List都是排好序的容器。List能够自动扩充容量。

4）如果要进行大量的随机访问，就使用ArrayList；如果要经常从表中间插入或删除元素，则应该使用LinkedList。

5）各种Queue以及栈的行为，由LinkedList提供支持。

6）Map是一种将对象（而非数字）与对象相关联的设计。HashMap设计用来快速访问；而TreeMap保持“键”始终处于排序状态，所以没有HashMap快。LinkedHashMap保持元素插入的顺序，但是也通过散列提供了快速访问能力。

7）Set不接受重复元素。HashSet提供最快的查询速度，而TreeSet保持元素处于排序状态。LinkedHashSet以插入顺序保存元素。

8）新程序中不应该使用过时的Vector、Hashtable和Stack。

浏览一下Java容器的简图（不包含抽象类和遗留构件）会大有裨益。这里只包含你在一般情况下会碰到的接口和类。

![279-1](../Images/image02998.jpeg)

简单的容器分类

你可以看到，其实只有四种容器：Map、List、Set和Queue，它们各有两到三个实现版本（Queue的java.util.concurrent实现没有包括在上面这张图中）。常用的容器用黑色粗线框表示。

点线框表示接口，实线框表示普通的（具体的）类。带有空心箭头的点线表示一个特定的类实现了一个接口，实心箭头表示某个类可以生成箭头所指向类的对象。例如，任意的Collection可以生成Iterator，而List可以生成ListIterator（也能生成普通的Iterator，因为List继承自Collection）。

下面的示例展示了各种不同的类在方法上的差异。实际的代码来自第15章，我在这里只是调用它以产生输出。程序的输出也展示了在每个类或接口中所实现的接口：

![279-2](../Images/image02999.jpeg)

![280-1](../Images/image03000.jpeg)

可以看到，除了TreeSet之外的所有Set都拥有与Collection完全一样的接口。List和Collection存在着明显的不同，尽管List所要求的方法都在Collection中。另一方面，在Queue接口中的方法都是独立的；在创建具有Queue功能的实现时，不需要使用Collection方法。最后，Map和Collection之间的唯一重叠就是Map可以使用entrySet()和values()方法来产生Collection。

注意，标记接口java.util.RandomAccess附着到了ArrayList上，而没有附着到LinkedList上。这为想要根据所使用的特定的List而动态修改其行为的算法提供了信息。

从面向对象的继承层次关系来看，这种组织结构确实有些奇怪。但是，当你了解了java.util中更多的有关容器的内容后（特别是第17章中的内容），你就会看到除了继承结构有些奇怪外，还有更多的问题。容器类库一直以来都是设计难题——解决这些难题涉及到要去满足经常彼此之间互为牵制的各方面需求。因此你应该学会中庸之道。

抛开这些问题，Java的容器每天都会用到的工具，它可以使程序更简洁、更强大、更高效。在适应容器类库的某些方面之前，你确实得费点劲儿，但是我想你很快就会找到自己的路子，去获得和使用这个类库中的类。

所选习题的答案都可以在名为The Thinking in Java Annotated Solution Guide的电子文档中找到，读者可以从https://www.mindviewllc.com购买此文档。

---

[^1]: 许多语言，例如Perl、Python和Ruby，都有容器的本地支持。

[^2]: 这里是操作符重载的用武之地，C++和C#的容器类都使用操作符重载生成了更简洁的语法。

[^3]: 在第15章的末尾，你会发现有关这个问题是否很严重的讨论。但是，第15章还将展示Java泛型远不止类型安全的容器这么简单。

[^4]: ，因此直至第17章之前，你都不用担心这个问题。

[^5]: 这实际上依赖于具体实现。优先级队列算法通常会在插入时排序（维护一个堆），但是它们也可能在移除时选择最重要的元素。如果对象的优先级在它在队列中等待时可以进行修改，那么算法的选择就显得很重要了。

[^6]: 某些人提倡这样一种自动创建机制，即对一个类中所有可能的方法组合都自动创建一个接口，有时要针对每一个单个的类都自动创建。我相信接口的意义应该不仅限于方法组合的机械地复制，因此我在创建接口之前，总是要先看到增加接口带来的价值。

[^7]: 在Java SE5之前还没有它，因为该方法被认为与操作系统的耦合度过紧，因此会违反“编写一次，到处运行”的原则。现在提供它这一事实表明，Java的设计者们更加务实了。