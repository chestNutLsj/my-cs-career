### 11.13.1　适配器方法惯用法

如果现有一个Iterable类，你想要添加一种或多种在foreach语句中使用这个类的方法，应该怎么做呢？例如，假设你希望可以选择以向前的方向或是向后的方向迭代一个单词列表。如果直接继承这个类，并覆盖iterator()方法，你只能替换现有的方法，而不能实现选择。

一种解决方案是所谓适配器方法的惯用法。“适配器”部分来自于设计模式，因为你必须提供特定接口以满足foreach语句。当你有一个接口并需要另一个接口时，编写适配器就可以解决问题。这里，我希望在默认的前向迭代器的基础上，添加产生反向迭代器的能力，因此我不能使用覆盖，而是添加了一个能够产生Iterable对象的方法，该对象可以用于foreach语句。正如你所见，这使得我们可以提供多种使用foreach的方式：

![276-1](../Images/image02995.jpeg)

如果直接将ral对象置于foreach语句中，将得到（默认的）前向迭代器。但是如果在该对象上调用reversed()方法，就会产生不同的行为。

通过使用这种方式，我可以在IterableClass.java示例中添加两种适配器方法：

![277-1](../Images/image02996.jpeg)

注意，第二个方法random()没有创建它自己的Iterator，而是直接返回被打乱的List中的Iterator。

从输出中可以看到，Collection.shuffle()方法没有影响到原来的数组，而只是打乱了shuffled中的引用。之所以这样，只是因为randomized()方法用一个ArrayList将Arrays.asList()方法的结果包装了起来。如果这个由Arrays.asList()方法产生的List被直接打乱，那么它就会修改底层的数组，就像下面这样：

![277-2](../Images/image02997.jpeg)

在第一种情况中，Arrays.asList()的输出被传递给了ArrayList()的构造器，这将创建一个引用ia的元素的ArrayList，因此打乱这些引用不会修改该数组。但是，如果直接使用Arrays.asList（ia）的结果，这种打乱就会修改ia的顺序。意识到Arrays.asList()产生的List对象会使用底层数组作为其物理实现是很重要的。只要你执行的操作会修改这个List，并且你不想原来的数组被修改，那么你就应该在另一个容器中创建一个副本。

练习32：（2）按照MultiIterableClass示例，在NonCollectionSequence.java中添加reversed()和randomized()方法，并让NonCollectionSequence实现Iterable。然后在foreach语句中展示所有的使用方式。