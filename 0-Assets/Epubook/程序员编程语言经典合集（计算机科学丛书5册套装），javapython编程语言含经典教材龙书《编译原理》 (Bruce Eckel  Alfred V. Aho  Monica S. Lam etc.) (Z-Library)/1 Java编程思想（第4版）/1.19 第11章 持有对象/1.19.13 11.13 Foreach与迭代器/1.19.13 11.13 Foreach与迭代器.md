## 11.13　Foreach与迭代器

到目前为止，foreach语法主要用于数组，但是它也可以应用于任何Collection对象。你实际上已经看到过很多使用ArrayList时用到它的示例，下面是一个更通用的证明：

![274-2](../Images/image02991.jpeg)

由于cs是一个Collection，所以这段代码展示了能够与foreach一起工作是所有Collection对象的特性。

之所以能够工作，是因为Java SE5引入了新的被称为Iterable的接口，该接口包含一个能够产生Iterator的iterator()方法，并且Iterable接口被foreach用来在序列中移动。因此如果你创建了任何实现Iterable的类，都可以将它用于foreach语句中：

![274-3](../Images/image02992.jpeg)

iterator()方法返回的是实现了Iterator<String>的匿名内部类的实例，该匿名内部类可以遍历数组中的所有单词。在main()中，你可以看到IterableClass确实可以用于foreach语句中。

在Java SE5中，大量的类都是Iterable类型，主要包括所有的Collection类（但是不包括各种Map）。例如，下面的代码可以显示所有的操作系统环境变量：

![275-2](../Images/image02993.jpeg)

System.getenv()[^7]产生一个由Map.Entry的元素构成的Set，并且这个Set是一个Iterable，因此它可以用于foreach循环。

foreach语句可以用于数组或其他任何Iterable，但是这并不意味着数组肯定也是一个Iterable，而任何自动包装也不会自动发生：

![275-3](../Images/image02994.jpeg)

尝试把数组当作一个Iterable参数传递会导致失败。这说明不存在任何从数组到Iterable的自动转换，你必须手工执行这种转换。

练习31：（3）修改polymorphism/shape/RandomShapeGenerator.java，使其成为一个Iterable。你需要添加一个接收元素数量为参数的构造器，这个数量是指在停止之前，你想用迭代器生成的元素的数量。验证这个程序可以工作。