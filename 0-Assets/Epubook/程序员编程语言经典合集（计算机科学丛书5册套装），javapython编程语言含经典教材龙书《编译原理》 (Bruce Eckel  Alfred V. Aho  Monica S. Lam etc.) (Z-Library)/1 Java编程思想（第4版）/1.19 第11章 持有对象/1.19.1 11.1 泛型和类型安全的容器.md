## 11.1　泛型和类型安全的容器

使用Java SE5之前的容器的一个主要问题就是编译器允许你向容器中插入不正确的类型。例如，考虑一个Apple对象的容器，我们使用最基本最可靠的容器ArrayList。现在，你可以把ArrayList当作“可以自动扩充自身尺寸的数组”来看待。使用ArrayList相当简单：创建一个实例，用add()插入对象；然后用get()访问这些对象，此时需要使用索引，就像数组一样，但是不需要方括号[^2]方法，使你可以知道已经有多少元素添加了进来，从而不会不小心因索引越界而引发错误（通过抛出运行时异常，异常将在第12章介绍）。

在本例中，Apple和Orange都放置在了容器中，然后将它们取出。正常情况下，Java编译器会报告警告信息，因为这个示例没有使用泛型。在这里，我们使用Java SE5所特有的注解来抑制了警告信息。注解以“@”符号开头，可以接受参数，这里的@SuppressWarnings注解及其参数表示只有有关“不受检查的异常”的警告信息应该被抑制：

![250-1](../Images/image02958.jpeg)

在第20章中将会更多地学习有关Java SE5的注解。

Apple和Orange类是有区别的，它们除了都是Object之外没有任何共性（记住，如果一个类没有显式地声明继承自哪个类，那么它自动地继承自Object）。因为ArrayList保存的是Object，因此你不仅可以通过ArrayList的add()方法将Apple对象放进这个容器，还可以添加Orange对象，而且无论在编译期还是运行时都不会有问题。当你在使用ArrayList的get()方法来取出你认为是Apple的对象时，你得到的只是Object引用，必须将其转型为Apple，因此，需要将整个表达式括起来，在调用Apple的id()方法之前，强制执行转型。否则，你就会得到语法错误。在运行时，当你试图将Orange对象转型为Apple时，你就会以前面提及的异常的形式得到一个错误。

在第15章中，你将会了解到，使用Java泛型来创建类会非常复杂。但是，应用预定义的泛型通常会很简单。例如，要想定义用来保存Apple对象的ArrayList，你可以声明ArrayList<Apple>，而不仅仅只是ArrayList，其中尖括号括起来的是类型参数（可以有多个），它指定了这个容器实例可以保存的类型。通过使用泛型，就可以在编译期防止将错误类型的对象放置到容器中[^3]。下面还是这个示例，但是使用了泛型：

![250-2](../Images/image02959.jpeg)

现在，编译器可以阻止你将Orange放置到apples中，因此它变成了一个编译期错误，而不再是运行时错误。

你还应该注意到，在将元素从List中取出时，类型转换也不再是必需的了。因为List知道它保存的是什么类型，因此它会在调用get()时替你执行转型。这样，通过使用泛型，你不仅知道编译器将会检查你放置到容器中的对象类型，而且在使用容器中的对象时，可以使用更加清晰的语法。

这个实例还表明，如果不需要使用每个元素的索引，你可以使用foreach语法来选择List中的每个元素。

当你指定了某个类型作为泛型参数时，你并不仅限于只能将该确切类型的对象放置到容器中。向上转型也可以像作用于其他类型一样作用于泛型：

![251-2](../Images/image02960.jpeg)

因此，你可以将Apple的子类型添加到被指定为保存Apple对象的容器中。

程序的输出是从Object默认的toString()方法产生的，该方法将打印类名，后面跟随该对象的散列码的无符号十六进制表示（这个散列码是通过hashCode()方法产生的）。你将在第17章中了解有关散列码的内容。

练习1：（2）创建一个新类Gerbil（沙鼠），包含int gerbilNumber，在构造器中初始化它（类似于本章的Mouse示例）。添加一个方法hop()，用以打印沙鼠的号码以及它正在跳跃的信息。创建一个ArrayList，并向其中添加一串Gerbil对象。使用get()遍历List，并且对每个Gerbil调用hop()。