### 20.2.5　实现处理器

下面是一个注解处理器的例子，它将读取一个类文件，检查其上的数据库注解，并生成用来创建数据库的SQL命令：

![660-1](../Images/image03626.jpeg)

![661-1](../Images/image03627.jpeg)

main()方法会处理命令行传入的每一个类名。使用forName()方法加载每一个类，并使用getAnnotation（DBTable.class）检查该类是否带有@DBTable注解。如果有，就将发现的表名保存下来。然后读取这个类的所有域，并用getDeclaredAnnotation()进行检查。该方法返回一个包含一个域上的所有注解的数组。最后用instanceof操作符来判断这些注解是否是@SQLIntege或@SQLString类型，如果是的话，在对应的处理块中将构造出相应cloumn名的字符串片断。注意，由于注解没有继承机制，所以要获得近似多态的行为，使用getDeclaredAnnotation()是唯一的办法。

嵌套中的@Constraint注解被传递给getConstraints()方法，由它负责构造一个包含SQL约束的String对象。

需要提醒读者的是，上面演示的技巧对于真实的对象/关系映射而言，是很幼稚的。例如使用@DBTable类型的注解，程序员以参数的形式给出表的名字，如果程序员想要修改表的名字，这将迫使其必须重新编译Java代码。这可不是我们希望看到的结果。现在已经有了很多可用的framework，可以将对象映射到关系数据库，并且，其中越来越多的framework已经开始利用注解了。

练习1：（2）为本节数据库的例子实现更多的SQL类型。

作业[^3]：修改数据库的例子，使其能够使用JDBC连接到一个真正的数据库，并与之交互。

作业：修改数据库的例子，令其生成XML构造文件，而不是SQL语句。