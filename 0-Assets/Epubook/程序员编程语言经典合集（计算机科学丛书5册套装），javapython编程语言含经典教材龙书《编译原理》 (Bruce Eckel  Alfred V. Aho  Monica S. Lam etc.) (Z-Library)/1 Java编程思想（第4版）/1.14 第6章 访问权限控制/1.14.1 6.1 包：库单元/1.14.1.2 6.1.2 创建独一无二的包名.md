### 6.1.2　创建独一无二的包名

读者也许会发现，既然一个包从未真正将被打包的东西包装成单一的文件，并且一个包可以由许多.class文件构成，那么情况就有点复杂了。为了避免这种情况的发生，一种合乎逻辑的做法就是将特定包的所有.class文件都置于一个目录下。也就是说，利用操作系统的层次化的文件结构来解决这一问题。这是Java解决混乱问题的一种方式，读者还会在我们介绍jar工具的时候看到另一种方式。

将所有的文件收入一个子目录还可以解决另外两个问题：怎样创建独一无二的名称以及怎样查找有可能隐藏于目录结构中某处的类。这些任务是通过将.class文件所在的路径位置编码成package的名称来实现的。按照惯例，package名称的第一部分是类的创建者的反顺序的Internet域名。如果你遵照惯例，Internet域名应是独一无二的，因此你的package名称也将是独一无二的，也就不会出现名称冲突的问题了（也就是说，只有在你将自己的域名给了别人，而他又以你曾经使用过的路径名称来编写Java程序代码时，才会出现冲突）。当然，如果你没有自己的域名，你就得构造一组不大可能与他人重复的组合（例如你的姓名），来创立独一无二的package名称。如果你打算发布你的Java程序代码，稍微花点力气去取得一个域名，还是很有必要的。

此技巧的第二部分是把package名称分解为你机器上的一个目录。所以当Java程序运行并且需要加载.class文件的时候，它就可以确定.class文件在目录上所处的位置。

Java解释器的运行过程如下：首先，找出环境变量CLASSPATH[^3]（可以通过操作系统来设置，有时也可通过安装程序-用来在你的机器上安装Java或基于Java的工具-来设置）。CLASSPATH包含一个或多个目录，用作查找.class文件的根目录。从根目录开始，解释器获取包的名称并将每个句点替换成反斜杠，以从CLASSPATH根中产生一个路径名称（于是，package foo.bar.baz就变成为foo\bar\baz或foo/bar/baz或其他，这一切取决于操作系统）。得到的路径会与CLASSPATH中的各个不同的项相连接，解释器就在这些目录中查找与你所要创建的类名称相关的.class文件。（解释器还会去查找某些涉及Java解释器所在位置的标准目录。）

为了理解这一点，以我的域名MindView.net为例。把它的顺序倒过来，并且将其全部转换为小写，net.mindview就成了我所创建的类的独一无二的全局名称。（com、edu、org等扩展名先前在Java包中都是大写的，但在Java2中一切都已改观，包的整个名称全都变成了小写。）若我决定再创建一个名为simple的类库，我可以将该名称进一步细分，于是我可以得到一个包的名称如下：

![145-1](../Images/image02793.jpeg)

现在，这个包名称就可以用作下面两个文件的名字空间保护伞了：

![145-2](../Images/image02794.jpeg)

如前所述，package语句必须是文件中的第一行非注释程序代码。第二个文件看起来也极其相似：

![145-3](../Images/image02795.jpeg)

这两个文件均被置于我的系统的子目录下：

![146-1](../Images/image02796.jpeg)

（注意，在本书的每一个文件中的第一行注释都指定了该文件在源代码目录树中的位置，这个信息将由针对本书的自动代码抽取工具使用。）

如果沿此路径往回看，可以看到包的名称com.bruceeckel.simple，但此路径的第一部分怎样办呢？它将由环境变量CLASSPATH关照，在我的机器上是：

![146-2](../Images/image02797.jpeg)

可以看到，CLASSPATH可以包含多个可供选择的查询路径。

但在使用JAR文件时会有一点变化。必须在类路径中将JAR文件的实际名称写清楚，而不仅是指明它所在位置的目录。因此，对于一个名为grape.jar的JAR文件，类路径应包括：

![146-3](../Images/image02798.jpeg)

一旦类路径得以正确建立，下面的文件就可以放于任何目录之下：

![146-4](../Images/image02799.jpeg)

当编译器碰到simple库的import语句时，就开始在CLASSPATH所指定的目录中查找，查找子目录net\mindview\simple，然后从已编译的文件中找出名称相符者（对Vector而言是Vector.class，对List而言是List.class）。请注意，Vector和List中的类以及要使用的方法都必须是public的。

对于使用Java的新手而言，设立CLASSPATH是很麻烦的一件事（我最初使用时就是这样的）；为此，Sun将Java2中的JDK改造得更聪明了一些。在安装后你会发现，即使你未设立CLASSPATH，你也可以编译并运行基本的Java程序。然而，要编译和运行本书的源码包（从https://www.mindviewllc.com网站可以取得），就得向你的CLASSPATH中添加本书程序代码树中的基目录了。

练习1：（1）在某个包中创建一个类，在这个类所处的包的外部创建该类的一个实例。

冲突

如果将两个含有相同名称的类库以“*”形式同时导入，将会出现什么情况呢？例如，假设某程序这样写：

![146-5](../Images/image02800.jpeg)

由于java.util.*也含有一个Vector类，这就存在潜在的冲突。但是只要你不写那些导致冲突的程序代码，就不会有什么问题-这样很好，否则就得做很多的类型检查工作来防止那些根本不会出现的冲突。

如果现在要创建一个Vector类的话，就会产生冲突：

![146-6](../Images/image02801.jpeg)

这行到底取用的是哪个Vector类？编译器不知道，读者同样也不知道。于是编译器提出错误信息，强制你明确指明。举例说明，如果想要一个标准的Java Vector类，就得这样写：

![147-1](../Images/image02802.jpeg)

由于这样可以完全指明该Vector类的位置（配合CLASSPATH），所以除非还要使用java.util中的其他东西，否则就没有必要写import java.util.*语句了。

或者，可以使用单个类导入的形式来防止冲突，只要你在同一个程序中没有使用有冲突的名字（在使用了有冲突名字的情况下，必须返回到指定全名的方式）。

练习2：（1）将本节中的代码片段改写为完整的程序，并校验实际所发生的冲突。