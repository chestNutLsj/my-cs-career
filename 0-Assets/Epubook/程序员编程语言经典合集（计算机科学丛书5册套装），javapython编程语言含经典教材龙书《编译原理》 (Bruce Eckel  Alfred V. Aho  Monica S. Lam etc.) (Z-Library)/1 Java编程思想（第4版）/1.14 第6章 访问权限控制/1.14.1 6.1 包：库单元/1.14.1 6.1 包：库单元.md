## 6.1　包：库单元

包内包含有一组类，它们在单一的名字空间之下被组织在了一起。

例如，在Java的标准发布中有一个工具库，它被组织在java.util名字空间之下。java.util中有一个叫做ArrayList的类，使用ArrayList的一种方式是用其全名java.util.ArrayList来指定。

![143-1](../Images/image02787.jpeg)

这立刻就使程序变得很冗长了，因此你可能想转而使用import关键字。如果你想要导入单个的类，可以在import语句中命名该类：

![143-2](../Images/image02788.jpeg)

现在，就可以不用限定地使用ArrayList了。但是，这样做java.util中的其他类仍旧是都不可用的。要想导入其中所有的类，只需要使用“*”，就像在本书剩余部分的示例中所看到的那样：

我们之所以要导入，就是要提供一个管理名字空间的机制。所有类成员的名称都是彼此隔离的。A类中的方法f()与B类中具有相同特征标记（参数列表）的方法f()不会彼此冲突。但是如果类名称相互冲突又该怎么办呢？假设你编写了一个Stack类并安装到了一台机器上，而该机器上已经有了一个别人编写的Stack类，我们该如何解决呢？由于名字之间的潜在冲突，在Java中对名称空间进行完全控制并为每个类创建唯一的标识符组合就成为了非常重要的事情。

到目前为止，书中大多数示例都存于单一文件之中，并专为本地使用（local use）而设计，因而尚未受到包名的干扰。这些示例实际上已经位于包中了：即未命名包，或称为默认包。这当然也是一种选择，而且为了简单起见，在本书其他部分都尽可能地使用了此方法。不过如果你正在准备编写对在同一台机器上共存的其他Java程序友好的类库或程序的话，就需要考虑如何防止类名称之间的冲突问题。

当编写一个Java源代码文件时，此文件通常被称为编译单元（有时也被称为转译单元）。每个编译单元都必须有一个后缀名.java，而在编译单元内则可以有一个public类，该类的名称必须与文件的名称相同（包括大小写，但不包括文件的后缀名.java）。每个编译单元只能有一个public类，否则编译器就不会接受。如果在该编译单元之中还有额外的类的话，那么在包之外的世界是无法看见这些类的，这是因为它们不是public类，而且它们主要用来为主public类提供支持。