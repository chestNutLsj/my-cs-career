## 9.1　抽象类和抽象方法

在第8章所有“乐器”的例子中，基类Instrument中的方法往往是“哑”（dummy）方法。若要调用这些方法，就会出现一些错误。这是因为Instrument类的目的是为它的所有导出类创建一个通用接口。

在那些示例中，建立这个通用接口的唯一理由是，不同的子类可以用不同的方式表示此接口。通用接口建立起一种基本形式，以此表示所有导出类的共同部分。另一种说法是将Instrument类称作抽象基类，或简称抽象类。

如果我们只有一个像Instrument这样的抽象类，那么该类的对象几乎没有任何意义。我们创建抽象类是希望通过这个通用接口操纵一系列类。因此，Instrument只是表示了一个接口，没有具体的实现内容；因此，创建一个Instrument对象没有什么意义，并且我们可能还想阻止使用者这样做。通过让Instrument中的所有方都产生错误，就可以实现这个目的。但是这样做会将错误信息延迟到运行时才获得，并且需要在客户端进行可靠、详尽的测试。所以最好是在编译时捕获这些问题。

为此，Java提供一个叫做抽象方法[^1]的机制，这种方法是不完整的；仅有声明而没有方法体。下面是抽象方法声明所采用的语法：

![202-1](../Images/image02886.jpeg)

包含抽象方法的类叫做抽象类。如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的。（否则，编译器就会报错。）

如果一个抽象类不完整，那么当我们试图产生该类的对象时，编译器会怎样处理呢？由于为抽象类创建对象是不安全的，所以我们会从编译器那里得到一条出错消息。这样，编译器会确保抽象类的纯粹性，我们不必担心会误用它。

如果从一个抽象类继承，并想创建该新类的对象，那么就必须为基类中的所有抽象方法提供方法定义。如果不这样做（可以选择不做），那么导出类便也是抽象类，且编译器将会强制我们用abstract关键字来限定这个类。

我们也可能会创建一个没有任何抽象方法的抽象类。考虑这种情况：如果有一个类，让其包含任何abstract方法都显得没有实际意义，而且我们也想要阻止产生这个类的任何对象，那么这时这样做就很有用了。

第8章Instrument类可以很容易地转化成abstract类。既然使某个类成为抽象类并不需要所有的方法都是抽象的，所以仅需将某些方法声明为抽象的即可。如下图所示：

![203-1](../Images/image02887.jpeg)

下面是修改过的“管弦乐器”的例子，其中采用了抽象类和抽象方法：

![203-2](../Images/image02888.jpeg)

![204-1](../Images/image02889.jpeg)

我们可以看出，除了基类，实际上并没有什么改变。

创建抽象类和抽象方法非常有用，因为它们可以使类的抽象性明确起来，并告诉用户和编译器打算怎样来使用它们。抽象类还是很有用的重构工具，因为它们使得我们可以很容易地将公共方法沿着继承层次结构向上移动。

练习1：（1）修改第8章练习9中的Rodent，使其成为一个抽象类。只要有可能，就将Rodent的方法声明为抽象方法。

练习2：（1）创建一个不包含任何抽象方法的抽象类，并验证我们不能为该类创建任何实例。

练习3：（2）创建一个基类，让它包含抽象方法print()，并在导出类中覆盖该方法。覆盖后的方法版本可以打印导出类中定义的某个整型变量的值。在定义该变量之处，赋予它非零值。在基类的构造器中调用这个方法。现在，在main()方法中，创建一个导出类对象，然后调用它的print()方法。请解释发生的情形。

练习4：（3）创建一个不包含任何方法的抽象类，从它那里导出一个类，并添加一个方法。创建一个静态方法，它可以接受指向基类的引用，将其向下转型到导出类，然后再调用该静态方法。在main()中，展现它的运行情况。然后，为基类中的方法加上abstract声明，这样就不再需要进行向下转型。