## 19.4　values()的神秘之处

前面已经提到，编译器为你创建的enum类都继承自Enum类。然而，如果你研究一下Enum类就会发现，它并没有values()方法。可我们明明已经用过该方法了，难道存在某种“隐藏的”方法吗？我们可以利用反射机制编写一个简单的程序，来查看其中的究竟：

![627-1](../Images/image03573.jpeg)

![628-1](../Images/image03574.jpeg)

答案是，values()是由编译器添加的static方法。可以看出，在创建Explore的过程中，编译器还为其添加了valueOf()方法。这可能有点令人迷惑，Enum类不是已经有valueOf()方法了吗。不过Enum中的valueOf()方法需要两个参数，而这个新增的方法只需一个参数。由于这里使用的Set只存储方法的名字，而不考虑方法的签名，所以在调用Explore.removeAll（Enum）之后，就只剩下[values]了。

从最后的输出中可以看到，编译器将Explore标记为final类，所以无法继承自enum。其中还有一个static的初始化子句，稍后我们将学习如何重定义该句。

由于擦除效应（在第15章中介绍过），反编译无法得到Enum的完整信息，所以它展示的Explore的父类只是一个原始的Enum，而非事实上的Enum<Explore>。

由于values()方法是由编译器插入到enum定义中的static方法，所以，如果你将enum实例向上转型为Enum，那么values()方法就不可访问了。不过，在Class中有一个getEnumConstants()方法，所以即便Enum接口中没有values()方法，我们仍然可以通过Class对象取得所有enum实例：

![628-2](../Images/image03575.jpeg)

因为getEnumConstants()是Class上的方法，所以你甚至可以对不是枚举的类调用此方法：

![628-3](../Images/image03576.jpeg)

只不过，此时该方法返回null，所以当你试图使用其返回的结果时会发生异常。