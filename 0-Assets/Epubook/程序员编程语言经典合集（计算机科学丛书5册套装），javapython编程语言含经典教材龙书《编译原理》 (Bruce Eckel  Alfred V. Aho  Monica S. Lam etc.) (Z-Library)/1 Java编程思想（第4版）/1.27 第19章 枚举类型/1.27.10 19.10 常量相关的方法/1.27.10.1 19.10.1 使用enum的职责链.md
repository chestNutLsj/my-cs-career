### 19.10.1　使用enum的职责链

在职责链（Chain of Responsibility）设计模式中，程序员以多种不同的方式来解决一个问题，然后将它们链接在一起。当一个请求到来时，它遍历这个链，直到链中的某个解决方案能够处理该请求。

通过常量相关的方法，我们可以很容易地实现一个简单的职责链。我们以一个邮局的模型为例。邮局需要以尽可能通用的方式来处理每一封邮件，并且要不断尝试处理邮件，直到该邮件最终被确定为一封死信。其中的每一次尝试可以看作为一个策略（也是一个设计模式），而完整的处理方式列表就是一个职责链。

我们先来描述一下邮件。邮件的每个关键特征都可以用enum来表示。程序将随机地生成Mail对象，如果要减小一封邮件的GeneralDelivery为YES的概率，那最简单的方法就是多创建几个不是YES的enum实例，所以enum的定义看起来有点古怪。

我们看到Mail中有一个randomMail()方法，它负责随机地创建用于测试的邮件。而generator()方法生成一个Iterable对象，该对象在你调用next()方法时，在其内部使用randomMail()来创建Mail对象。这样的结构使程序员可以通过调用Mail.generator()方法，很容易地构造出一个foreach循环：

![639-2](../Images/image03596.jpeg)

![640-1](../Images/image03597.jpeg)

![641-1](../Images/image03598.jpeg)

![642-1](../Images/image03599.jpeg)

职责链由enum MailHandler实现，而enum定义的次序决定了各个解决策略在应用时的次序。对每一封邮件，都要按此顺序尝试每个解决策略，直到其中一个能够成功地处理该邮件，如果所有的策略都失败了，那么该邮件将被判定为一封死信。

练习8：（6）修改PostOffice.java，使其能够转发邮件。

练习9：（5）修改class PostOffice，使其能够使用EnumMap。

作业[^2]：专用程序设计语言，例如Prolog，使用反向链来解决类似的问题。试用PostOffice.java做一个例子，研究一下这些语言，用其编写一个扩展性更好的程序，使程序员可以很容易地向系统中添加新的“规则”。