### 19.11.1　使用enum分发

直接将RoShamBo1.java翻译为基于enum的版本是有问题的，因为enum实例不是类型，不能将enum实例作为参数的类型，所以无法重载eval()方法。不过，还有很多方式可以实现多路分发，并从enum中获益。

一种方式是使用构造器来初始化每个enum实例，并以“一组”结果作为参数。这二者放在一块，形成了类似查询表的结构：

![648-1](../Images/image03607.jpeg)

在compete()方法中，一旦两种类型都被确定了，那么唯一的操作就是返回结果Outcome。然而，你可能还需要调用其他的方法，（例如）甚至是调用在构造器中指定的某个命令对象上的方法。

RoShamBo2.java比之前的例子短小得多，而且更直接，更易于理解。注意，我们仍然是使用两路分发来判定两个对象的类型。在RoShamBo1.java中，两次分发都是通过实际的方法调用实现，而在这个例子中，只有第一次分发是实际的方法调用。第二个分发使用的是switch，不过这样做是安全的，因为enum限制了switch语句的选择分支。

在代码中，enum被单独抽取出来，因此它可以应用在其他例子中。首先，Competitor接口定义了一种类型，该类型的对象可以与另一个Competitor相竞争：

![649-2](../Images/image03608.jpeg)

然后，我们定义两个static方法（static可以避免显式地指明参数类型）。第一个是match()方法，它会为一个Competitor对象调用compete()方法，并与另一个Competitor对象作比较。在这个例子中，我们看到，match()方法的参数需要是Competitor<T>类型。但是在play()方法中，类型参数必须同时是Enum<T>类型（因为它将在Enums.random()中使用）和Competitor<T>类型（因为它将被传递给match()方法）：

![649-3](../Images/image03609.jpeg)

play()方法没有将类型参数T作为返回值类型，因此，似乎我们应该在Class<T>中使用通配符来代替上面的参数声明。然而，通配符不能扩展多个基类，所以我们必须采用以上的表达式。