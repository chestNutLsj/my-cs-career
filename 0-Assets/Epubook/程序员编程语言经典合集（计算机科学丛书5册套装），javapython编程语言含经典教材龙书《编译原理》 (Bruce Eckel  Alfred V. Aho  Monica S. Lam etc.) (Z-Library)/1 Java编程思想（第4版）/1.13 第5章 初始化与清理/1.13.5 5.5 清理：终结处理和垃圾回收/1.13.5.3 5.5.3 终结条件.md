### 5.5.3　终结条件

通常，不能指望finalize()，必须创建其他的“清理”方法，并且明确地调用它们。看来，finalize()只能存在于程序员很难用到的一些晦涩用法里了。不过，finalize()还有一个有趣的用法，它并不依赖于每次都要对finalize()进行调用，这就是对象终结条件[^4]的验证。

当对某个对象不再感兴趣——也就是它可以被清理了，这个对象应该处于某种状态，使它占用的内存可以被安全地释放。例如，要是对象代表了一个打开的文件，在对象被回收前程序员应该关闭这个文件。只要对象中存在没有被适当清理的部分，程序就存在很隐晦的缺陷。finalize()可以用来最终发现这种情况——尽管它并不总是会被调用。如果某次finalize()的动作使得缺陷被发现，那么就可据此找出问题所在——这才是人们真正关心的。

以下是个简单的例子，示范了finalize()可能的使用方式：

![122-1](../Images/image02744.jpeg)

本例的终结条件是：所有的Book对象在被当作垃圾回收前都应该被签入（check in）。但在main()方法中，由于程序员的错误，有一本书未被签入。要是没有finalize()来验证终结条件，将很难发现这种缺陷。

注意，System.gc()用于强制进行终结动作。即使不这么做，通过重复地执行程序（假设程序将分配大量的存储空间而导致垃圾回收动作的执行），最终也能找出错误的Book对象。

你应该总是假设基类版本的finalize()也要做某些重要的事情，因此要使用super来调用它，就像在Book.finalize()中看到的那样。在本例中，它被注释掉了，因为它需要进行异常处理，而我们还没有介绍过这部分内容。

练习10：（2）编写具有finalize()方法的类，并在方法中打印消息。在main()中为该类创建一个对象。试解释这个程序的行为。

练习11：（4）修改前一个练习的程序，让你的finalize()总会被调用。

练习12：（4）编写名为Tank的类，此类的状态可以是“满的”或“空的”。其终结条件是：对象被清理时必须处于空状态。请编写finalize()以检验终结条件是否成立。在main()中测试Tank可能发生的几种使用方式。