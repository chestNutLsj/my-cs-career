### 5.5.1　finalize()的用途何在

此时，读者已经明白了不该将finalize()作为通用的清理方法。那么，finalize()的真正用途是什么呢？

这引出了要记住的第三点：

3. 垃圾回收只与内存有关。

也就是说，使用垃圾回收器的唯一原因是为了回收程序不再使用的内存。所以对于与垃圾回收有关的任何行为来说（尤其是finalize()方法），它们也必须同内存及其回收有关。

但这是否意味着要是对象中含有其他对象，finalize()就应该明确释放那些对象呢？不，无论对象是如何创建的，垃圾回收器都会负责释放对象占据的所有内存。这就将对finalize()的需求限制到一种特殊情况，即通过某种创建对象方式以外的方式为对象分配了存储空间。不过，读者也看到了，Java中一切皆为对象，那这种特殊情况是怎么回事呢？

看来之所以要有finalize()，是由于在分配内存时可能采用了类似C语言中的做法，而非Java中的通常做法。这种情况主要发生在使用“本地方法”的情况下，本地方法是一种在Java中调用非Java代码的方式（关于本地方法的讨论见本书电子版第2版，在https://www.mindviewllc.com网站上有收录）。本地方法目前只支持C和C++，但它们可以调用其他语言写的代码，所以实际上可以调用任何代码。在非Java代码中，也许会调用C的malloc()函数系列来分配存储空间，而且除非调用了free()函数，否则存储空间将得不到释放，从而造成内存泄露。当然，free()是C和C++中的函数，所以需要在finalize()中用本地方法调用它。

至此，读者或许已经明白了不要过多地使用finalize()的道理了[^3]。对，它确实不是进行普通的清理工作的合适场所。那么，普通的清理工作应该在哪里执行呢？