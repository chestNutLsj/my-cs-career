### 5.8.1　可变参数列表

第二种形式提供了一种方便的语法来创建对象并调用方法，以获得与C的可变参数列表（C通常把它简称为varargs）一样的效果。这可以应用于参数个数或类型未知的场合。由于所有的类都直接或间接继承于Object类（随着本书的进展，读者会对此有更深入的认识），所以可以创建以Object数组为参数的方法，并像下面这样调用：

![135-1](../Images/image02773.jpeg)

可以看到print()方法使用Object数组作为参数，然后使用foreach语法遍历数组，打印每个对象。标准Java库中的类能输出有意义的内容，但这里建立的类的对象，打印出的内容只是类的名称以及后面紧跟着的一个@符号以及多个十六进制数字。于是，默认行为（如果没有定义toString()方法的话，后面会讲这个方法的）就是打印类的名字和对象的地址。

你可能看到过像上面这样编写的Java SE5之前的代码，它们可以产生可变的参数列表。然而，在Java SE5中，这种盼望已久的特性终于添加了进来，因此你现在可以使用它们来定义可变参数列表了，就像在printArray()中看到的那样：

![135-2](../Images/image02774.jpeg)

有了可变参数，就再也不用显式地编写数组语法了，当你指定参数时，编译器实际上会为你去填充数组。你获取的仍旧是一个数组，这就是为什么print()可以使用foreach来迭代该数组的原因。但是，这不仅仅只是从元素列表到数组的自动转换，请注意程序中倒数第二行，一个Integer数组（通过使用自动包装而创建的）被转型为一个Object数组（以便移除编译器警告信息），并且传递给了printArray()。很明显，编译器会发现它已经是一个数组了，所以不会在其上执行任何转换。因此，如果你有一组事物，可以把它们当作列表传递，而如果你已经有了一个数组，该方法可以把它们当作可变参数列表来接受。

该程序的最后一行表明将0个参数传递给可变参数列表是可行的，当具有可选的尾随参数时，这一特性就会很有用：

![136-2](../Images/image02775.jpeg)

这个程序还展示了你可以如何使用具有Object之外类型的可变参数列表。这里所有的可变参数都必须是String对象。在可变参数列表中可以使用任何类型的参数，包括基本类型。下面的例子也展示了可变参数列表变为数组的情形，并且如果在该列表中没有任何元素，那么转变成的数据的尺寸为0：

![136-3](../Images/image02776.jpeg)

getClass()方法属于Object的一部分，我们将在第14章中做全面介绍。它将产生对象的类，并且在打印该类时，可以看到表示该类类型的编码字符串。前导的“[”表示这是一个后面紧随的类型的数组，而紧随的“I”表示基本类型int。为了进行双重检查，我在最后一行创建了一个int数组，并打印了其类型。这样也就验证了使用可变参数列表不依赖于自动包装机制，而实际上使用的是基本类型。

然而，可变参数列表与自动包装机制可以和谐共处，例如：

![137-2](../Images/image02777.jpeg)

请注意，你可以在单一的参数列表中将类型混合在一起，而自动包装机制将有选择地将int参数提升为Integer。

可变参数列表使得重载过程变得复杂了，尽管乍一看会显得足够安全：

![137-3](../Images/image02778.jpeg)

在每一种情况中，编译器都会使用自动包装机制来匹配重载的方法，然后调用最明确匹配的方法。

但是在不使用参数调用f()时，编译器就无法知道应该调用哪一个方法了。尽管这个错误可以弄清楚，但是它可能会使客户端程序员大感意外。

你可能会通过在某个方法中增加一个非可变参数来解决该问题：

![138-2](../Images/image02779.jpeg)

{CompileTimeError}注释标签把该文件排除在了本书的Ant构建之外。如果你手动编译它，就会得到下面的错误消息：

![138-3](../Images/image02780.jpeg)

如果你给这两个方法都添加一个非可变参数，就可以解决问题了：

![138-4](../Images/image02781.jpeg)

你应该总是只在重载方法的一个版本上使用可变参数列表，或者压根就不是用它。

练习19：（2）写一个类，它接受一个可变参数的String数组。验证你可以向该方法传递一个用逗号分隔的String列表，或是一个String[]。

练习20：（1）创建一个使用可变参数列表而不是普通的main()语法的main()。打印所产生的args数组的所有元素，并用各种不同数量的命令行参数来测试它。