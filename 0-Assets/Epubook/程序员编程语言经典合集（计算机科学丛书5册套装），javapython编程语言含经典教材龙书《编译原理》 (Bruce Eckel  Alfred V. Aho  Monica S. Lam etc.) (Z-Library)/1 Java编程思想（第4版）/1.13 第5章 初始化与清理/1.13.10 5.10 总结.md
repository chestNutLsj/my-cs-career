## 5.10　总结

构造器，这种精巧的初始化机制，应该给了读者很强的暗示：初始化在Java中占有至关重要的地位。C++的发明人Bjarne Stroustrup在设计C++期间，在针对C语言的生产效率所进行的最初调查中发现，大量编程错误都源于不正确的初始化。这种错误很难发现，并且不恰当的清理也会导致类似问题。构造器能保证正确的初始化和清理（没有正确的构造器调用，编译器就不允许创建对象），所以有了完全的控制，也很安全。

在C++中，“析构”相当重要，因为用new创建的对象必须明确被销毁。在Java中，垃圾回收器会自动为对象释放内存，所以在很多场合下，类似的清理方法在Java中就不太需要了（不过当要用到的时候，你就只能自己动手了）。在不需要类似析构函数的行为的时候，Java的垃圾回收器可以极大地简化编程工作，而且在处理内存的时候也更安全。有些垃圾回收器甚至能清理其他资源，比如图形和文件句柄。然而，垃圾回收器确实也增加了运行时的开销。而且Java解释器从来就很慢，所以这种开销到底造成了多大的影响也很难看出。随着时间的推移，Java在性能方面已经取得了长足的进步，但速度问题仍然是它涉足某些特定编程领域的障碍。

由于要保证所有对象都被创建，构造器实际上要比这里所讨论的更复杂。特别当通过组合或继承生成新类的时候，这种保证仍然成立，并且需要一些附加的语法来提供支持。在后面的章节中，读者将学习到有关组合、继承以及它们对构造器造成的影响等方面的知识。

所选习题的答案都可以在名为The Thinking in Java Annotated Solution Guide的电子文档中找到，读者可以从https://www.mindviewllc.com购买此文档。

---

[^1]: 有些人执意将this放在每一个方法调用和字段引用前，认为这样“更清楚更明确”。但是，千万别这么做。我们使用高级语言的原因之一就是它们能帮我们做一些事情。要是你把this放在一些没必要的地方，就会使读你程序的人不知所措，因为别人写的代码不会到处使用this。人们期望只在必要处使用this。遵循一种一致而直观的编程风格能节省时间和金钱。

[^2]: 这不是完全不可能。如果你传递一个对象的引用到静态方法里（静态方法可以创建其自身的对象），然后通过这个引用（和this效果相同），你就可以调用非静态方法和访问非静态数据成员了。但通常要达到这样的效果，你只需写一个非静态方法即可。

[^3]: Joshua Bloch在题为“避免使用终结函数”一节中走的更远，他提到：“终结函数无法预料，常常是危险的，总之是多余的。”《Effective Java》，第20页，（Addison-Wesley 2001）。

[^4]: 这个术语是在由Bill Venners（www.artima.com）和我一同开的培训班上发明的。

[^5]: 当然，每次访问数组的时候都要检查边界的做法在时间和代码上都是需要开销的，但是无法禁用这个功能。这意味着如果数组访问发生在一些关键节点上，它们有可能会成为导致程序效率低下的原因之一。但是基于“因特网的安全以及提高程序员生产力”的理由，Java的设计者认为这种权衡是值得的。尽管你可能会受到诱惑，去编写你认为可以使得数组访问效率提高的代码，但是这一切都是在浪费时间，因为自动的编译期错误和运行时优化都可以提高数组访问的速度。