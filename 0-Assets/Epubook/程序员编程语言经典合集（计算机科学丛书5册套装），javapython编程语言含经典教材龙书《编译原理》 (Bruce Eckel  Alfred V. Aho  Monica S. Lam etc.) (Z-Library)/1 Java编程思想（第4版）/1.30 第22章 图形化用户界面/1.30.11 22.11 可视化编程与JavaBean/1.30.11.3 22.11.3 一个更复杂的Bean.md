### 22.11.3　一个更复杂的Bean

下面的例子稍微复杂一些（虽然它并不是很重要）。它是一个JPanel，当鼠标移动的时候，可以在鼠标周围绘制小圆圈。当你按下鼠标，单词“Bang！”将出现在屏幕的中央，并且触发一个动作监听器。

你可以改变的属性包括：圆圈的大小，当按下鼠标时所显示的单词的颜色、大小和文本。BangBean类还具有addActionListener()和removeActionListener()，所以你可以自己编写监听器并与之关联，当用户在BangBean上单击的时候，你的监听器就会被触发。你应该能够识别它们支持的属性和事件：

![862-2](../Images/image03886.jpeg)

![863-1](../Images/image03887.jpeg)

首先注意到的是，BangBean实现了Serializable接口。这就意味着IDE构建工具能够在程序设计者调整属性之后，通过对象序列化机制“保存”（pickle）BangBean的所有信息。在作为运行程序的组件创建这个Bean的时候，这些保存过的属性能够被恢复，这样你就得到了与设计时一致的Bean。

观察addActionListener()方法的特征签名，就会发现它可以抛出TooManyListenersException异常。这表明它只支持单路的事件处理方式，即事件发生的时候它只能通知一个监听器。通常，你会使用支持多路方式的组件，这样一个事件可以通知给多个监听器。不过，这样会牵涉到线程问题，我们将在14.14.4节研究这个问题。同时，单路事件处理方式就可以回避这个问题。

当单击鼠标时，文字将显示在BangBean的中央，此时如果actionListener字段非空，它的actionPerformed()方法将被调用，调用之前要创建一个新的ActionEvent对象。当鼠标移动的时候，新的坐标将被捕获，并且重新绘制窗体（如你所见，擦除窗体上的任何文字）。

下面是测试Bean的BangBeanTest类：

![864-1](../Images/image03888.jpeg)

当Bean处于IDE中时，不必使用这个类，不过为你的每个Bean提供一种快速的测试方法会很有帮助。BangBeanTest将把一个BangBean对象放在applet内，给BangBean对象关联一个简单的ActionListener（动作监听器），当ActionEvent事件发生的时候，监听器能把事件计数显示到JTextField。当然，通常应用程序构建工具会帮助创建使用Bean的大部分代码。

当通过BeanDumper查询BangBean，或者把BangBean放置在支持Bean的开发环境中时，显示出的属性和动作将比上面代码中编写的要多许多。这是因为BangBean继承自JPanel，而JPanel也是一个Bean，所以你会看到所有的属性和事件。

练习35：（6）在因特网上查找并下载几个免费的GUI构建工具，或者如果你有的话就使用商业产品，研究一下要把BangBean导入这个环境并使用它，需要哪些必要的步骤。