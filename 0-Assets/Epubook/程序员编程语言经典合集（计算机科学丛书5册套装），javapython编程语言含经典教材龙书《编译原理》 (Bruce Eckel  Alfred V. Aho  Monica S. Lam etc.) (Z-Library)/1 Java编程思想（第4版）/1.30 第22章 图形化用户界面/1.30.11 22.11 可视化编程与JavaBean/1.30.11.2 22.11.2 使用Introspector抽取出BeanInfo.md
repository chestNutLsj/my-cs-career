### 22.11.2　使用Introspector抽取出BeanInfo

JavaBean模式的最关键部分之一，表现在当你从选用区拖动一个Bean，然后把它放置到窗体上的时候。IDE构建工具必须能够创建这个Bean（如果有默认构造器就可以创建），然后在不访问Bean的源代码的情况下抽取出所有必要信息，以创建属性和事件处理器的列表。

部分解决方案在第14章就出现了：Java的反射机制能发现未知类的所有方法。对于解决JavaBean的这个问题，这是个完美的方案，你不用像其他可视化编程语言那样使用任何语言附加的关键字。实际上，Java语言里加入反射机制的主要原因之一就是为了支持JavaBean（尽管反射也支持对象序列化和远程方法调用）。所以，你也许会认为IDE构建工具的编写者将使用反射来抽取Bean的方法，然后在方法里面查找出Bean的属性和事件。

这当然是可行的，不过Java的设计者希望提供一个标准工具，不仅要使Bean用起来简单，而且对于创建更复杂的Bean也能够提供一个标准方法。这个工具就是Introspector（内省器）类，这个类最重要的就是静态的getBeanInfo()方法。向这个方法传递一个Class对象引用，它能够完全侦测这个类，然后返回一个BeanInfo对象，可以通过这个对象得到Bean的属性、方法和事件。

通常，你不用关心这些问题；也许能直接从货架上获得大多数想用的Bean，而不必知道底层的细节。你只需把Bean拖动到窗体上，配置它们的属性，然后为感兴趣的事件编写处理程序即可。不过，使用Introspector来显示Bean的信息是个值得学习的练习。下面就是这个工具：

![859-1](../Images/image03881.jpeg)

![860-1](../Images/image03882.jpeg)

BeanDumper.dump()方法执行了所有工作。首先，它试图创建一个BeanInfo对象，成功的话，就调用BeanInfo的方法得到有关其属性、方法和事件的信息。你会发现Introspector.getBeanInfo()方法有第二个参数，它用来告诉Introspector在哪个继承层次上停止查询。因为我们不关心来自Object的方法，所以这里的参数让Introspector在解析来自Object的所有方法前停止查询。

对于属性来说，getPropertyDescriptors()返回类型为PropertyDescriptor的数组，你可以针对每一个PropertyDescriptor都调用getPropertyType()来得到“通过属性方法设置和返回的对象”的类型。然后，针对每个属性，你可以通过getName()方法得到它的别名（从方法名中抽取），通过getReadMethod()方法得到读方法，通过getWriteMethod()方法得到写方法。后两个方法返回Method对象，它们能够用来在对象上调用相应的方法（这是反射的一部分）。

对于公共方法（包括属性方法），getMethodDescriptors()方法返回类型为MethodDescriptor的数组。对于数组的每个元素，你可以得到相关联的Method对象，并显示它们的名称。

对于事件，getEventSetDescriptors()方法返回类型为EventSetDescriptor（或是别的什么）的数组。可以对数组中的每一个元素进行查询，以得到监听器的类型、监听器类的方法，以及添加和移除监听器的方法。BeanDumper程序显示了所有这些信息。

在启动之后，程序强制评估frogbean.Frog。下面是程序输出，这里移除了不必要的额外细节：

![860-2](../Images/image03883.jpeg)

![861-1](../Images/image03884.jpeg)

![862-1](../Images/image03885.jpeg)

这里列出的是Introspector能够观察到的从你的Bean中产生的BeanInfo对象中的大多数信息。可以观察到属性的类型和名称相互独立。注意属性名称使用小写字母（唯一例外的情况是，属性名称以连续多个大写字母开头）。记住，你在这里看到的方法名称（比如读和写方法），是从Method对象中得到的，它可以用来在对象上调用相关联的方法。

公共方法列表中既包括了那些与属性或事件无关的方法，比如croak()，也包括了那些与属性或事件有关的方法。这些就是你可以通过编程在Bean上调用的所有方法，并且，为了让你的工作更容易，IDE构建工具可以在你编写方法调用的时候，显示这个列表。

最后，你可以发现所有事件都被完全地解析了出来，包括相关的监听器、它的方法，以及添加和移除监听器所用的方法。基本上，一旦你获得了BeanInfo对象，你就可以得到Bean的所有重要信息。你还能够调用Bean上的方法，甚至在除了对象以外（这里又是反射的功能）再没有其他任何信息的情况下，也能够这么做。