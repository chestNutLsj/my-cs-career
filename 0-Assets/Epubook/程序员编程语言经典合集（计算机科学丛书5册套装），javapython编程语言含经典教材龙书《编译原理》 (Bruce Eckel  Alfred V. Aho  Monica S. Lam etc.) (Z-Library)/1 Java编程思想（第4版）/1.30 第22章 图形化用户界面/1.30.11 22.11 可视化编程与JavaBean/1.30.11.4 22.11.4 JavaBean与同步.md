### 22.11.4　JavaBean与同步

当创建Bean的时候，必须要假设它可能会在多线程环境下运行。也就是说：

1）尽可能地让Bean中的所有公共方法都是synchronized（同步）的。当然，这将导致synchronized的运行时开销（在近几个版本的JDK中，这个开销已经大大降低了）。如果这么做会有问题，那么对那些不会导致临界区域问题的方法，可以考虑不同步。但要记住，这些方法并非总是这么容易做出判断。进行同步的方法应该尽可能短（比如下面例子中的getCircleSize()方法），并且（或者）是“原子的”——原子性是指，在调用含有这一小段代码的方法时，对象不能被改变（但是回顾一下第21章，你认为是原子性的代码也许并不具有原子性）。不同步这样的方法也许不会对程序的执行速度有明显的效果。所以最好是同步Bean的所有公共方法，只有在确实会有明显效果并且你可以安全地移除时，才在一个方法上移除synchronized关键字。

2）当一个多路事件触发了一组对该事件感兴趣的监听器时，你必须假定，在你遍历列表进行通知的同时，监听器可能会被添加或移除。

第一点很容易处理，但第二点就需要做更多的思考。前面版本的BangBean.java通过忽略synchronized关键字并使用单路事件处理方式，回避了并发问题。下面是修改后的版本，它可以在多线程环境下工作，而且使用了多路事件处理方式：

![865-1](../Images/image03889.jpeg)

![866-1](../Images/image03890.jpeg)

给方法加上synchronized关键字很容易。不过要注意，在addActionListener()和removeActionListener()方法中，现在要从ArrayList添加或移除ActionListener，所以你可以添加任意多的监听器。

可以观察到notifyListeners()方法没有被同步。这个方法可以同时被多个线程调用。在调用notifyListeners()期间，也可能有别的线程在对addActionListener()或removeActionListener()进行调用，这将遍历actionListeners的这个ArrayList，所以就可能发生冲突。为了解决这个问题，先在一个同步子句里对ArrayList进行复制，可以通过使用ArrayList的构造器来实现，因为它会复制其参数中的元素，然后对复制的对象进行遍历。这样，就可以操作原来那个ArrayList而不会对notifyListeners()过程有影响了。

paintComponent()方法也没有被同步。判断是否同步覆盖后的方法并不像判断自己写的方法那么明显。在本例中表明，无论是否同步，paintComponent()方法看起来工作都正常。不过你必须考虑这些问题：

1）这个方法会修改对象中“关键”变量的状态吗？要弄清楚变量是否“关键”，必须判断它们是否被程序中的其他线程读写。（在本例中，读写操作基本上是通过同步方法进行的，所以你检查这些就可以了。）在paintComponent()方法中，就没有进行任何修改操作。

2）这个方法依赖于那些“关键”变量吗？如果有某个同步方法会修改此方法所使用的变量，那么你应该把这个方法也同步。根据这一点，你会发现cSize被同步方法所改变，所以paintComponent()方法应该被同步。不过，这里还可以问自己，“如果cSize在调用paintComponent()的过程中被改变，最坏的结果是什么？”要是觉得问题不大，这种改变只起瞬时作用，你就可以作出不同步paintComponent()方法的决定，以避免同步方法调用所产生的额外开销。

3）第三个线索是查看基类版本的paintComponent()是否同步，在这里并没有被同步。这不是种严密的判断方法，只是一个线索。比如在本例中，由同步方法所改变的字段（比如cSize）已经混在paintComponent()的公式中了，在这种情况下它有可能会被改变。不过，请注意，同步不会继承；也就是说，如果基类方法是同步的，派生类中覆盖后的版本并非自动同步。

4）paint()和paintComponent()的执行必须尽可能快。要尽量把处理的开销移到方法外面，所以要是发现需要同步这些方法，那么你的设计可能就存在问题。

与BangBeanTest相比，main()里面的测试代码已经被修改过了，它通过添加额外的监听器，来演示BangBean2的多路事件处理能力。