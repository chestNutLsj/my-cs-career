### 22.8.13　菜单

每个能够持有菜单的组件，包括JApplet、JFrame、JDialog以及它们的子类，它们都有一个setJMenuBar()方法，它接受一个JMenuBar对象（某个特定组件只能持有一个JMenuBar对象）作为参数。你先把JMenu对象添加到JMenuBar中，然后把JMenuItem添加到JMenu中。每个JMenuItem都能有一个相关联的ActionListener，用来捕获菜单项被选中时所触发的事件。

在Java和Swing中，必须在源代码中构造所有的菜单。下面是个非常简单的菜单例子：

![831-1](../Images/image03845.jpeg)

程序中通过取模运算“i%3”把菜单项分配给三个JMenu。每个JMenuItem必须有一个相关联的ActionListener；这里使用了同一个ActionListener，不过通常要为每个JMenuItem单独准备一个ActionListener。

JMenuItem从AbstractButton继承而来，所以它具有类似按钮的行为。它提供了一个可以单独放置在下拉菜单上的条目。还有三种类型继承自JMenuItem：JMenu用来持有其他的JMenuItem（这样才能实现层叠式菜单）；JCheckBoxMenuItem提供了一个复选标记，用来表明菜单项是否被选中；JRadioButtonMenuItem包含了一个单选按钮。

下面是一个更复杂的创建菜单的例子，这里仍然是冰激凌口味的例子。这个例子还演示了层叠式菜单、键盘快捷键、JCheckBoxMenuItem，以及动态改变菜单的方法：

![832-1](../Images/image03846.jpeg)

![833-1](../Images/image03847.jpeg)

![834-1](../Images/image03848.jpeg)

在这个程序中，我把菜单项放到了几个数组中，然后通过遍历这些数组，并为每个JMenuItem调用add()方法的方式，将它们添加到菜单中。这种方式让添加或减少菜单项不至于太乏味。

程序中不是创建了一个而是创建了两个JMenuBar，用以演示程序运行期间可以动态替换菜单条。你可以看到如何用JMenu构造JMenuBar，以及用JMenuItem、JCheckBoxMenuItem甚至其他JMenu（产生子菜单）来构成每个JMenu。当构造完一个JMenuBar后，可以使用setJMenuBar()方法把它安装到当前程序上。注意，当按钮按下的时候，它将通过调用getJMenuBar()来判断当前安装的是哪一个菜单条，然后换成另一个菜单条。

在测试Open菜单项的时候，要注意拼写和大小写是很关键的，如果没有任何匹配的Open，Java也不会报告任何错误。这种类型的字符串比较是造成程序错误的根源之一。

菜单项的选中和清理能够被自动地处理。处理JCheckBoxMenuItem的代码演示了判断菜单项是否被选中的两种方式：字符串比较（缺乏安全的方式，尽管你会看到可以使用这种方法），和比较事件的目标对象。可以使用getState()方法得到是否选中的状态。还可以用setState()方法来改变JCheckBoxMenuItem的状态。

菜单对应的事件有些不一致，这可能会引起困惑：JMenuItem使用的是ActionListener，而JCheckBoxMenuItem使用的是ItemListener。JMenu对象虽然也支持ActionListener，不过其用处并不大。一般来说，要把监听器关联到每一个JMenuItem、JCheckBoxMenuItem或者JRadioButtonMenuItem上，但是在上例中，ItemListener和ActionListener关联到了不同的菜单组件上。

Swing支持助记键，或者称为“键盘快捷键”，所以可以用键盘而不是鼠标来选择任何从AbstractButton（按钮，菜单项等等）继承而来的组件。做到这一点很简单；只要使用重载的构造器，使它的第二个参数接受快捷键的标识符即可。不过，大多数AbstractButton没有这样的构造器，所以更通用的做法是使用setMnemonic()方法。上例中为按钮和部分菜单项添加了快捷键；快捷指示符会自动出现在组件上。

你还能看到setActionCommand()的用法。它看起来有些奇怪，因为在每种情况下，“动作命令”与菜单上的标签都完全相同。为什么不直接使用标签而是这种额外的字符串呢？问题在于对国际化的支持。如果要把程序以另一种语言发布，最好是希望只改变菜单上的标签，而不用修改代码（毫无疑问，修改代码会引入新的错误）。通过使用setActionCommand()，可以把“动作命令”作为不变量，而把菜单上的标签作为可变量。所有的代码在运行时都使用“动作命令”，这样改变菜单标签的时候就不会影响代码。注意，在本例中，并非所有菜单都是基于“动作命令”进行判断的，这是因为没有专门为它们设定“动作命令”。

大量工作都是在监听器中完成的。BL执行的是JMenuBar的交换。在ML中，采用了“找出按铃者”方式，它的做法是先得到ActionEvent的事件源，然后把它类型转换成JMenuItem，接着得到其“动作命令”的字符串，并且把它传递给级联的if语句进行处理。

尽管FL监听器处理的是风味菜单中所有不同风味的菜单项，但它的确很简单。如果事件处理逻辑足够简单的话，这种方式值得参考。不过一般情况下会采用在FooL、BarL和BazL里面所使用的方式，它们只被关联到一个菜单项，所以就不需要进行额外的判断，因为你明确知道是谁调用了监听器。尽管这种方式产生了更多的类，但是类内部的代码会更短，整个处理过程也更安全。

你会发现，有关菜单的代码很快就变得冗长而凌乱；这时，使用GUI构造工具才是明智的选择。好的工具还可以对菜单进行维护。

练习19：（3）修改Menus.java，在菜单上使用单选按钮而不是复选框。

练习20：（6）创建一个程序，它可以将一个文本文件断开成单词，将这些单词分布到菜单和子菜单上，作为它们的标签。