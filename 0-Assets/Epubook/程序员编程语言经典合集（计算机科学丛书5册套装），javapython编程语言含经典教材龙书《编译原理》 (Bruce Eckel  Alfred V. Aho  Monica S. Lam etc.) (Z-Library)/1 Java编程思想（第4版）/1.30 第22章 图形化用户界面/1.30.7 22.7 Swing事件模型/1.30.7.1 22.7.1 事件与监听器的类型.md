### 22.7.1　事件与监听器的类型

所有Swing组件都具有addXXXListener()和removeXXXListener()方法。这样就可以为每个组件添加或移除相应类型的监听器。注意，每个方法的“XXX”还表示方法所能接收的参数，比如addMyListener（MyListenerm）。下表包含相互关联的基本事件、监听器以及通过提供addXXXListener()和removeXXXListener()方法来支持这些事件的基本组件。记住，事件模型是可以扩展的，所以将来你也许会遇到表格里没有列出的事件和监听器。

![812-1](../Images/image03817.jpeg)

![813-1](../Images/image03818.jpeg)

⊖ 尽管表示鼠标移动的事件似乎很有必要，但Swing并没有提供MouseMotionEvent这样的事件。MouseEvent包含了鼠标单击和移动的事件，所以MouseEvent在这个表中第二次出现并不是一个错误。

读者可以观察到，每种组件所支持的事件类型都是固定的。为每个组件列出其支持的所有事件是相当困难的。一个比较简单的方法是修改第14章的ShowMethods.java程序，这样它就可以显示出你所输入的任意Swing组件所支持的所有事件监听器。

第14章介绍了反射机制，并且使用反射对指定的类查找其方法：既可以查找所有方法的列表，也可以查找“方法名称符合你所提供的关键字的”部分方法。反射的神奇之处在于它能自动得到一个类的所有方法，而不用遍历类的整个继承层次并在每个层次检查基类。所以，它为编程提供了极具价值并可以节省时间的工具；因为大多数Java方法的名称非常详细且具有描述性，所以可以找出包含你所感兴趣的关键字的方法名称。当找到了所要找的方法后，就可以在JDK文档里查看其细节了。

下面是ShowMethods.java的更好用的GUI版本，专门用来查找Swing组件里的addListener方法：

![813-2](../Images/image03819.jpeg)

![814-1](../Images/image03820.jpeg)

在name JTextField中输入要查找的Swing组件类的名称。查找的结果将使用正则表达式进行匹配，最终结果显示在JTextArea中。

注意，这里没有使用按钮或者别的组件来表明你希望启动查找。这是由于JTextField被ActionListener所监听。当你做出更改并按下“回车”键后，列表马上就得到了更新。如果文本域的内容非空，将把此内容作为Class.forName()的参数，以用来查找这个类。如果名称不正确，Class.forName()方法将失败，即抛出异常。这个异常将被捕获，并把JTextArea内容设置为No match（不匹配）。如果输入正确的名称（注意大小写），Class.forName()将成功返回，然后getMethods()方法将返回一个Method对象的数组。

这里使用了两个正则表达式。第一个是addListener，它查找的模式为：以add开头，后面跟任意字母，然后接Listener，最后是括号内的参数列表。注意，整个正则表达式用“非转义”的括号包围，意思是当发生匹配的时候，它可以作为一个正则表达式“组”来访问。在NameL.ActionPerformed()中，通过把每个Method对象都以字符串形式传递给Pattern.matcher()方法，创建一个Matcher对象。当在此对象上调用find()的时候，只有发生了匹配，才会返回真，这时，你可以通过调用group（1）来选择第一个匹配的包含在括号中的表达式组。这样得到的字符串仍然包含限定词，为了把限定词剔除掉，需要使用qualifier Pattern对象，这与ShowMethods.java中的做法很相似。

在构造器的末尾，在name中设置一个初始值，然后触发事件，对初始数据进行一次测试。

这个程序为查询Swing组件所支持的事件类型提供了一种便利方式。一旦知道了某个组件支持哪些事件，不用参考任何资料就可以处理这个事件了。你只要：

1）获取事件类的名称，并移除单词“Event”，然后将剩下的部分加上单词“Listener”，得到的就是内部类必须实现的监听器接口。

2）实现上面的接口，为要捕获的事件编写出方法。比如，你可能要查找鼠标移动，所以你可以为MouseMotionListener接口的mouseMoved()方法编写代码（自然必须同时实现接口的其他方法，不过很快你会学到一种简单的方式）。

3）为第二步编写的监听器类创建一个对象。然后通过调用方法向组件注册这个对象——方法名为“add”前缀加上监听器名称，比如addMouseMotionListener()。

下面是一些监听器接口：

![815-1](../Images/image03821.jpeg)

这并不是个完整的列表，部分原因是由于事件模型允许你编写自己的事件类型和相应的监听器。所以，人们常常会遇到含有自定义事件的库，本章学习到的知识可以帮助读者理解如何使用这些事件。

使用监听器适配器来进行简化

在上面的表中可以发现，某些监听器接口只有一个方法。这种接口实现起来很简单。不过，具有多个方法的监听器接口使用起来却不太方便。比如，如果你想捕获一个鼠标单击事件（例如，某个按钮还没有替你捕获该事件），那么就需要为mouseClicked()方法编写代码。但是因为MouseListener是一个接口，所以尽管接口里的其他方法对你来说没有任何用处，但是你还是必须要实现所有这些方法。这非常烦人。

要解决这个问题，某些（不是所有的）含有多个方法的监听器接口提供了相应的适配器（可以在上面的表中看到具体的名称）。适配器为接口里的每个方法都提供了默认的空实现。现在你要做的就是从适配器继承，然后仅覆盖那些需要修改的方法。比如，你要用的典型的MouseListener像这样：

![816-1](../Images/image03822.jpeg)

适配器的出发点就是为了使编写监听器类变得更容易。不过，适配器也有某种形式的缺陷。假设你写了一个与前面类似的MouseAdapter：

![816-2](../Images/image03823.jpeg)

这个适配器将不起作用，而且要想找出问题的根源也非常困难，这足以让你发疯。因为除了鼠标单击的时候方法没有被调用以外，程序的编译和运行都十分良好。你能发现这个问题吗？它出在方法的名称上：这里的名称是MouseClicked()而没有写成mouseClicked()。这个简单的大小写错误导致加入了一个新方法。它不是关闭视窗的时候所应该调用的方法，所以无法得到所希望的结果。尽管使用接口有些不方便，但可以保证方法被正确实现。

要想保证实际上的确是覆盖了某个方法，一种改进的方法是在这段代码的上面使用内建的@Override注解。

练习9：（5）在ShowAddListeners.java的基础上编写程序，实现typeinfo.ShowMethods .java程序的完全功能。