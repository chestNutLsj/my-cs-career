### 22.10.1　长期运行的任务

在使用图形化用户界面编程时最容易犯的错误之一，就是意外地使用了事件分发线程来运行长任务。下面是一个简单的示例：

![849-2](../Images/image03869.jpeg)

当按下b1时，事件分发线程会突然被占用去执行这个长期运行的任务。此时你会看到，这个按钮甚至不会马上弹起来，因为正常情况下会重绘屏幕的事件分发线程现在处于忙状态。并且你也不能做其他任何事，例如按下b2，因为这个程序在b1的任务完成，从而使得事件分发线程再次可用之前，是不会做出响应的。b2中的代码是一种有缺陷的尝试，试图通过中断事件分发线程来解决这个问题。

解决之道当然是在单独的线程中执行长期运行的任务，下面是使用了单线程的Executor，它会自动将待处理的任务排队，然后每次执行其中的一个：

![850-2](../Images/image03870.jpeg)

![851-1](../Images/image03871.jpeg)

这个程序有了一些改进，但是当你按下b2时，它会在ExecutorService上调用shutdownNow()，从而会禁用它。如果你试图添加更多的任务，那么就会得到异常。因此，按下b2会使程序不起作用。我们想要的是在关闭当前任务（并放弃待处理任务）的同时，不会停止任何其他的事物，在第20章中描述的Java SE5的Callable/Future机制正是我们所需要的。我们将定义一个被称为TaskManager的新类，它包含多个元组，这些元组持有表示任务的Callable和从Callable中返回的Future。必须使用元组的原因是因为它使得我们可以跟踪最初的任务，这样就可以获取从Future中无法获得的额外信息。下面是示例：

![851-2](../Images/image03872.jpeg)

在java.util.concurrent类库中，默认情况下，经由Future是无法获得任务的，因为在你从Future获得结果时，任务不必仍旧留存。这里，我们通过把任务存储起来，强制它仍旧留存。

TaskManager被放到了net.mindview.util中，因此它可以当作通用使用工具来使用：

![851-3](../Images/image03873.jpeg)

TaskManager是TaskItem的ArrayList，它还包含一个单线程的Executor，因此当你用一个Callable来调用add()时，它会提交该Callable，然后将产生的Future连同最初的任务一起存储起来。在这种方式中，如果需要用任务来执行某些事，你都会拥有一个指向该任务的引用。作为一个简单示例，在purge()中使用的是任务的toString()方法。

现在，它可以用在我们的示例中去管理长期运行的任务了：

![852-2](../Images/image03874.jpeg)

![853-1](../Images/image03875.jpeg)

正如你所看见的，CallableTask确实执行了与Task相同的操作，只是它返回了结果，在本例中返回的结果是一个标识该任务的String。

被称为SwingWorker（来自Sun的Web站点）的非Swing实用工具（不是标准Java发布版本的一部分）和Foxtrot（来自http://foxtrot.sourceforge.net）都是专门设计用来解决类似问题的。但是到本书撰写时为止，这些实用工具还没有做出修改从而能使它们利用Java SE5的Callable/Future机制。

为最终用户提供某种可视线索，以表示任务正在运行以及其执行进度，经常是一种非常重要的工具。这通常可以使用JProgressBar或ProgressMonitor来实现，下面的示例使用了ProgressMonitor：

![853-2](../Images/image03876.jpeg)

![854-1](../Images/image03877.jpeg)

MonitoredCallable的构造器接收一个ProgressMonitor作为参数，并且其call()方法会每半秒钟更新一次该ProgressMonitor。注意，MonitoredCallable是一个单独的任务，因此不应该尝试着直接控制UI，这样就需要使用SwingUtilities.invokeLater()来向monitor提交进度变化信息。Sun的Swing教程（在http://java.sun.com上）展示了另一种可选的方式，即使用Swing的Timer，它可以检查任务的状态并更新监视器。

如果监视器的cancel按钮被按下，monitor.isCanceled()方法将返回true。这里，任务只是在其自身的线程上调用了interrupt()，这个方法将使任务进入catch子句，而monitor将在此由close()方法终结。

剩下的代码与之前代码是一样的，只是创建ProgressMonitor成为了MonitoredLongRunningCallable构造器的一部分。

练习33：（6）修改InterruptableLongRunningCallable.java，使其并行而不是按顺序地运行所有任务。