### 22.10.2　可视化线程机制

下面的例子使一个实现了Runnable接口的Jpanel类可以在其自身上绘制不同的颜色。程序设定为从命令行接受参数，以决定颜色块的数目和颜色变化的时间间隔（线程休眠的时间）。尝试用不同的值运行程序，你可能会发现一些在你的平台之上的多线程实现的有趣的、难以言表的特性：

![855-1](../Images/image03878.jpeg)

![856-1](../Images/image03879.jpeg)

ColorBoxes设置为使用GridLayout布局管理器，从而得到二维的网格单元。然后加入适当数目的CBox对象来填充网格，并为这些对象传入pause值。在main()中可以发现，pause和grid都有默认值，通过命令行传入的参数值可以修改这些值。

所有的工作由CBox完成。它从JPanel继承，并且实现了Runnable接口，所以每个JPanel同时也是一个独立任务。这些任务都是通过线程池ExecutorService来驱动的。

当前单元的颜色是color，这些颜色是通过使用Color构造器创建的，该构造器接受一个24位的数字，在本例中，这个数字是随机创建的。

paintComponent()方法相当简单，它只是将颜色设置为color，并用这种颜色填充整个JPanel。

在run()方法中，可以看到一个无穷循环，它先把cColor设置成新的随机颜色，然后调用repaint()进行显示。接着调用sleep()使线程休眠一段时间，这个时间可以从命令行指定。

在run()中对repaint()的调用应该受到检查。初看起来，就像是我们在创建许多线程，其中每一个都强制进行绘制。看上去这违反了应该只向事件队列提交任务的原则，但是，这些线程并未实际修改共享资源。当它们调用repaint()时，并未强制在这一时刻立即进行绘制，而只是设置了一个“脏标志”，表示当下一次事件分发线程准备好重绘时，这个区域是重绘的备选元素之一。因此，这个程序不会引起Swing的多线程问题。

当事件分发线程实际执行paint()时，首先调用paintComponent()，然后是paintBorder()和paintChildren()。如果你需要在导出组件中覆盖paint()，就必须牢记调用基类版本的paint()，以使得它仍旧可以执行正确的行为。

这个设计很灵活，并且线程与每个JPanel都联系到了一起，所以你可以试着创建任意多的线程。（事实上，这个数目受你的JVM所能自如处理的线程数目的限制。）这个程序还能做一个有趣的基准测试，因为可以针对不同的JVM线程实现以及不同的平台，用它来演示这些实现的动态性能以及行为上的差异。

练习34：（4）修改ColorBoxes.java，让数个闪烁点（星星）穿过画布，然后随机地变化这些“星星”的颜色。