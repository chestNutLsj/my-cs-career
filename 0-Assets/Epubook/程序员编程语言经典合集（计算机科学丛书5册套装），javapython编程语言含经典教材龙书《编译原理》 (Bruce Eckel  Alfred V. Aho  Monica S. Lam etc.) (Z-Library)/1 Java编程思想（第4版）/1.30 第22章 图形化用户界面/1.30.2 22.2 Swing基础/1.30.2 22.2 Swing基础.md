## 22.2　Swing基础

大多数Swing应用都被构建在基础的JFrame内部，JFrame在你使用的任何操作系统中都可以创建视窗应用。视窗的标题可以像下面这样使用JFrame的构造器来设置：

![803-1](../Images/image03803.jpeg)

setDefaultCloseOperation()告诉JFrame当用户执行关闭操作时应该做些什么。EXIT_ON_CLOSE常量告诉它要退出程序。如果没有这个调用，默认的行为是什么也不做，因此应用将不会关闭。setSize()以像素为单位设置视窗的尺寸。请注意最后一行：

![803-4](../Images/image03804.jpeg)

如果没有这行，你在屏幕上将什么也看不到。

我们可以通过在JFrame中添加一个JLabel来使事情变得更有趣一些：

![803-2](../Images/image03805.jpeg)

在一秒钟之后，JLabel的文本发生了变化。尽管这对于这个小程序来说既有趣又安全，但是对于main()线程来说，直接对GUI组件编写代码并非是一种好的想法。Swing有它自己的专用线程来接收UI事件并更新屏幕，如果你从其他线程着手对屏幕进行操作，那么就可能会产生第21章中所描述的冲突和死锁。

取而代之的是，其他线程，例如这里是像main()这样的线程，应该通过Swing事件分发线程提交要执行的任务[^4]来实现这种方式，这个方法会通过事件分发线程将任务放置到（最终将得到执行的）待执行事件队列中。如果我们将这种方式应用于上面的示例，那么它就会变成下面的样子：

![803-3](../Images/image03806.jpeg)

现在你再也不用直接操作JLabel了。取而代之的是，你提交一个Runnable，当事件分发线程在事件队列中获取这项任务时，它将执行实际的操作，并且在执行这个Runnable时，不会做其他任何事情，因此也就不会产生任何冲突，当然，前提是程序中的所有代码都遵循这种通过SwingUtilities.invokeLater()来提交操作的方式。这包括启动程序自身，即main()也不应该调用Swing的方法，就像上面的程序一样，它应该向事件队列提交任务[^5]。因此，所编写的恰当的程序看起来应该是下面的样子：

![804-2](../Images/image03807.jpeg)

注意，对sleep()的调用不在构造器的内部。如果你将它放在构造器内部，JLabel的初始文本就永远都不会出现。这主要是因为构造器在sleep()调用完毕和新的标签插入之前不会结束，如果sleep()在构造器的内部，或者在任何UI操作的内部，那么就意味着你在sleep()期间将中止事件分发线程，这通常是个糟糕的主意。

练习1：（1）修改HelloSwing.java，向你自己证明如果没有对setDefaultCloseOperation()的调用，应用程序就不会关闭。

练习2：（2）修改HelloSwing.java，通过添加随机数量的标签，说明标签的添加是动态的。