### 22.14.2　Hello，SWT

让我们以最简单的“hello world”风格的应用程序开始：

![878-1](../Images/image03911.jpeg)

如果下载了本书的源代码，你就会发现Requires注释最终使得Ant的build.xml成为了构建swt子目录的前提条件，所有导入org.eclipse.swt的文件都需要你从www.eclipse.org来安装SWT类库。

Display管理SWT和底层操作系统之间的连接，它是操作系统和SWT之间的桥的一部分。Shell是顶层主窗口，所有其他组件都构建于其中，当你调用setText()时，参数会变为窗口标题栏上的标签。

为了显示窗口以及这样的应用程序，你必须在Shell上调用open()。

尽管Swing对你隐藏了事件处理循环，但是SWT会强制你显式地编写它。在循环的顶部，检查shell是否已经被释放——注意，这给了你一个插入代码去执行清理动作的选择，但是这意味着main()线程将会是用户界面线程。在Swing中，后台会创建第二个事件分发线程，但是在SWT中，你的main()线程将处理UI。由于默认情况下只有一个线程而不是两个，因此这使得在某种程度上，你不太可能在用线程来处理UI时搞得一塌糊涂。

注意，你不必像使用Swing那样担心向用户界面线程提交任务，SWT不仅会替你仔细关照这一点，而且如果你试图在错误的线程中操作部件，那它还会抛出异常。但是，如果你需要产生其他线程去执行长期运行的操作，那么你仍旧需要按照使用Swing时的方式去提交变化。为了这一点，SWT提供了三个可以在Display对象上调用的方法：asyncExec（Runnable）、syncExec（Runnable）和timerExec（int，Runnable）。

在此处，你的main()线程的活动是在Display对象上调用readAndDispatch()（这意味每个应用程序只有一个Display对象）。如果在事件队列中存在更多的事件在等待处理，那么readAndDispatch()方法将返回true。在这种情况下，你希望立即再次调用它。然而，如果没有任何事件被悬挂，那么你可以调用Display对象的sleep()方法，以便在再次检查事件队列之前等待一小段时间。

一旦程序结束，你必须显式地调用Display对象上的dispose()方法。SWT经常要求你显式地释放资源，因为这些通常都是来自底层操作系统的资源，如果不释放可能会被耗尽。

为了证明Shell是主窗口，下面的程序将创建大量的Shell对象：

![879-1](../Images/image03912.jpeg)

当你运行它时，将获得10个主窗口。在以这种方式编写的程序中，如果关闭任何一个窗口，那么所有的窗口都会被关闭。

SWT也使用了布局管理器，虽然它与Swing使用的不同，但是思想一致。下面是稍微复杂一些的示例，它接收从System.getProperties()中获得的文本，并将其添加到shell中：

![880-1](../Images/image03913.jpeg)

在SWT中，所有部件必须都有一个具有泛化类型Conposite的父对象，并且必须在部件构造器中将这个父对象作为第一个参数来提供。在Text构造器中你就可以看到这一点，其中shell是第一个参数。实际上，所有构造器还都要接受一个标志参数，它使得你可以根据特定的部件所能接受的情况，提供任意数量的样式指示信息。多个样式指示信息是按位或在一起的，就像在本例中看到的那样。

在设置Text()对象时，我添加了样式标志，以使得它将文本包装起来，并且如果需要的话，它会自动地添加一个垂直滚动条。你会发现SWT是绝对是基于构造器的，各种部件都有大量的不通过构造器就很难或者根本不可能修改的属性，所以你应该总是查看部件构造器文档，了解可接受的标志。注意，某些构造器即便在文档中没有列出任何“可接受”的标志，它们也要求要有一个标志参数，这样就可以使得未来在做扩充时，不需要修改接口。