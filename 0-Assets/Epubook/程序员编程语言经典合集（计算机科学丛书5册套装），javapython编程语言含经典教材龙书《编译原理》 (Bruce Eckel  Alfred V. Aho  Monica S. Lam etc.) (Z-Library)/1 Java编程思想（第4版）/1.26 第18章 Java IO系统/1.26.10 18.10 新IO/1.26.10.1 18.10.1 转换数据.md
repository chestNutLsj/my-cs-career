### 18.10.1　转换数据

回过头看GetChannel.java这个程序就会发现，为了输出文件中的信息，我们必须每次只读取一个字节的数据，然后将每个byte类型强制转换成char类型。这种方法似乎有点原始——如果我们查看一下java.nio.CharBuffer这个类，将会发现它有一个toString()方法是这样定义的：“返回一个包含缓冲器中所有字符的字符串。”既然ByteBuffer可以看作是具有asCharBuffer()方法的CharBuffer，那么为什么不用它呢？正如下面的输出语句中第一行所见，这种方法并不能解决问题：

![587-2](../Images/image03505.jpeg)

![588-1](../Images/image03506.jpeg)

缓冲器容纳的是普通的字节，为了把它们转换成字符，我们要么在输入它们的时候对其进行编码（这样，它们输出时才具有意义），要么在将其从缓冲器输出时对它们进行解码。可以使用java.nio.charset.Charset类实现这些功能，该类提供了把数据编码成多种不同类型的字符集的工具：

![588-2](../Images/image03507.jpeg)

让我们返回到BufferToText.java，如果我们想对缓冲器调用rewind()方法（调用该方法是为了返回到数据开始部分），接着使用平台的默认字符集对数据进行decode()，那么作为结果的CharBuffer可以很好地输出打印到控制台。可以使用System.getProperty（"file.encoding"）发现默认字符集，它会产生代表字符集名称的字符串。把该字符串传送给Charset.forName()用以产生Charset对象，可以用它对字符串进行解码。

另一选择是在读文件时，使用能够产生可打印的输出的字符集进行encode()，正如在BufferToText.java中第3部分所看到的那样。这里，UTF-16BE可以把文本写到文件中，当读取时，我们只需要把它转换成CharBuffer，就会产生所期望的文本。

最后，让我们来看看若是通过CharBuffer向ByteBuffer写入，会发生什么情况（后面将会深入了解）。注意我们为ByteBuffer分配了24个字节。既然一个字符需要2个字节，那么一个ByteBuffer足可以容纳12个字符，但是“Some text”只有9个字符，剩余的内容为零的字节仍出现在由它的toString()所产生的CharBuffer的表示中，我们可以在输出中看到。

练习23：（6）创建并测试一个实用方法，使其可以打印出CharBuffer中的内容，直到字符不能再打印为止。