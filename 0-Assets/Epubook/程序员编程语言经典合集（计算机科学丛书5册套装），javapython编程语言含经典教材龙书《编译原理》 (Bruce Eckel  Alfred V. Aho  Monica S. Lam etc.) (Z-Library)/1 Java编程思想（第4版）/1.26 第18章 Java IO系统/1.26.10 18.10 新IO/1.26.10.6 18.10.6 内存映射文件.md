### 18.10.6　内存映射文件

内存映射文件允许我们创建和修改那些因为太大而不能放入内存的文件。有了内存映射文件，我们就可以假定整个文件都放在内存中，而且可以完全把它当作非常大的数组来访问。这种方法极大地简化了用于修改文件的代码。下面是一个小例子：

![596-4](../Images/image03526.jpeg)

为了既能写又能读，我们先由RandomAccessFile开始，获得该文件上的通道，然后调用map()产生MappedByteBuffer，这是一种特殊类型的直接缓冲器。注意我们必须指定映射文件的初始位置和映射区域的长度，这意味着我们可以映射某个大文件的较小的部分。

MappedByteBuffer由ByteBuffer继承而来，因此它具有ByteBuffer的所有方法。这里，我们仅仅展示了非常简单的put()和get()，但是我们同样可以使用像asCharBuffer()等这样的用法。

前面那个程序创建的文件为128MB，这可能比操作系统所允许一次载入内存的空间大。但似乎我们可以一次访问到整个文件，因为只有一部分文件放入了内存，文件的其他部分被交换了出去。用这种方式，很大的文件（可达2GB）也可以很容易地修改。注意底层操作系统的文件映射工具是用来最大化地提高性能。

性能

尽管“旧”的I/O流在用nio实现后性能有所提高，但是“映射文件访问”往往可以更加显著地加快速度。下面的程序进行了简单的性能比较。

![597-1](../Images/image03527.jpeg)

![598-1](../Images/image03528.jpeg)

正如在本书前面的例子中所看到的那样，runTest()被用作是一种模板方法，为在匿名内部子类中定义的test()的各种实现创建了测试框架）。每种子类都将执行一种测试，因此test()方法为我们进行各种I/O操作提供了原型。

尽管“映射写”似乎要用到FileOutputStream，但是映射文件中的所有输出必须使用RandomAccessFile，正如前面程序代码中的读/写一样。

注意test()方法包括初始化各种I/O对象的时间，因此，即使建立映射文件的花费很大，但是整体受益比起I/O流来说还是很显著的。

练习25：（6）试着将本章例子中的ByteBuffer.allocate()语句改为ByteBuffer.allocateDirect()。用来证实性能之间的差异，但是请注意程序的启动时间是否发生了明显的改变。

练习26：（3）修改JGrep.java，让其使用Java的nio内存映射文件。