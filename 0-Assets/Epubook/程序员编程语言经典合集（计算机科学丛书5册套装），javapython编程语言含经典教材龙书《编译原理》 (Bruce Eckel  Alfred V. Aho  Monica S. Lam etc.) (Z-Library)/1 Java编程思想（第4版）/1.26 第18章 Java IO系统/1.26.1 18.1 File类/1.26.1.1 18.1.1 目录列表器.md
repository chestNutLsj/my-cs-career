### 18.1.1　目录列表器

假设我们想查看一个目录列表，可以用两种方法来使用File对象。如果我们调用不带参数的list()方法，便可以获得此File对象包含的全部列表。然而，如果我们想获得一个受限列表，例如，想得到所有扩展名为.java的文件，那么我们就要用到“目录过滤器”，这个类会告诉我们怎样显示符合条件的File对象。

下面是一个示例，注意，通过使用java.utils.Arrays.sort()和String.CASE_INSENSITIVE.ORDERComparator，可以很容易地对结果进行排序（按字母顺序）。

![558-1](../Images/image03463.jpeg)

![559-1](../Images/image03464.jpeg)

这里，DirFilter类“实现”了FilenameFilter接口。请注意FilenameFilter接口是多么的简单：

![559-2](../Images/image03465.jpeg)

DirFilter这个类存在的唯一原因就是将accept()方法。创建这个类的目的在于把accept()方法提供给list()使用，使list()可以回调accept()，进而以决定哪些文件包含在列表中。因此，这种结构也常常称为回调。更具体地说，这是一个策略模式的例子，因为list()实现了基本的功能，而且按照FilenameFilter的形式提供了这个策略，以便完善list()在提供服务时所需的算法。因为list()接受FilenameFilter对象作为参数，这意味着我们可以传递实现了FilenameFilter接口的任何类的对象，用以选择（甚至在运行时）list()方法的行为方式。策略的目的就是提供了代码行为的灵活性。

accept()方法必须接受一个代表某个特定文件所在目录的File对象，以及包含了那个文件名的一个String。记住一点：list()方法会为此目录对象下的每个文件名调用accept()，来判断该文件是否包含在内；判断结果由accept()返回的布尔值表示。

accept()会使用一个正则表达式的matcher对象，来查看此正则表达式regex是否匹配这个文件的名字。通过使用accept()，list()方法会返回一个数组。

匿名内部类

这个例子很适合用一个匿名内部类（第8章介绍过）进行改写。首先创建一个filter()方法，它会返回一个指向FilenameFilter的引用：

![559-3](../Images/image03466.jpeg)

![560-1](../Images/image03467.jpeg)

注意，传向filter()的参数必须是final的。这在匿名内部类中是必需的，这样它才能够使用来自该类范围之外的对象。

这个设计有所改进，因为现在FilenameFilter类紧密地和DirList2绑定在一起。然而，我们可以进一步修改该方法，定义一个作为list()参数的匿名内部类；这样一来程序会变得更小：

![560-2](../Images/image03468.jpeg)

既然匿名内部类直接使用args[0]，那么传递给main()方法的参数现在就是final的。

这个例子展示了匿名内部类怎样通过创建特定的、一次性的类来解决问题。此方法的一个优点就是将解决特定问题的代码隔离、聚拢于一点。而另一方面，这种方法却不易阅读，因此要谨慎使用。

练习1：（3）修改DirList.java（或其变体之一），以便FilenameFilter能够打开每个文件（使用net.mindview.util.TextFile工具），并检查命令行尾随的参数是否存在于那个文件中，以此检查结果来决定是否接受这个文件。

练习2：（2）创建一个叫做SortedDirList的类，它具有一个可以接受文件路径信息，并能构建该路径下所有文件的排序目录列表的构造器。向这个类添加两个重载的list()方法：一个产生整个列表，另一个产生与其参数（一个正则表达式）相匹配的列表的子集。

练习3：（3）修改DirList.java（或其变体之一），使其对所选中的文件计算文件尺寸的总和。