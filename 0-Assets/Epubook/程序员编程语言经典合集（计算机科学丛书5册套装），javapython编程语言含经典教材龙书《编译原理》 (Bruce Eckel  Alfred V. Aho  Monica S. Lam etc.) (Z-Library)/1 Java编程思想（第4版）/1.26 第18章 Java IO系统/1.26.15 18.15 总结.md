## 18.15　总结

Java I/O流类库的确能满足我们的基本需求：我们可以通过控制台、文件、内存块，甚至因特网进行读写。通过继承，我们可以创建新类型的输入和输出对象。并且通过重新定义toString()方法，我们甚至可以对流接受的对象类型进行简单扩充。当我们向一个期望收到字符串的方法传送一个对象时，会自动调用toString()方法（这是Java有限的自动类型转换功能）。

在I/O流类库的文档和设计中，仍留有一些没有解决的问题。例如，当我们打开一个文件用于输出时，我们可以指定一旦试图覆盖该文件就抛出一个异常——有的编程系统允许我们自行指定想要打开的输出文件，只要它尚不存在。在Java中，我们似乎应该使用一个File对象来判断某个文件是否存在，因为如果我们以FileOutputStream或者FileWriter打开，那么它肯定会被覆盖。

I/O流类库使我们喜忧参半。它确实能做许多事情，而且具有可移植性。但是如果我们没有理解“装饰器”模式，那么这种设计就不是很直觉，因此，在学习和传授它的过程中，需要额外的开销。而且它并不完善；例如，我应该不必去写像TextFile这样的应用（新的Java SE5的PrintWriter向正确的方向迈进了一步，但是它只是一个部分的解决方案）。在Java SE5中有一个巨大的改进：他们最终添加了输出格式化，而事实上其他所有语言的I/O包都提供这种支持。

一旦我们理解了装饰器模式，并开始在某些情况下使用该类库以利用其提供的灵活性，那么你就开始从这个设计中受益了。到那个时候，为此额外多写几行代码的开销应该不至于使人觉得太麻烦。

所选习题的答案都可以在名为The Thinking in Java Annotated Solution Guide的电子文档中找到，读者可以从https://www.mindviewllc.com处购买此文档。

---

[^1]: 很难说这就是一个很好的设计选择，尤其是与其他程序设计语言中的简单I/O类库相比较。但它的确是如此选择的一个恰当理由。

[^2]: 。

[^3]: XML是另一种方式，可以解决在不同的计算平台之间移动数据，而不依赖于所有平台上都有Java这一问题。XML将在本章稍后进行介绍。

[^4]: 第22章展示了一种更方便的解决方案：一个GUI程序，具有带滚动的文本区域。

[^5]: 此部分内容由Chintan Thakker提供。

[^6]: 有关线程的更多细节在第21章中可以找到。

[^7]: 14.9节展示了如何在类的外部访问private方法。