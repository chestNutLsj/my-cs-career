## 18.13　XML

对象序列化的一个重要限制是它只是Java的解决方案：只有Java程序才能反序列化这种对象。一种更具互操作性的解决方案是将数据转换为XML格式，这可以使其被各种各样的平台和语言使用。

因为XML十分流行，所以用它来编程时的各种选择不胜枚举，包括随JDK发布的javax.xml.*类库。我选择使用Elliotte Rusty Harold的开源XOM类库（可从www.xom.nu下载并获得文档），因为它看起来最简单，同时也是最直观的用Java产生和修改XML的方式。另外，XOM还强调了XML的正确性。

作为一个示例，假设有一个Person对象，它包含姓和名，你想将它们序列化到XML中。下面的Person类有一个getXML()方法，它使用XOM来产生被转换为XML的Element对象的Person数据；还有一个构造器，接受Element并从中抽取恰当的Person数据（注意，XML示例都在它们自己的子目录中）：

![619-1](../Images/image03562.jpeg)

![620-1](../Images/image03563.jpeg)

XOM的方法都具有相当的自解释性，可以在XOM文档中找到它们。XOM还包含一个Serializer类，你可以在format()方法中看到它被用来将XML转换为更具可读性的格式。如果只调用toXML()，那么所有东西都会混在一起，因此Serializer是一种便利工具。

从XML文件中反序列化Person对象也很简单：

![620-2](../Images/image03564.jpeg)

People构造器使用XOM的Builder.build()方法打开并读取一个文件，而getChildElements()方法产生了一个Elements列表（不是标准的Java List，只是一个拥有size()和get()方法的对象，因为Harold不想强制人们使用Java SE5，但是仍旧希望使用类型安全的容器）。在这个列表中的每个Element都表示一个Person对象，因此它可以传递给第二个Person构造器。注意，这要求你提前知道XML文件的确切结构，但是这经常会有些问题。如果文件结构与你预期的结构不匹配，那么XOM将抛出异常。对你来说，如果你缺乏有关将来的XML结构的信息，那么就有可能会编写更复杂的代码去探测XML文档，而不是只对其做出假设。

为了获取这些示例去编译它们，你必须将XOM发布包中的JAR文件放置到你的类路径中。

这里只给出了用Java和XOM类库进行XML编程的简介，更详细的信息可以浏览www.xom.nu。

练习31：（2）在Person.java和People.java中添加恰当的地址信息。

练习32：（4）使用Map<String，Integer>和net.mindview.util.TextFile工具编写程序，对在文件中出现的单词进行计数（使用\\W+做为传递给TextFile构造器的第二个参数）。将结果存储为XML文件。