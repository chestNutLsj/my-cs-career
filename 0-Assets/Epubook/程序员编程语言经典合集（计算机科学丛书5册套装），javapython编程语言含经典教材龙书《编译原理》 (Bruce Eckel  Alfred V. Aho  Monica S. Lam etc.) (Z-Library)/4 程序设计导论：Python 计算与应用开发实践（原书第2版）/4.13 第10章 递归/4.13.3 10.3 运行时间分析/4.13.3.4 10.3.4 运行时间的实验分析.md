   

### 10.3.4　运行时间的实验分析

一种比较函数fib()和rfib()（或其他函数）的精确方法是基于相同的输入运行这些函数并比较它们的运行时间。作为好的（懒惰的）程序员，我们喜欢自动化这个过程，所以我们开发了一个可以用来分析函数运行时间的应用程序。我们将该应用程序普遍化，以适用于除了fib()和rfib()的其他函数。

我们的应用程序由几个函数组成。一个关键的函数是timing()，用以测量函数基于输入的运行时间。它是一个高阶函数，带两个输入参数：（1）一个函数func，（2）一个“输入规模”（整数），在一个给定规模的输入上运行函数func，返回其运行时间。

模块：ch10.py

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09162.jpeg)

函数timing()使用time模块中的time()函数获取执行函数func前后的系统时间，二者之差就是函数运行时间。（注意：测量的时间可能受到计算机可能正在运行的其他任务的影响，但我们避免处理这个问题。）

函数buildinput()带一个输入规模作为输入参数，返回一个适合于函数func()输入的对象，并且具有合适的输入规模。这个函数是依赖于我们正在分析的函数func()。在斐波那契函数fib()和rfib()的情况下，对应于输入规模n的输入恰恰就是n：

模块：ch10.py

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09163.jpeg)

比较两个函数在同一个输入上的运行时间并不能说明哪个函数更好（即更快）。比较两个函数在若干不同输入上的运行时间更有用。这样，我们可以尝试理解当输入规模（即问题规模）增大时两个函数的行为。为此，我们开发了函数timingAnalysis，它在一系列递增规模的输入上运行任意函数并报告运行时间。

模块：ch10.py

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09164.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09165.jpeg)

函数timingAnalysis带五个输入参数：函数func和数值start、stop、inc、runs。它首先在输入规模start上运行func若干次，然后输出平均运行时间。然后在输入规模start+inc、start+2*inc、…，直到输入规模stop上重复执行。

在函数fib()和输入规模分别为24、26、28、30、32、34上运行函数timin-Analysis()，结果如下：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09166.jpeg)

在函数rfib()上执行同样的操作，结果如下：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09167.jpeg)

两次实验的结果如图10-11所示。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09168.jpeg)

图10-11　运行时间图。其中显示了对于输入n=24,26,28,32和34，fib()和rfib()的平均运行时间（单位：秒）

fib()的运行时间可以忽略不计。然而，rfib()的运行时间则随着输入规模增加而快速增加。事实上，运行时间在连续两个输入规模间增大了1倍多。这意味着相对于输入规模，运行时间成指数规模增加。为了理解递归函数rfib()糟糕性能的背后原因，我们在图10-12中描述了其执行流程。

图10-12显示了计算rfib(n)时执行的一些递归调用。要计算rfib(n)，必须递归调用rfib(n-1)和rfib(n-2)；要计算rfib(n-1)和rfib(n-2)，必须分别单独递归调用rfib(n-2)和rfib(n-3)，以及rfib(n-3)和rfib(n-4)，以此类推。

rfib(n)的计算包含两个独立的rfib(n-2)的计算，因此花费的时间是rfib(n-2)的两倍。这解释了指数规模运行时间的原因。它同时指出了递归解决方案rfib()的问题所在：它一次又一次地重复执行一个函数调用。例如，函数调用rfib(n-4)被执行了五次，虽然其结果一样。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09169.jpeg)

图10-12　递归调用树。计算rfib(n)需要两次递归调用rfib(n-1)和rfib(b-2)。计算rfib(n-1)需要递归调用rfib(n-2)和rfib(n-3)；计算rfib(n-2)需要递归调用rfib(n-3)和rfib(n-4)。同一个递归调用被执行多次，例如rfib(n-4)被重复计算了五次

练习题10.8　使用本节开发的运行时间分析应用程序，分析函数power()、rpower()，以及内置运算符**的运行时间。为此，可以通过在如下所示的函数power2()、rpower2()和pow2()上，使用输入规模20 000到80 000（步长为20 000），运行timingAnalysis()。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09170.jpeg)

完成后，讨论实现内置的幂操作符**可能使用的方法。