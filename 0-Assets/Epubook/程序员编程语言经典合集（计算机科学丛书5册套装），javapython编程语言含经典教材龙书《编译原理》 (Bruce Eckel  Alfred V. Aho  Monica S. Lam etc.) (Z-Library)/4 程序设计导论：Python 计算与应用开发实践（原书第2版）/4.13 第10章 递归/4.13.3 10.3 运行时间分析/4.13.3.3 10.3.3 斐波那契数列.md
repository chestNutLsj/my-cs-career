   

### 10.3.3　斐波那契数列

我们在第5章介绍了斐波那契数列：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09154.jpeg)

我们还描述了一种构建斐波那契数列的方法：数列中的一个数是数列中前两个数之和（除了最前面的两个1）。这个规则在本质上是递归的。所以，如果我们要实现一个函数rfib()，带一个非负整数n作为输入参数，返回第n个斐波那契数，看起来很自然可以使用一个递归来实现。接下来我们讨论其递归实现。

既然递归规则适用于第0个和第1个之后的斐波那契数，递归基本情况为n≤1（即n=0或n=1）是有道理的。在基本情况下，rfib()应该返回1：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09155.jpeg)

递归步骤适用于输入n>1。在这种情况下，第n个斐波那契数为第n-1个和第n-2个斐波那契数之和：

模块：ch10.py

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09156.jpeg)

让我们验证函数rfib()的运行结果：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09157.jpeg)

结果看起来正确。让我们尝试计算一个较大的斐波那契数：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09158.jpeg)

结果正确。但计算花费了一定时间（请读者尝试）。如果我们尝试：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09159.jpeg)

结果要等待很长的时间。（记住，你可以通过同时按【Ctrl+C】键终止程序的执行。）

计算第36个斐波那契数真的那么耗时吗？回想一下，我们已经在第5章中实现了一个返回第n个斐波那契数的函数：

模块：ch10.py

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09160.jpeg)

让我们验证运行结果：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09161.jpeg)

所有的结果瞬时完成。让我们来探讨rfib()出错的原因。