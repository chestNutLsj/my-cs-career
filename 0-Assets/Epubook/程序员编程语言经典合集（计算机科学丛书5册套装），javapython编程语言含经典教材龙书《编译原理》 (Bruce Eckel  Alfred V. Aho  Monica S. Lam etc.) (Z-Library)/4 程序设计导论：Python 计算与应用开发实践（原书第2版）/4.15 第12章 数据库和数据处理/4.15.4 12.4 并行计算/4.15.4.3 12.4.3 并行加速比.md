   

### 12.4.3　并行加速比

为了说明并行计算的优越性，我们讨论一个数论中计算密集型的问题。我们想比较素数在几个任意整数范围内的分布。更确切地说，我们希望在几个相同大小范围（100 000个大整数）计算素数的个数。

假设其中一个范围是从12 345 678到但不包括12 445 678。为了在这个范围内查找素数，我们可以简单地遍历范围内的数值，并检查每个数值是否为素数。函数countPrimes()使用列表解析实现这个想法：

模块：primeDensity.py

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09402.jpeg)

函数prime()带一个正整数参数，如果是素数则返回True，否则返回False。这是思考题5.36的答案。我们使用下一个程序来计算函数countPrimes()的执行时间：

模块：primeDensity.py

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09403.jpeg)

如果修改行p=Pool()为p=Pool(1)，则进程池只有一个进程，输出结果如下：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09404.jpeg)

换言之，单个进程处理所有八个整数范围，耗时47.84秒（运行时间在不同的计算机上可能会有差异）。如果我们采用两个进程的进程池，则可以显著提升运行时间为24.60秒。因此，通过使用两个内核代替一个内核，我们几乎将运行时间缩减了一半。

一种比较顺序运行时间和并行运行时间的更好方法是加速比（speedup），即顺序运行时间和并行运行时间的比率。在这种特殊情况下，我们的加速比为：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09405.jpeg)

这意味着两个进程（在两个不同的内核上运行）时，我们解决问题的速度变为原来的1.94倍（或者几乎两倍）。注意，从本质上来说，这是我们所能期望的最好结果：并行执行的两个进程的速度最多可以是一个进程的两倍。

四个进程时，我们进一步提高了运行时间：16.78秒，这对应的加速比为47.84/16:78≈2.85。请注意，四个进程在四个独立内核上运行的最佳加速比是4。八个进程时，我们进一步提高了运行时间：14.29秒，这对应的加速比为47.84/14:29≈3.35。当然，最好的可能值是8。