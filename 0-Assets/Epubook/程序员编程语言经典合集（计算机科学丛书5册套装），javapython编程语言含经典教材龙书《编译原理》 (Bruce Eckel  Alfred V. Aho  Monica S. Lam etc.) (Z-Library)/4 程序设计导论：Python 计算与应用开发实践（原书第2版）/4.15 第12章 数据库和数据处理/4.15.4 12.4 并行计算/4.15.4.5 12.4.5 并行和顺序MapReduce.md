   

### 12.4.5　并行和顺序MapReduce

我们使用MapReduce的并行实现来解决名称交叉检查问题。假设成千上万的已经分类的文档刚刚在网上发布，这些文档提到了各种各样的人名。你希望在这些文档中查找提及特定人名的文档，而且希望为一个或多个文档中的所有人名执行相同操作。为了方便，所有的人名是大写的，这帮你缩小了可能是正确人名的单词的范围。

我们将要解决的确切问题是：给定一个（包含文档的）URL列表，希望获得一个(proper,urlList)对列表，其中proper是任何文档中的大写单词，urlList是包含proper的文档的URL列表。为了使用MapReduce，我们需要定义Map和Reduce函数。

Map函数带一个URL参数，需要构建一个(key,value)对的列表。在本问题中，URL指定的文档中的每个大写单词都有一个(key,value)对，其中单词是键，而URL是值。因此Map函数如下所示：

模块：ch12.py

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09408.jpeg)

在第9行中使用正则表达式（在第8行定义）来查找大写字母（要复习正则表达式，请参见11.3）。通过把re函数findall()返回的列表转换为集合过滤掉重复单词，因为不需要重复单词，而且这可以加速接下来的Partition和Reduce步骤。

MapReduce的Partition步骤把Map步骤的输出结果作为输入参数，合并key相同的所有(key,value)对。在这个特定问题中，Partition步骤的结果是每个大写单词的(word,urls)对，urls是包含word的所有文档的URL列表。因为这正是我们需要的结果，所以Reduce步骤不需要任何处理操作：

模块：ch12.py

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09409.jpeg)

如何比较我们的顺序实现和并行实现呢？在接下来的代码中，我们开发了一个测试程序，比较了顺序实现和四个进程的并行实现的运行时间（测试是在一台有八个内核的机器上运行的）。作为我们使用的分类文档的替代，测试数据使用了查尔斯·狄更斯的八本小说，由古腾堡项目（又称为古腾堡计划、古腾堡工程）公开提供：

模块：ch12.py

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09410.jpeg)

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09411.jpeg)

让我们运行测试：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09412.jpeg)

因此，四个内核时，运行时间减少了5.08秒，对应于加速比为：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09413.jpeg)

四个内核的最佳加速比为4。在这个示例中，我们使用四个内核，所得的加速比为1.34，这与理论上的最佳加速比4有一定差距。

知识拓展：为什么不能获得更好的加速比？

我们不能获得更好的加速比的一个原因是并行运行程序时总有开销。在管理不同内核上运行的多个进程时，操作系统有额外的工作要做。另一个原因是，我们的并行MapReduce实现Map和Reduce步骤并行的同时，Partition步骤仍然是顺序的。对于在Partition步骤中产生非常大的中间列表的问题，Partition步骤将与顺序实现耗费相同的长时间。这大大地减少了并行Map和Reduce步骤的优越性。

Partition并行化也是可能的，但其实现需要访问正确配置的谷歌公司使用的一种分布式文件系统。事实上，这种分布式文件系统是谷歌公司在开发MapReduce框架中做出的真正的贡献。

在练习题12.8中，我们将开发一个程序，包含一个更加耗时的Map步骤和一个不大耗时的Partition步骤，你将看到更好的加速比。

练习题12.8　给定一个正整数列表，要求计算一个映射，把一个素数映射到可以被该素数整除的所有整数列表。例如，如果列表是[24,15,35,60]，则映射为：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09414.jpeg)

（素数2可以整除24和60；素数3可以整除15和60；等等。）

它被告知，应用程序的输入可能是非常大的整数列表。因此，必须使用MapReduce框架来解决这个问题。为了这样做，你需要为这个特殊问题开发一个Map函数和一个Reduce函数。如果命名为Mapper()和Reducer()，程序将使用下列方式获得上述的映射：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image09415.jpeg)

实现了Map函数和Reduce函数之后，通过开发一个测试程序，采用在10 000 000和20 000 000之间随机抽样的64个整数，比较你的顺序MapReduce实现和并行MapReduce实现的运行时间，并计算加速比。你可以使用在模块random中定义的函数sample()。