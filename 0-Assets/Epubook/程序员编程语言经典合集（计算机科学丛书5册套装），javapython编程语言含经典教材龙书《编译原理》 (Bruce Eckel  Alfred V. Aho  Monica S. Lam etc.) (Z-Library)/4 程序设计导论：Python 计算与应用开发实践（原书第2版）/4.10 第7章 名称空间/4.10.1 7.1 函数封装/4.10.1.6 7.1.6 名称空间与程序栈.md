   

### 7.1.6　名称空间与程序栈

我们知道每个函数调用将创建一个新的名称空间。如果我们调用一个函数，该函数又调用第二个函数，第二个函数又调用第三个函数，则将有三个名称空间，对应于每一个函数的调用。我们现在讨论操作系统（OS）如何管理这些名称空间。这一点很重要，因为没有操作系统对管理名称空间的支持，就无法实现函数调用。

我们使用如下模块作为运行示例：

模块：stack.py

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image08674.jpeg)

运行该模块之后，我们在命令行执行函数调用f(4)：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image08675.jpeg)

图7-2描述了f(4)的执行过程：

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image08676.jpeg)

图7-2　f(4)的执行过程。执行过程从函数调用f(4)的名称空间开始，其中n等于4。函数调用g(3)创建一个新的名称空间，其中n等于3，函数g()使用n的这个值（3）执行。函数调用h(2)创建一个新的名称空间，其中n等于2，函数h()使用n的这个值（2）执行。当h(2)执行终止后，恢复执行g(3)及其对应的名称空间，其中n等于3。当g(3)终止后，恢复执行f(4)

图7-2显示了三个不同的名称空间以及其中每个n的不同值。为了理解这些名称空间是如何管理的，我们仔细研究f(4)的执行过程。

当开始执行f(4)时，n的值是4。当调用函数g(3)时，函数调用g(3)对应的名称空间中n的值是3。然而，n的旧值4必须保留，因为f(4)的执行还没有完成。当g(3)结束后，必须继续执行第14行的代码。

在g(3)执行开始之前，底层的OS存储要完成f(4)的执行所需要的所有信息：

·变量n的值（在示例中，值n=4）

·恢复继续执行f(4)的代码行号（在本实例中，为第14行）

OS把这些信息保存在被称为程序栈的内存中。它被称为栈，因为操作系统会在执行g(3)之前将信息压入到程序栈的顶部。如图7-3所示。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image08677.jpeg)

图7-3　栈帧。一个函数调用把局部变量存储在其栈帧。如果调用另一个函数，则也保存下一次执行的行号

存储与特定未完成函数调用相关的信息的程序栈区域称为栈帧。

当开始执行函数调用g(3)，n的值是3。在g(3)的执行过程中，使用输入参数n-1=2调用函数h()。调用函数h()之前，对应于g(3)的栈帧被压入到程序栈，如图7-4所示。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image08678.jpeg)

图7-4　程序栈。如果一个函数在另一个函数中被调用，则被调用的函数的栈帧被压入到调用方的函数的栈帧之上

在图7-5中，我们再次描述函数f(4)的执行过程，这次同时显示OS如何使用程序栈来存储未完成函数调用的名称空间，以便当继续函数调用执行时恢复名称空间。在图7-5的上半部分，函数调用系列使用实线箭头描述。每次调用对应一次“压入”栈帧到程序栈的操作，在图中使用虚线箭头表示。

现在，让我们继续仔细分析f(4)的执行过程。当h(2)执行时，n是2，并输出1/n=0.5和n=2。然后h(2)终止执行。此时，执行控制将返回到函数调用g(3)。因此，需要恢复与g(3)相关联的名称空间，继续上一次停止执行的位置。OS将通过从程序栈顶部弹出栈帧，并使用栈帧的值执行如下操作：

·恢复n的值为3（即恢复名称空间）。

·从第9行开始继续执行g(3)。

![](0-Assets/Epubook/程序员编程语言经典合集（计算机科学丛书5册套装），javapython编程语言含经典教材龙书《编译原理》%20(Bruce%20Eckel%20%20Alfred%20V.%20Aho%20%20Monica%20S.%20Lam%20etc.)%20(Z-Library)/images/image08679.jpeg)

图7-5　f(4)的执行过程，第2部分。函数调用f(4)在自己的名称空间执行。当调用g(3)时，f(4)的名称空间被压入到程序栈。函数调用g(3)在自己的名称空间执行。当调用h(2)时，g(3)的名称空间也被压入到程序栈。当函数调用h(2)终止时，通过弹出程序栈的顶部栈帧恢复g(3)的名称空间，从存储在栈帧中的行（即第9行）开始继续执行。当g(3)终止时，再次通过弹出程序栈恢复f(4)的名称空间和执行

执行第9行，结果为输出n=3，并终止g(3)。如图7-5所示，程序栈继续弹出并恢复函数调用f(4)的名称空间，并从第14行开始继续执行f(4)。结果是输出n=4，并终止f(4)。

知识拓展：程序栈和缓冲区溢出攻击

程序栈是操作系统主存的重要组成部分。程序栈为每个函数调用包含一个栈帧。栈帧用于存储与函数调用有关的本地变量（如n）。另外，当调用另一个函数时，栈帧用于存储当其他函数终止后恢复执行的指令的行号（即内存地址）。

程序栈还给计算机系统带来一个漏洞，这种漏洞常常用于计算机系统攻击，被称为缓冲区溢出攻击。该漏洞在于，函数调用的输入参数，例如f(4)中的4，可以写入程序栈中，如图7-5所示。换言之，操作系统在程序栈中分配一个小的空间来存储预期的输入参数（在我们的例子中是一个整数值）。

恶意用户可以用比分配空间大得多的参数调用函数。这种参数可能包含恶意代码，也会把程序栈中的既存行号覆盖为另一个行号。当然这一新的行号将指向恶意代码。

最终，执行程序将弹出包含重写行号的栈帧，并开始执行从该行开始的指令。