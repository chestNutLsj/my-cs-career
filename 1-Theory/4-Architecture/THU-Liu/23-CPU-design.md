## 单周期 CPU 设计
### 要实现的指令集
选取 RISC-V 指令中9条典型指令组成的子集：
- 访存指令：lw、sw
- 算术运算指令：add、sub、andi、auipc
- 转移指令：beq、jal、jalr

*其他指令的实现原理可以从中体现——上面 9 条指令覆盖了所有的 RISC-V 指令集的不同类型指令*

解决三个主要问题
- 数据通路设计
- 控制信号设计
- 执行时序设计

### 元件细节
![[23-Singlecycle-Single-cycle-cpu-datapath.png]]

寄存器组 RF：
![[23-CPU-design-register-files.png]]

### 时序设计
- 每条指令占用一个（整）时钟周期
	- 取指令后分析指令，并给出整个执行期间的全部信号 
	- 不需要状态信息，在时钟的结束的边沿写入结果
- 控制对象
	- ALU 的运算
	- 寄存器组和存储器的写入
	- 多路选通器
- 时钟周期开始时读取指令
	- 与具体指令无关，只要 PC+4 正确运行，找到下一条合法指令即可；

### 各指令具体的控制细节
#### 时钟周期开始时
![[23-CPU-design-start.png]]
- 根据 PC 的值找到 IM 中对应的指令——取指阶段
- PC<-PC+4，自动地找到下一条指令的地址；

#### R 型指令
![[23-CPU-design-S-type-flow.png]]
- `add rd,rs1,rs2`
- 指令从 IM 中读出，根据指令中各字段的含义和控制信号，选择合适的寄存器进行运算，此时控制信号 ASel=0、BSel=1，都表示寄存器选中；
- 注意到末尾的三路选通器有 1 个直连到 DataD 的，这是为了将 ALU 计算的结果写入指令中的目标寄存器 rd
- PC 自增 4 

#### I 型指令
![[23-CPU-design-I-type-flow.png]]
- `addi rd,rs,imm`
- 与 R 型指令大差不差，有些区别的地方在于 ImmSel=1，表示生成立即数；RFWEn=1，表示不使用寄存器 DataB，而是通过 BSel=0 获取立即数，用于 ALU 的计算；
- 同样 ALU 计算的结果在三路选通器后要回送到目标寄存器，PC 要自增；

![[23-CPU-design-I-type-load-flow.png]]
- `lw rd,rs,imm`
- load 指令也是 I 型指令的一种，故整体上没有什么大的差别，唯一区别是 ALU 中计算的结果，也就是 rs+imm 要作为 DM 的输入 Addr，从内存中读取数据到 DataR，最终通过三路选通器仍然写回到 rd 寄存器中

#### S 型指令
![[23-CPU-design-S-type-flow-1.png]]
- `sw rs2,rs1,imm` 这里 rs2 是数据寄存器，rs1 是基地址寄存器，imm 是地址偏移量
- 可以看到 DM 中控制信号 MemRW 变为写使能，根据 ALU 计算的结果作为写入地址、将数据寄存器 rs2 中的数据 DataB 写入的 DM 中，并且三路选通器都不开启

#### B 型指令
![[23-CPU-design-B-type-flow.png]]
- `beq rs1,rs2,label`
- IMM Gen 生成的是 label 标签的地址，其寻址是基于基地址寄存器的偏移；
- Branch Comp 中对寄存器 rs1、rs2 中的数据进行比较，根据比较结果 ALU 决定下一个 PC 是自增（分支失败）、选择 label（分支成功）

#### J 型指令
![[23-CPU-design-J-type-flow.png]]
- `jal rd,imm`
- 强制跳转指令，根据 imm 的值设置跳转目标的地址，经过 ALU 计算出结果后写回到 PC 中，完成跳转；

![[23-CPU-design-jalr.png]]
- `jalr rd,rs1,imm` 是 I 型指令，其中 rd 写入的是返回地址（PC+4），而 PC 则写入 rs1+imm 的目标地址；

#### U 型指令
![[23-CPU-design-auipc.png]]
- `auipc rd,imm`
- auipc 指令**将立即数左移 12 位加到 当前 PC 上**，再写入到通用寄存器。
- 这样，可以将 auipc 中的 20 位立即数与 jalr 中的 12 位立即数组合，将执行流程转移到任何 32 位 pc 相对地址。 而 auipc 加上普通加载或存储指令中的 12 位立即数偏移量，可以使得程序访问任何 32 位 PC 相对地址的数据。

#### 信号控制一览

![[23-CPU-design-signal-control.png]]

### 单周期 CPU 特点

优点：
- 每条指令占用一个时钟周期
- 逻辑设计简单，时序设计也简单

缺点：
- 各组成部件的利用率不高
	- 长时间地维持有效信号而不变化，可能导致后续无法复用
- 时钟周期应满足执行时间最长指令的要求
	- Load 指令耗时极长
- CPI =1


## 多周期 CPU 设计
> 内容来自袁春风的计组，因为清华的 ppt 有所缺失，不过也可以参照往年的旧 ppt，毕竟 mips 和 riscv 大差不差。

### 基本思想
- 把每条指令的执行分解为大致相等的数个阶段，通常是 IF、ID、EX、MEM、WB 五个步骤，每个步骤占用一个时钟周期；
- 每个阶段内使用有限的、单一的部件；
- 控制器仅需提供当前步骤所需要的控制信号；
- 各阶段的执行结果在下一个时钟到来时保存到相应存储单元或稳定保存的组合电路中——引入了内部寄存器（锁存器），这在一定程度上延长了指令执行时间，毕竟内部锁存器也有执行延迟
- 时钟周期宽度以最复杂的阶段的所用时间为准，通常是一次存储器读写的时间
- 转入到下一步骤执行，需要引入状态标记当前执行步骤，形成了一组**有限状态自动机**

### 指令执行状态分析
![[23-CPU-design-multicycle.png]]