
## 冲突的种类

- 什么是流水线中的“冲突”？
	- 在流水线中经常有一些被称为“冲突”的情况发生，它使得指令序列中下一条指令无法按照设计的时钟周期执行，这些“冲突”可能会降低流水线可以获得的理想性能。
- 流水线中的冲突种类
	- 第一种是结构冲突，是指令在重叠执行的过程中，硬件资源满足不了指令重叠执行的要求，发生硬件资源冲突而产生的冲突。
	- 第二种是数据冲突，是指在同时重叠执行的几条指令中，一条指令依赖于前面指令执行结果数据，但是又得不到时发生的冲突。
	- 第三种是控制冲突，它是指流水线中的分支指令或者其他需要改写 PC 的指令造成的冲突。
- 解决流水线中“冲突”问题的重要性
	- 流水线冲突问题是流水线执行过程中的主要障碍，会给流水线中指令序列的顺利执行带来许多不利的影响。
	- 如果不能较好的处理流水线冲突问题，就可能影响流水线的性能，甚至使程序运行产生错误的结果。

### 结构冲突

![[25-Hazard-handle-structure-hazards.png]]
- 同一个时间段内，同一个部件的同一功能端口被不同的指令同时使用——硬件资源不足
- 解决策略：
	1. 通过合理的功能划分，要求一个部件每条指令只能使用一次，且只能在特定周期使用，避免一部分结构冲突
	2. 设置多个独立部件来避免结构冲突，本质是增加硬件资源的数量：
		- 如区分寄存器的写端口和读端口，分别用使用下降沿和上升沿触发
		- 如区分存储器的指令部分和数据部分（哈佛架构），从而使指令和数据的访问各自独立；

![[25-Hazard-handle-structure-hazards-handle.png]]
- IM 和 DM 是指令存储器和数据存储器；
- 现代 L1 cache 天然区分 i-cache 和 d-cache，由此可以避免结构冲突
- Reg 分前半周期和后半周期进行访问，实现写端口和读端口独立地访问；

### 数据冲突

![[25-Hazard-handle-data-hazards.png]]
- 后发指令需要前面指令的结果时，却还没有产生、或正在产生但没有写入到寄存器中；
- 上图的所有数据冲突都是由于前面的指令在写结果之前，后面的指令就要读取，这称为写后读 Read After Write 数据冲突
- 事实上，在非“乱序”执行的流水线中，所有数据冲突都是 RAW 冲突；

解决策略：

#### 插入空操作

![[25-Hazard-handle-nop.png]]
- 编译器采取措施，插入空操作指令 nop，其作用仅仅是 PC+4
- 优点：硬件控制简单
- 缺点：指令空间需要预备一条 nop 指令，并且浪费了指令的执行时间（上图中浪费了 5 条指令的空间和时间）

#### 插入气泡

![[25-Hazard-handle-stall.png]]
- 硬件上采取措施，阻塞 stall 相关指令、使其延迟执行
- 实现起来比较复杂，需要修改数据通路，检测哪两条指令发生了数据相关，以确定是否需要阻塞；
- 阻塞时，可以将控制信号清零来阻止结果的写入；也可以将指令清零使后续指令执行空操作；或让 PC 写使能信号清零，PC 值不变，使当前指令重复执行；
- 优缺点：不占用指令条数，但是有额外的时间开销；

#### 转发技术


#### Load-use 冒险

### 控制冲突

