## 进程概念
进程是能分配给处理器并由处理器执行的实体，由一组执行的指令、一个当前状态和一组相关系统资源所表示的活动单元，其两个基本元素是程序代码和与代码关联的数据集。

PCB 表征进程执行的任意时刻的所有信息：
![[Pasted image 20230731230654.png]]

## 进程状态

### 进程状态模型
#### 两状态模型 (running or not)
![[two-status-shift-queue-diagram.png]]

#### 五状态模型 (ready? running:blocked)
![[Pasted image 20230722122910.png]]

![[Pasted image 20230722125935.png]]

#### 六状态模型 (add suspend)
![[Pasted image 20230722122942.png]]

#### 七状态模型 (suspend read/suspend wait)
![[Pasted image 20230722123746.png]]

## 进程描述
![[Pasted image 20230731231250.png]]

### OS控制结构
![[Pasted image 20230801173105.png]]

### 进程控制结构
![[Pasted image 20230801174644.png]]

![[Pasted image 20230801184219.png]]

![[Pasted image 20230801180711.png]]

## 进程控制

### 执行模式
**两种执行模式**：
- 与操作系统关联的处理器执行模式，特权模式（或称，控制模式、内核模式、系统模式）；
- 与用户程序关联的处理器执行模式，非特权模式；

**处理器怎么知道正在什么模式运行**？
- PSW 状态字中存在一个指示执行模式的位
	- 用户调用 OS 服务或中断进而触发系统例程执行时，置为内核模式；
	- 当系统服务返回用户进程时，置为用户模式。

**如何设置模式**？（以 IA-64 结构、Linux 系统为例）
- 处理器中 PSR (Processor Status Register)有一个 2 bit 字段 CPL，置为 0 时是最高特权级，3 是最低特权级；
- 中断发生时，CPL 置零；中断处理程序的最后一个指令会使处理器在返回时恢复中断程序的 PSR。

### 进程创建
1. 分配唯一的进程标识符 PID；
2. **为进程分配空间**：包含进程映像中所有元素；
3. **初始化进程控制块**：
	- 处理进程标识 ID 和其它相关 ID；
	- 初始化处理器状态信息；
	- 初始化进程控制信息；
	- 优先级默认最低，除非显式请求；
	- 初创时不拥有任何资源；
4. **设置正确地链接**：将调度队列维护为链表，新进程放在就绪、就绪/挂起链表中；
5. 维护其它数据结构；

### 进程切换
**什么事件触发了进程切换**？
1. 中断
	- 时钟中断；
	- IO 中断
	- 内存失效
2. 陷阱
	- 运算除 0；
	- 
3. 系统调用
	- IO 请求

**模式切换和进程切换有什么区别**？
- 模式切换指的是处理器运行指令的权限是否在用户态和内核态切换；进程切换指当前进程是否运行结束、时间片耗尽等，需要下一个就绪态进程占据 CPU。
- 模式切换可在不改变运行态进程的状态时出现，此时保存上下文及恢复的开销很小；

**保存的上下文有什么**？
- 中断处理程序可能改变的所有信息，如PSW；
- 恢复被中断程序时需要的所有信息，如 PC；

保存和恢复上下文都由硬件实现

**出现中断时，处理器会进行什么工作**？——模式切换
1. PC 置于中断处理程序开始处；
2. 用户模式切换到内核模式，以便中断处理代码直接运行特权指令
3. 处理器处于中断处理程序第一条指令的取指阶段，在此之前保存被中断进程的上下文到其 PCB 中

**完整的进程切换步骤**？
1. 保存处理器上下文；
2. 更新当前处于运行态进程的进程控制块，包括进程状态、退出运行态原因、记账信息等；
3. 将该进程的 PCB 移动到相应队列（就绪、阻塞、就绪/挂起）；
4. 选择另一个就绪态进程开始执行，更新对应 PCB，如运行状态信息；
5. 更新内存管理数据结构，取决于管理地址转换的方式；
6. 载入 PC 和其它寄存器先前的值，恢复上下文到切换前；

**要实现进程切换，操作系统对控制的数据结构做什么改动**？
上一问题的 2、3、4、5

## OS 执行（设计方法）
- OS 与普通计算机软件同样运行在处理器上，也是一个程序；
- OS 会频繁地释放控制权，并依赖于处理器来恢复控制权；

![[Pasted image 20230801194109.png]]

### 无进程内核
内核在所有进程的外部执行，二者分离，如图 a
- 运行中进程遇到中断或 syscall，会保存上下文并转移控制权到内核；
- OS 本身具有控制过程调用和返回的内存区域与系统栈；
- OS 可以执行任何预期的功能，并恢复被中断进程的上下文，恢复中断用户进程的执行；
- OS 也可以保存进程的模式上下文，并继续调度和分派另一个进程，这取决于中断的原因和当前的情况；

此方案中，**进程只适用于用户程序，OS 代码是在特权模式下单独运行的实体**。

### 在用户进程内执行
在用户进程的上下文中执行所有 OS 软件，此时 OS 是用户调用的一组例程，在用户进程的环境内执行并实现各种功能，如图 b

任何时刻 OS 都管理着 n 个进程映像，这里的进程映像包括内核程序的代码、数据、栈区域：
![[Pasted image 20230801211852.png]]

因此发生中断、陷阱或系统调用时，该方案中处理器置于内核模式，控制权交给 OS，此前保存了模式上下文，并切换到 OS 例程。注意，此时仍然处于当前用户进程内，只是切换了模式，而不是切换了进程。OS 执行完操作后，切换模式以在当前进程内恢复中断前的流程。

该方案最大的优点是，不论中断还是恢复，都不会产生进程切换的巨大开销。如要进行进程切换，则要调用进程切换例程作专门处理。

### 基于进程的 OS
第三种方案是将 OS 作为一组系统例程实现，内核功能被组织成独立的进程，如图 c

优点是鼓励使用模块化 OS 的程序设计原理，精简了模块间接口；对非关键 OS 功能使用独立进程实现，比如用以提供资源利用率的监视；最后在多处理器和分布式环境中性能较好。

## 线程
**引入线程前，进程特点**：
- 资源所有权：对存放进程映像的虚拟地址空间有控制、所有权；
- 调度执行权：多进程的执行过程会交替进行，进程是被操作系统调度和分派的实体

**引入线程**，就是为了拆分调度执行权，更加细分地利用进程申请的资源，提高效率。

### 多线程
![[Pasted image 20230801215127.png]]

多线程环境中，**进程成为了资源分配单元和保护单元**，其包括：
1. 容纳进程映像的虚拟地址空间；
2. 对处理器、其它进程、文件和 IO 资源的受保护访问；

进程中包含若干线程，每个线程包括：
1. 线程运行状态；
2. 未运行时保存的线程上下文，线程视为进程内运行的独立程序计数器；
3. 一个执行栈；
4. 每个线程用于保存局部变量的静态存储空间；
5. 与进程内其它线程共享的内存和资源访问；

![[Pasted image 20230801220249.png]]

线程优点：

单用户多处理器系统中使用线程的例子：
1. 前台与后台工作

### 线程功能

线程执行状态

线程同步

## 线程分类

## 多核与多线程
