Peterson 算法实现：

```cpp
#include <iostream>
#include <vector>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <chrono>
#include <random>

constexpr int BSIZE = 8; // buffer size
constexpr int PWT = 2; // producer wait time limit
constexpr int CWT = 10; // consumer wait time limit
constexpr int RT = 10; // program run-time in seconds

std::mutex mtx; // 互斥锁，用于保护共享数据的访问
std::condition_variable cv; // 条件变量，用于线程间的等待和通知

bool SHM1[2] = {false, false}; // 用于进程间的标志位共享
int SHM2 = 0; // 用于进程间的共享变量
std::vector<int> SHM3(BSIZE, 0); // 用于进程间的共享数组
int SHM4 = 1; // 用于进程间的共享变量

int myrand(int n) {
    static std::mt19937 gen(std::chrono::high_resolution_clock::now().time_since_epoch().count());
    std::uniform_int_distribution<int> dist(1, n);
    return dist(gen);
}

void producer() {
    while (true) {
        SHM1[1] = true; // 表示生产者准备好了
        std::cout << "Producer is ready now." << std::endl << std::endl;
        SHM2 = 0; // 生产者将共享变量设置为0

        std::unique_lock<std::mutex> lock(mtx); // 获取互斥锁
        cv.wait(lock, [&]{ return !SHM1[0] && SHM2 == 0; }); // 等待条件变量满足，解锁互斥锁

        // 临界区开始
        int index = 0;
        while (index < BSIZE) {
            if (SHM3[index] == 0) {
                int tempo = myrand(BSIZE * 3);
                std::cout << "Job " << tempo << " has been produced" << std::endl;
                SHM3[index] = tempo;
                break;
            }
            index++;
        }
        if (index == BSIZE) {
            std::cout << "Buffer is full, nothing can be produced!!!" << std::endl;
        }
        std::cout << "Buffer: ";
        for (int value : SHM3) {
            std::cout << value << " ";
        }
        std::cout << std::endl;
        // 临界区结束

        SHM1[1] = false; // 生产者完成
        lock.unlock(); // 解锁互斥锁
        cv.notify_one(); // 通知等待的线程

        if (SHM4 == 0) { // 如果共享变量SHM4为0，退出循环
            break;
        }

        int wait_time = myrand(PWT);
        std::cout << "Producer will wait for " << wait_time << " seconds" << std::endl << std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(wait_time));
    }
}

void consumer() {
    std::this_thread::sleep_for(std::chrono::seconds(5));
    while (true) {
        SHM1[0] = true; // 表示消费者准备好了
        std::cout << "Consumer is ready now." << std::endl << std::endl;
        SHM2 = 1; // 消费者将共享变量设置为1

        std::unique_lock<std::mutex> lock(mtx); // 获取互斥锁
        cv.wait(lock, [&]{ return !SHM1[1] && SHM2 == 1; }); // 等待条件变量满足，解锁互斥锁

        // 临界区开始
        if (SHM3[0] != 0) {
            std::cout << "Job " << SHM3[0] << " has been consumed" << std::endl;
            SHM3[0] = 0;
            for (size_t i = 1; i < BSIZE; ++i) {
                SHM3[i - 1] = SHM3[i];
            }
            SHM3[BSIZE - 1] = 0;
        } else {
            std::cout << "Buffer is empty, nothing can be consumed!!!" << std::endl;
        }
        std::cout << "Buffer: ";
        for (int value : SHM3) {
            std::cout << value << " ";
        }
        std::cout << std::endl;
        // 临界区结束

        SHM1[0] = false; // 消费者完成
        lock.unlock(); // 解锁互斥锁
        cv.notify_one(); // 通知等待的线程

        if (SHM4 == 0) { // 如果共享变量SHM4为0，退出循环
            break;
        }

        int wait_time = myrand(CWT);
        std::cout << "Consumer will sleep for " << wait_time << " seconds" << std::endl << std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(wait_time));
    }
}

int main() {
    std::thread producerThread(producer);
    std::thread consumerThread(consumer);

    std::this_thread::sleep_for(std::chrono::seconds(RT));
    SHM4 = 0;

    cv.notify_all(); // 通知所有等待的线程
    producerThread.join();
    consumerThread.join();

    std::cout << "The clock ran out." << std::endl;
    return 0;
}
```

## 信号量方法的实现
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

class BiSemaphore {
public:
    explicit BiSemaphore(int initial) : value(initial) {}

    void signal() {
        std::unique_lock<std::mutex> lock(mutex);
        value++;
        cv.notify_all();
    }

    void wait() {
        std::unique_lock<std::mutex> lock(mutex);
        cv.wait(lock, [this]() { return value > 0; });
        value--;
    }

    void waitWithTimeout(std::chrono::milliseconds timeout) {
        std::unique_lock<std::mutex> lock(mutex);
        if (!cv.wait_for(lock, timeout, [this]() { return value > 0; })) {
            // Handle timeout if needed
        }
        value--;
    }

private:
    int value;
    std::mutex mutex;
    std::condition_variable cv;
};

int n = 0;
BiSemaphore s(1);
BiSemaphore delay(0);

void produce() {
    // Produce operation
}

void append() {
    // Append operation
}

void consume() {
    // Consume operation
}

void take() {
    // Take operation
}

void producer() {
    while (true) {
        produce();
        s.wait();
        append();
        n++;
        if (n == 1) {
            delay.signal();
        }
        s.signal();
    }
}

void consumer() {
    int m;
    delay.wait();
    while (true) {
        s.wait();
        take();
        n--;
        m = n;
        s.signal();
        consume();
        if (m == 0) {
            delay.wait();
        }
    }
}

int main() {
    n = 0;
    std::thread producerThread(producer);
    std::thread consumerThread(consumer);

    producerThread.join();
    consumerThread.join();

    return 0;
}

```

## 管程方法实现
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

class BoundedBuffer {
public:
    BoundedBuffer(int bufferSize) : buffer(bufferSize), nextin(0), nextout(0), count(0) {}

    void append(char x) {
        std::unique_lock<std::mutex> lock(mutex);
        notFull.wait(lock, [this]() { return count < buffer.size(); });
        buffer[nextin] = x;
        nextin = (nextin + 1) % buffer.size();
        count++;
        notEmpty.notify_one();
    }

    void take(char &x) {
        std::unique_lock<std::mutex> lock(mutex);
        notEmpty.wait(lock, [this]() { return count > 0; });
        x = buffer[nextout];
        nextout = (nextout + 1) % buffer.size();
        count--;
        notFull.notify_one();
    }

private:
    std::vector<char> buffer;
    size_t nextin, nextout, count;
    std::mutex mutex;
    std::condition_variable notFull, notEmpty;
};

BoundedBuffer boundedBuffer(N); // N is the buffer size

void producer() {
    char x;
    while (true) {
        produce(x);
        boundedBuffer.append(x);
    }
}

void consumer() {
    char x;
    while (true) {
        boundedBuffer.take(x);
        consume(x);
    }
}

int main() {
    std::thread producerThread(producer);
    std::thread consumerThread(consumer);

    producerThread.join();
    consumerThread.join();

    return 0;
}

```

## 消息传递方法实现
```cpp
#include <iostream>
#include <thread>
#include <condition_variable>
#include <queue>
#include <mutex>

const int capacity = /* buffering capacity */;
int i;

struct Message {
    // Define the structure of your message here
    // For simplicity, let's assume a single integer value
    int value;
};

std::queue<Message> buffer;
std::mutex bufferMutex;
std::condition_variable mayProduce, mayConsume;

Message nullMessage;

Message produce() {
    Message msg;
    msg.value = ++i;
    return msg;
}

void producer() {
    while (true) {
        Message pmsg;
        {
            std::unique_lock<std::mutex> lock(bufferMutex);
            mayProduce.wait(lock, [] { return buffer.size() < capacity; });
            pmsg = produce();
            buffer.push(pmsg);
        }
        mayConsume.notify_one();
    }
}

void consume(const Message& msg) {
    // Process the consumed message
    std::cout << "Consumed: " << msg.value << std::endl;
}

void consumer() {
    while (true) {
        Message cmsg;
        {
            std::unique_lock<std::mutex> lock(bufferMutex);
            mayConsume.wait(lock, [] { return !buffer.empty(); });
            cmsg = buffer.front();
            buffer.pop();
        }
        if (cmsg.value == nullMessage.value) {
            // Break the loop if null message is received
            break;
        }
        consume(cmsg);
        mayProduce.notify_one();
    }
}

int main() {
    i = 0;

    std::thread producerThread(producer);
    std::thread consumerThread(consumer);

    // Create initial null messages in the buffer
    for (int i = 1; i <= capacity; i++) {
        buffer.push(nullMessage);
    }

    // Start producer and consumer threads
    producerThread.join();
    consumerThread.join();

    return 0;
}

```