## 概念介绍

### 进程
- 进程是操作系统内独立且隔离的执行单元。它包含自己的内存空间、代码、数据和系统资源。进程由操作系统内核进行管理和调度。
- 每个进程都有独特的进程标识符（PID），用于区分其他进程。
- 进程提供很高的隔离性，一个进程不能直接访问另一个进程的内存或资源。要在进程之间进行通信，需要使用进程间通信（IPC）机制，如管道、套接字或消息传递。
- 启动一个进程通常涉及复制父进程的状态和内存，之后子进程独立运行。

### 线程
- 线程是进程内的最小执行单元。与进程不同，线程共享其父进程的内存空间和资源。
- 线程比进程轻量，创建和在线程之间切换的开销较小。由于它们共享相同的内存空间，同一进程内的线程之间的通信和数据共享更为高效。
- 进程内的线程可以访问共享数据，这可能导致同步问题，并需要线程同步机制（如锁和信号量）来确保数据的完整性。
- 线程适用于涉及并行性的任务，例如在网络服务器中处理多个连接。

### 协程
- 协程是一种编程抽象，允许函数在特定点暂停和恢复执行，而不会丢失其状态。也称为“协作式多任务处理”。
- 与线程不同，线程是由操作系统抢占式调度的，协程依赖于开发者在适当的时候主动放弃控制权，将执行权交给另一个协程。
- 协程通常比线程更轻量级，因为它们不需要为每个协程分配独立的内存栈，而是与调用它们的函数共享相同的栈。
- 协程适用于管理涉及顺序或非阻塞操作的任务，例如异步 I/O 或事件驱动编程。

### 联系和区别
- 进程和线程由操作系统进行管理，而协程由应用程序本身或协程库进行管理。
- 进程是彼此隔离的，而线程共享同一进程的内存空间和资源。
- 线程比进程更轻量级，创建和在线程之间切换的开销较小。
- 协程比线程更轻量级，因为不需要为每个协程分配独立的内存栈。
- 进程和线程是并发的，由操作系统调度它们的执行。协程是协作式的，需要主动放弃控制权。
- 进程间通信需要使用 IPC 机制，而同一进程内的线程可以直接通过共享内存进行通信。
- 线程适用于并行任务，而协程适用于顺序或非阻塞操作。

> 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [zhuanlan.zhihu.com](https://zhuanlan.zhihu.com/p/337978321)

> 本文已收录 Github：[imcoderlemon/CodeClass](https://github.com/imcoderlemon/CodeClass) 从小白到架构师，关于编程所有你需要掌握的内容都在这里

**进程线程可以说是操作系统基础**，看过很多关于这方面知识的文章都是纯理论讲述，编程新手有些难以下咽。

**我准备用图解的形式带你学习和掌握进程、线程、协程**。文字力求简单明了，对于复杂概念做到一个概念一张图解，在操作系统课程的学习中，很多人对进程线程有大体的认识，但操作系统教材更偏向于理论叙述，本文会结合 Linux 系统实现分析，更加印象深刻。

同时，大部分人都接触进程和线程比较多，对协程知之甚少，然而最近协程并发编程技术火热起来，希望读完本文你对协程也有一个基本的了解。

话不多说，我们马上进入本文的学习。

## 进程

### 进程与资源

那么进程都管理哪些资源呢？ 通常包括内存资源、IO 资源、信号处理等部分。

![[process-resource.png]]

篇幅有限着重说一下内存管理，进程运行起来必然会涉及到对内存资源的管理。内存资源有限，**操作系统采用虚拟内存技术，把进程虚拟地址空间划分成用户空间和内核空间。**

### 地址空间

4 GB 的进程虚拟地址空间被分成两部分：用户空间和内核空间

![](https://pic1.zhimg.com/v2-4ff18e725b19cb250800ec3e7ce4aeb8_b.jpg)

### 用户空间

用户空间按照**访问属性一致的地址空间存放在一起的原则**，划分成 5 个不同的内存区域。 访问属性指的是 “可读、可写、可执行等 。

*   代码段

代码段是用来存放可执行文件的操作指令，可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，它是不可写的。

*   数据段

数据段用来存放可执行文件中已初始化全局变量，换句话说就是存放程序静态分配的变量和全局变量。

*   BSS 段

BSS 段包含了程序中未初始化的全局变量，在内存中 bss 段全部置零。

*   堆 heap

堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用 malloc 等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用 free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）

*   栈 stack

栈是用户存放程序临时创建的局部变量，也就是函数中定义的变量（但不包括 static 声明的变量，static 意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进后出特点，所以栈特别方便用来保存 / 恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。

上述几种内存区域中数据段、BSS 段、堆通常是被连续存储在内存中，在位置上是连续的，而代码段和栈往往会被独立存放。堆和栈两个区域在 i 386 体系结构中栈向下扩展、堆向上扩展，相对而生。

![](https://pic3.zhimg.com/v2-36e2a0f6c1765fdbbefe63c8fb5dfaa2_b.jpg)

你也可以再 linux 下用 size 命令查看编译后程序的各个内存区域大小：

```
[lemon ~]# size /usr/local/sbin/sshd
   text    data     bss     dec     hex filename
1924532   12412  426896 2363840  2411c0 /usr/local/sbin/sshd
```

### 内核空间

在 x 86 32 位系统里，Linux 内核地址空间是指虚拟地址从 0 xC 0000000 开始到 0 xFFFFFFFF 为止的高端内存地址空间，总计 1 G 的容量， 包括了内核镜像、物理页面表、驱动程序等运行在内核空间 。

![](https://pic4.zhimg.com/v2-21f351e22de25fdb267647775a06f2fb_b.jpg)

线程
--

线程是操作操作系统能够进行运算调度的最小单位。线程被包含在进程之中，是进程中的实际运作单位，一个进程内可以包含多个线程，**线程是资源调度的最小单位。**

### 线程资源和开销

同一进程中的多条线程共享该进程中的全部系统资源，如虚拟地址空间，文件描述符文件描述符和信号处理等等。但同一进程中的多个线程有各自的调用栈、寄存器环境、线程本地存储等信息。

线程创建的开销主要是线程堆栈的建立，分配内存的开销。这些开销并不大，最大的开销发生在线程上下文切换的时候。

![](https://pic1.zhimg.com/v2-b06ec7a97613d7d0a8f4a279b6000360_b.jpg)

### 线程分类

还记得刚开始我们讲的内核空间和用户空间概念吗？线程按照实现位置和方式的不同，也分为用户级线程和内核线程，下面一起来看下这两类线程的差异和特点。

### 用户级线程

实现在用户空间的线程称为用户级线程。用户线程是完全建立在用户空间的线程库，用户线程的创建、调度、同步和销毁全由用户空间的库函数完成，不需要内核的参与，因此这种线程的系统资源消耗非常低，且非常的高效。

### 特点

*   用户线级线程只能参与竞争该进程的处理器资源，不能参与全局处理器资源的竞争。
*   用户级线程切换都在用户空间进行，开销极低。
*   用户级线程调度器在用户空间的线程库实现，内核的调度对象是进程本身，内核并不知道用户线程的存在。

![](https://pic3.zhimg.com/v2-9eb0c5ceb0a68258bc8dd00c1d09f3b2_r.jpg)

### 缺点

*   如果触发了引起阻塞的系统调用的调用，会立即阻塞该线程所属的整个进程。
*   系统只看到进程看不到用户线程，所以只有一个处理器内核会被分配给该进程 ，也就不能发挥多核 CPU 的优势 。

### 内核级线程

内核级线程是指，内核线程建立和销毁都是由操作系统负责、通过系统调用完成的，内核维护进程及线程的上下文信息以及线程切换。

### 特点

*   内核级线级能参与全局的多核处理器资源分配，充分利用多核 CPU 优势。
*   每个内核线程都可被内核调度，因为线程的创建、撤销和切换都是对内核管理的。
*   一个内核线程阻塞与他同属一个进程的线程仍然能继续运行。

![](https://pic2.zhimg.com/v2-e677e892fcdad78f21c380825b426211_r.jpg)

### 缺点

*   内核级线程调度开销较大。调度内核线程的代价可能和调度进程差不多昂贵，代价要比用户级线程大很多。
*   线程表是存放在操作系统固定的表格空间或者堆栈空间里，所以内核级线程的数量是有限的。

### Linux 线程实现

Linux 并没有为线程准备特定的数据结构，因为 Linux 只有 task_struct 这一种描述进程的结构体。在内核看来只有进程而没有线程，线程调度时也是当做进程来调度的。Linux 所谓的线程其实是与其他进程共享资源的**轻量级进程**。

为什么说是轻量级呢？在于它只有一个最小的执行上下文和调度程序所需的统计信息，它只带有进程执行相关的信息，与父进程共享进程地址空间 。

### 轻量级进程

轻量级线程 Light-weight Process 简称 LWP ，是一种由内核支持的用户线程，每一个轻量级进程都与一个特定的内核线程关联。

它是基于内核线程的高级抽象，系统只有先支持内核线程才能有 LWP。每一个进程有一个或多个 LWPs ，每个 LWP 由一个内核线程支持，在这种实现的操作系统中 LWP 就是用户线程。

![](https://pic1.zhimg.com/v2-1b47808502ed504097c660f8e9422b00_b.jpg)

轻量级进程最早在 Linux 内核 2.0. x 版本就已实现，应用程序通过一个统一的 clone () 系统调用接口，用不同的参数指定创建的进程是轻量进程还是普通进程。

### 特点和缺点

由于轻量轻量级进程基于内核线程实现，因此它的特点和缺点就是内核线程的缺点，这里不再赘述。

### 查看 LWP 信息

轻量级线程也没什么神秘的，还记得我在这篇文章《资深程序员总结：分析 Linux 进程的 6 个方法，我全都告诉你》教你的方法吗？我们用 Linux 的 pstack 命令可以查看进程的轻量级线程 LWP 信息。下图的黄色字体就是打印出的轻量级线程 ID ，以及该线程的调用堆栈信息，从最新的栈帧开始往下排列。

用法示例： pstack pid

![](https://pic3.zhimg.com/v2-1c5abf3b30b1ff0530fe09a83b7807ae_r.jpg)

协程
--

协程的知名度好像不是很高，在以前我们谈论高并发，大部分人都知道利用多线程和多进程部署服务，提高服务性能，但一般不会提到协程。其实协程的概念出来的比线程还早，只不过最近才被人们更多的提起。

协程之所以最近被大家熟知，个人觉得是 Python 和 Go 从语言层面提供了对协程更好的支持，尤其是以 Goroutine 为代表的 Go 协程实现，很大程度上降低了协程使用门槛，可以说是后起之秀了！

![](https://pic4.zhimg.com/v2-97326500b21d26e751d3604bf6f85ceb_b.gif)

### why 协程

当今无数的 Web 服务和互联网服务，本质上大部分都是 IO 密集型服务，什么是 IO 密集型服务？意思是处理的任务大多是和网络连接或读写相关的高耗时任务，高耗时是相对 CPU 计算逻辑处理型任务来说，两者的处理时间差距不是一个数量级的。

**IO 密集型服务的瓶颈不在 CPU 处理速度，而在于尽可能快速的完成高并发、多连接下的数据读写。**

**以前有两种解决方案：**

*   如果用多线程，高并发场景的大量 IO 等待会导致多线程被频繁挂起和切换，非常消耗系统资源，同时多线程访问共享资源存在竞争问题。
*   如果用多进程，不仅存在频繁调度切换问题，同时还会存在每个进程资源不共享的问题，需要额外引入进程间通信机制来解决。

**协程出现给高并发和 IO 密集型服务开发提供了另一种选择。**

当然，世界上没有技术银弹，在这里我想把协程这把钥匙交到你手中，但是它也不是万能钥匙，最好的解决方案是贴合自身业务类型做出最优选择，不一定就选择一种模型，有时候是几种模型的组合，比如多线程搭配协程是常见的组合。

### 什么是协程

**那什么是协程呢？协程 Coroutines 是一种比线程更加轻量级的微线程。**类比一个进程可以拥有多个线程，一个线程也可以拥有多个协程，因此协程又称微线程和纤程。

![](https://pic1.zhimg.com/v2-e42121b8e5588bdbd27b989c91e35190_r.jpg)

**可以粗略的把协程理解成子程序调用，每个子程序都可以在一个单独的协程内执行。**

![](https://pic3.zhimg.com/v2-87bffe39bec109f0c29658b13ac92bb2_b.jpg)

### 调度开销

线程是被内核所调度，线程被调度切换到另一个线程上下文的时候，需要保存一个用户线程的状态到内存，恢复另一个线程状态到寄存器，然后更新调度器的数据结构，这几步操作设计用户态到内核态转换，开销比较多。

![](https://pic1.zhimg.com/v2-b06ec7a97613d7d0a8f4a279b6000360_b.jpg)

协程的调度完全由用户控制，协程拥有自己的寄存器上下文和栈，协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作用户空间栈，完全没有内核切换的开销。

![](https://pic4.zhimg.com/v2-083f9b453b38c5a04d2f4ccf02cdbebf_b.jpg)

### 动态协程栈

协程拥有自己的寄存器上下文和栈，协程调度切换时将寄存器上下文和栈保存下来，在切回来的时候，恢复先前保存的寄存器的上下文和栈。

Goroutine 是 Golang 的协程实现。Goroutine 的栈只有 2 KB 大小，而且是动态伸缩的，可以按需调整大小，最大可达 1 G 相比线程来说既不浪费又灵活了很多，可以说是相当的 nice 了！

线程也都有一个固定大小的内存块来做栈，一般会是 2 MB 大小，线程栈会用来存储线程上下文信息。2 MB 的线程栈和协程栈相比大了很多。

![](https://pic2.zhimg.com/v2-cdee0006236af4a271a2285ebe9b9d79_b.jpg)

### 协程实现

### Python 协程实现

正如刚才所写的代码示例，python 2.5 中引入 yield/send 表达式用于实现协程，但这种通过生成器的方式使用协程不够优雅。

python 3.5 之后引入 async/await ，简化了协程的使用并且更加便于理解。

### Go 语言协程实现

Golang 在语言层面实现了对协程的支持，Goroutine 是协程在 Go 语言中的实现， 在 Go 语言中每一个并发的执行单元叫作一个 Goroutine ，Go 程序可以轻松创建成百上千个协程并发执行。

Go 协程调度器有三个重要数据结构：

*   G 表示 Goroutine ，它是一个待执行的任务；
*   M 表示操作系统的线程，它由操作系统的调度器调度和管理；
*   P 表示处理器 Processor，它可以被看做运行在线程上的本地调度器；

![](https://pic1.zhimg.com/v2-e6535eeae1de80d692e99cb58302a1ec_b.jpg)

Go 调度器最多可以创建 10000 个线程，但可以通过设置 GOMAXPROCS 变量指能够正常运行的运行， 这个变量的默认值 等于 CPU 个数，也就是线程数等于 CPU 核数，这样不会触发操作系统的线程调度和上下文切换，所有的调度由 Go 语言调度器触发，都是在用户态，减少了非常多的调用开销。

总结
--

这篇文章讲解和对比了进程、线程的概念，同时通过进程窥探到操作系统内存管理的冰山一角，另外还讲解了具体到 Linux 系统下线程的实现现状，顺势引出了轻量级进程的概念。最后着重说明了大部分同学不太了解的协程，通过对比不同的服务模型，带你了解协程的特点。

看到这里的小伙伴，对！说的就是你，如果对你有帮助

只希望你 **点个赞、感谢与收藏**~

**一是当做对我的鼓励，**

**三是防止下次想看却找不到**

如果你也是**编程和计算机爱好者**，下面我写的其他回答应该对你也有帮助：

[后端都要学习什么？](https://www.zhihu.com/question/24952874/answer/1602200603) [Visual Studio Code 如何编写运行 C、C++ 程序？](https://www.zhihu.com/question/30315894/answer/1574277687) [什么是微服务架构？](https://www.zhihu.com/question/65502802/answer/1587913583) [有哪些你看了以后大呼过瘾的编程书？](https://www.zhihu.com/question/50408698/answer/1594991093)

最后再絮叨几句，所有的编程开发都离不开计算机基础！如果能参考国内一流大学的教材来学，更能是事半功倍，下面这个开源项目，**包含了浙大计算机专业 4 年所学内容：教材 + 课件 + 试卷 + PPT 等等：**

[程序员柠檬橙：看完这份浙大计算机本科课程共享计划，我也上了个 985](https://zhuanlan.zhihu.com/p/336377397)

另外，我当初在准备各大公司技术笔试的时候刷了大量的算法题，其中就是参考了**一本谷歌大神的 LeetCode 刷题笔记**，帮我整理了解题思路，归纳了出刷题方法，非常不出错，转给需要的同学：

[慌，晋级答辩要代码走读](https://mp.weixin.qq.com/s/DM4XoW4rTcaQ9ZgB7C2oVg)

**更多干货文章，关注我的专栏：**

[学编程，涨工资](https://www.zhihu.com/column/c_1326224372755771392)

**如果文章对你有帮助，「点赞、感谢、收藏」激励我持续创作**。

![](https://picx.zhimg.com/v2-5e2e216cf09c38985dba7fb2fc19d133_l.jpg?source=f2fdee93)程序员柠檬 10 次咨询 5.0 腾讯 高级工程师 17302 次赞同去咨询

> **原创声明**：个人技术博客「程序员柠檬」  
> **文章链接：**[40 篇原创技术文章，助你编程能力突飞猛进！](https://mp.weixin.qq.com/s/wdD4LFsR_IilPBTIxWpJ2A)