

## 并发原理

### 棘手的原因
单处理器中，并发处理棘手之处在于：**进程的相对执行速度不可预测**。其取决于其他进程的活动、OS 处理中断的方式、OS 的调度策略。

因此并发问题面临着如下难关：
- 全局资源的共享非常危险；
- OS 很难对资源进行最优化分配；
- 定位程序设计的错误非常困难；

### 解决方案

**控制对共享资源的访问。**

### 竞争条件
多个进程或线程进行读写数据时，最终结果取决于多个进程的指令执行顺序，竞争失败者（最后操作）反而决定最终结果的走向。（画家算法）

#### 如何用信号量解决竞争条件？

### OS 如何处理并发？
1. 必须跟踪不同的进程。即 PCB 的作用；
2. 必须为每个活动进程分配和释放各种资源，如处理器时间、存储器、文件、IO 设备等；
3. 必须保护每个进程的数据和物理资源；
4. 进程的功能呢个和输出结果必须与执行速度无关；

### 进程间的关系

![[Pasted image 20230810195428.png]]

#### 进程间资源竞争
没有任何信息交换，但一个进程的执行可能会影响到竞争进程的行为。

控制问题：
1. 互斥：一次只允许一个程序在临界区中；
2. 死锁；
3. 饥饿；

#### 进程间通过共享合作
互相在不确切知道对方的情况下进行交互，知道其他进程可能访问同一数据，因此进程间必须合作以确保共享的数据能够正确管理。

新的要求：数据一致性。考虑：
```
P1{ a=a+1; b=b+1;}
P2{ b=2*b; a=2*a;}

// 各自独立执行能够保证结果的一致，即a=b
// 若并发执行，则有可能a!=b，如：
a=a+1;
b=2*b;
b=b+1;
a=2*a;
```

#### 进程间通过通信合作
各进程与其他进程连接，通信提供同步和协调活动的方法。

传递消息中未共享任何对象，因此不必互斥，但仍存在死锁和饥饿问题。

### 互斥的要求
1. 必须强制实施互斥，互斥访问资源时一次只许一个进程进入临界区；（忙则等待）
2. 在非临界区停止的进程不能干涉其他进程；（进程独立性）
3. 不能出现死锁或饥饿；
4. 临界区空时，需要进入临界区的进程能够立即进入；（空则准入）
5. 对相关进程的执行速度和处理器数量没有限制；
6. 进程驻留在临界区中的时间有限，等待进入临界区中的时间也有限；（有限等待）

### 满足互斥的方法

#### 软件方法
让并发执行的进程承担

#### 硬件方法
使用专用机器指令，优点是系统开销小，缺点是难以通用；

#### 操作系统或程序设计语言支持
信号量、管程、消息传递

## 互斥：软件实现

![[Pasted image 20230810171247.png]]

### 错误一 ：严格交替进入临界区否则永久阻塞
```
Main(){
	int thread_number = 1;
	startThreads();
}

Thread1(){
	do {
		// entry section
		// wait until threadnumber is 1
		while (threadnumber == 2)	;

		// critical section

		// exit section
		// give access to the other thread
		threadnumber = 2;
	} while (completed == false)
}

Thread2(){
	do {
		// entry section
		// wait until threadnumber is 2
		while (threadnumber == 1)	;

		// critical section

		// exit section
		// give access to the other thread
		threadnumber = 1;
	} while (completed == false)
}
```

turn 值（此处为threadnumber）与进程号不对应，就自旋等待，直到另一进程恢复 turn 值。

缺点：
1. 进程严格交替使用，慢的进程会严重拖累整体运行效率；
2. 一个进程终止，另一个进程被永久阻塞；

### 错误二：查看另一进程状态
```
Main(){
	// flags to indicate if each thread is in
	// its critical section or not.
	boolean thread1 = false;
	boolean thread2 = false;

	startThreads();
}

Thread1(){
	do {
		// entry section
		// wait until thread2 is in its critical section
		while (thread2 == true)	;

		// indicate thread1 entering its critical section
		thread1 = true;

		// critical section

		// exit section
		// indicate thread1 exiting its critical section
		thread1 = false;
	} while (completed == false)
}

Thread2(){
	do {
		// entry section
		// wait until thread1 is in its critical section
		while (thread1 == true)	;

		// indicate thread2 entering its critical section
		thread2 = true;

		// critical section

		// exit section
		// indicate thread2 exiting its critical section
		thread2 = false;
	} while (completed == false)
}
```

flag对应状态，flag[0]关联P0，flag[1]关联P1，周期性检查另一个进程的flag，直到为false，则修改自己flag为true并进入，离开时恢复自己flag为false。

缺点：1.临界区外终止不会影响另一个进程，临界区内终止则另一进程永久阻塞；2.当同时发现另一个进程 flag 为 false 时，会设置自己 flag 为 true，这样连互斥都实现不了。

### 错误三：抢先占用，但会死锁
```
Main(){
	// flags to indicate if each thread is in
	// queue to enter its critical section
	boolean thread1wantstoenter = false;
	boolean thread2wantstoenter = false;

	startThreads();
}

Thread1(){
	do {
		thread1wantstoenter = true;

		// entry section
		// wait until thread2 wants to enter
		// its critical section
		while (thread2wantstoenter == true)	;

		// critical section

		// exit section
		// indicate thread1 has completed
		// its critical section
		thread1wantstoenter = false;
	} while (completed == false)
}

Thread2(){
	do {
		thread2wantstoenter = true;

		// entry section
		// wait until thread1 wants to enter
		// its critical section
		while (thread1wantstoenter == true)	;

		// critical section

		// exit section
		// indicate thread2 has completed
		// its critical section
		thread2wantstoenter = false;
	} while (completed == false)
}
```

algo 2 是由于检查 flag 但还未进入临界区时，就改变自身状态导致失败，因此改进办法是将置为 true 的语句放在忙等待之前。

缺点：1. 临界区内或修改 flag 时失败，另一进程永久阻塞；2. 虽然实现了互斥，但若同时设置 flag 为 true，在 while 时会死锁。

### 错误四：随时重设标志以谦让，低概率活锁
```
Main(){
	// flags to indicate if each thread is in
	// queue to enter its critical section
	boolean thread1wantstoenter = false;
	boolean thread2wantstoenter = false;

	startThreads();
}

Thread1(){
	do {
		thread1wantstoenter = true;

		while (thread2wantstoenter == true) {
			// gives access to other thread
			// wait for random amount of time
			thread1wantstoenter = false;
			sleep(rand_time);
			thread1wantstoenter = true;
		}

		// entry section
		// wait until thread2 wants to enter
		// its critical section

		// critical section

		// exit section
		// indicate thread1 has completed
		// its critical section
		thread1wantstoenter = false;
	} while (completed == false)
}

Thread2(){
	do {
		thread2wantstoenter = true;

		while (thread1wantstoenter == true) {
			// gives access to other thread
			// wait for random amount of time
			thread2wantstoenter = false;
			sleep(rand_time);
			thread2wantstoenter = true;
		}

		// entry section
		// wait until thread1 wants to enter
		// its critical section

		// critical section

		// exit section
		// indicate thread2 has completed
		// its critical section
		thread2wantstoenter = false;
	} while (completed == false)
}
```
algo 3 设置状态前不知另一进程的状态，且进入临界区之前不会回退，导致死锁。若采用谦让机制，每隔一段时间修改自己 flag，让另一进程进入临界区。

缺点：1. 若两进程执行速度完全一致，等待间隔也一致，会产生活锁；
### Dekker 算法

```
Main(){
	// to denote which thread will enter next
	int favouredthread = 1;

	// flags to indicate if each thread is in
	// queue to enter its critical section
	boolean thread1wantstoenter = false;
	boolean thread2wantstoenter = false;

	startThreads();
}

Thread1(){
	do {
		thread1wantstoenter = true;

		// entry section
		// wait until thread2 wants to enter
		// its critical section
		while (thread2wantstoenter == true) {
			// if 2nd thread is more favored
			if (favouredthread == 2) {
				// gives access to other thread
				thread1wantstoenter = false;

				// wait until this thread is favored
				while (favouredthread == 2) ;

				thread1wantstoenter = true;
			}
		}

		// critical section

		// favor the 2nd thread
		favouredthread = 2;

		// exit section
		// indicate thread1 has completed
		// its critical section
		thread1wantstoenter = false;
	} while (completed == false)
}

Thread2(){
	do {
		thread2wantstoenter = true;

		// entry section
		// wait until thread1 wants to enter
		// its critical section
		while (thread1wantstoenter == true) {
			// if 1st thread is more favored
			if (favaouredthread == 1) {
				// gives access to other thread
				thread2wantstoenter = false;

				// wait until this thread is favored
				while (favouredthread == 1)	;

				thread2wantstoenter = true;
			}
		}

		// critical section

		// favour the 1st thread
		favouredthread = 1;

		// exit section
		// indicate thread2 has completed
		// its critical section
		thread2wantstoenter = false;
	} while (completed == false)
}
```

flag 表示进程状态；turn 表示哪个进程有权进入临界区，实现谦让的目的。进入临界区时，设置自己 flag 为 true，检查另一个 flag，若为 false 则直接进入；若为 true，则检查 turn 是否为自己，若是则另一进程同时延期执行并设置 flag 为 false 让步，本进程循环检查另一个 flag 直到其为 false；执行完临界区后，设置 flag 为 false，并置 turn 为另一者。
### Perterson 算法
```
boolean flag[2];
int turn;
void P0(){
	while(1){
		flag[0]=true;
		turn=1;
		while(flag[1]&&turn==1) /*busy waiting*/ ;
		// critical section

		flag[0]=false;
		// rest code
	}
}

void P1(){
	while(1){
		flag[1]=true;
		turn=0;
		while(flag[1]&&turn==1) /*busy waiting*/ ;
		// critical section

		flag[1]=false;
		//rest code
	}
}
void main(){
	flag[0]=false;
	flag[1]=false;
	parbegin(P0,P1);
}
```

进程先声明自己想要进入临界区 (flag->true)，但都谦让对方 (turn=P_other)，因此在忙等待中必有一者等待，一者进入临界区，进入临界区的进程执行完后将自身 flag 置为 false，另一进程解锁，进入临界区。

## 互斥：硬件支持
### 中断禁用

### 专用机器指令


## 信号量
### 原语

### 互斥

### 生产者消费者问题

### 实现信号量

## 管程
### 使用信号的管程

### 使用通知和广播的管程 (Hoare 管程)

### Hansen 管程


## 消息传递
### 同步

### 寻址

### 消息格式

### 排队规则

### 互斥

## 读写者问题
### 读者优先策略
### 写者优先策略

### 消息传递解决读写者问题

## 死锁
### 原理
#### 联合进程图

#### 可重用资源

#### 可消耗资源

#### 资源分配图

#### 死锁四条件

### 死锁预防

### 死锁避免

#### 进程启动拒绝

#### 资源分配拒绝

### 死锁检测

#### 死锁检测算法

#### 死锁解除

## 综合的死锁策略

## 哲学家就餐问题
### 基于信号量的方案

### 基于管程的方案