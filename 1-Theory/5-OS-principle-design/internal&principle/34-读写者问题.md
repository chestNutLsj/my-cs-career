## 读者优先
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <semaphore>

using namespace std;

int readcount = 0;
sem_t x, wsem;

void reader() {
    while (true) {
        sem_wait(&x);  // Apply for read semaphore
        readcount++;
        if (readcount == 1)
            sem_wait(&wsem);  // If the first reader, acquire writer semaphore
        sem_post(&x);  // Release read semaphore

        // Reading is performed
        cout << "Reader is reading..." << endl;
        this_thread::sleep_for(chrono::milliseconds(100));  // Simulate reading

        sem_wait(&x);  // Apply for read semaphore
        readcount--;
        if (readcount == 0)
            sem_post(&wsem);  // If the last reader, release writer semaphore
        sem_post(&x);  // Release read semaphore
    }
}

void writer() {
    while (true) {
        sem_wait(&wsem);  // Apply for writer semaphore

        // Writing is performed
        cout << "Writer is writing..." << endl;
        this_thread::sleep_for(chrono::milliseconds(200));  // Simulate writing

        sem_post(&wsem);  // Release writer semaphore
    }
}

int main() {
    sem_init(&x, 0, 1);  // Initialize read semaphore
    sem_init(&wsem, 0, 1);  // Initialize writer semaphore

    thread readerThread(reader);
    thread writerThread(writer);

    readerThread.join();
    writerThread.join();

    sem_destroy(&x);  // Destroy read semaphore
    sem_destroy(&wsem);  // Destroy writer semaphore

    return 0;
}

```

## 写者优先
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <semaphore>

using namespace std;

int readcount = 0, writecount = 0;
sem_t x, y, z, wsem, rsem;

void reader() {
    while (true) {
        sem_wait(&z);
        sem_wait(&rsem);
        sem_wait(&x);
        readcount++;
        if (readcount == 1)
            sem_wait(&wsem);
        sem_post(&x);
        sem_post(&rsem);
        sem_post(&z);

        // Reading is performed
        cout << "Reader is reading..." << endl;
        this_thread::sleep_for(chrono::milliseconds(100));  // Simulate reading

        sem_wait(&x);
        readcount--;
        if (readcount == 0)
            sem_post(&wsem);
        sem_post(&x);
    }
}

void writer() {
    while (true) {
        sem_wait(&y);
        writecount++;
        if (writecount == 1)
            sem_wait(&rsem);
        sem_post(&y);

        sem_wait(&wsem);
        
        // Writing is performed
        cout << "Writer is writing..." << endl;
        this_thread::sleep_for(chrono::milliseconds(200));  // Simulate writing

        sem_post(&wsem);

        sem_wait(&y);
        writecount--;
        if (writecount == 0)
            sem_post(&rsem);
        sem_post(&y);
    }
}

int main() {
    sem_init(&x, 0, 1);
    sem_init(&y, 0, 1);
    sem_init(&z, 0, 1);
    sem_init(&wsem, 0, 1);
    sem_init(&rsem, 0, 1);

    thread readerThread(reader);
    thread writerThread(writer);

    readerThread.join();
    writerThread.join();

    sem_destroy(&x);
    sem_destroy(&y);
    sem_destroy(&z);
    sem_destroy(&wsem);
    sem_destroy(&rsem);

    return 0;
}

```

### 消息传递（写者优先）
```cpp
#include <iostream>
#include <thread>
#include <queue>
#include <condition_variable>

using namespace std;

// Message types
enum MessageType {
    ReadRequest,
    WriteRequest,
    Finished
};

struct Message {
    MessageType type;
    int id;
};

int count = 0;
int writer_id = -1;

queue<Message> readRequests;
queue<Message> writeRequests;
queue<Message> finishedMessages;
mutex mtx;
condition_variable cv;

void reader(int i) {
    while (true) {
        Message rmsg;
        rmsg.type = ReadRequest;
        rmsg.id = i;
        {
            unique_lock<mutex> lock(mtx);
            readRequests.push(rmsg);
            cv.notify_all();  // Notify the controller
            cv.wait(lock, [&]() { return rmsg.id == -1; });  // Wait for finished message
        }
        
        // Reading is performed
        cout << "Reader " << i << " is reading..." << endl;
        this_thread::sleep_for(chrono::milliseconds(100));  // Simulate reading
        
        rmsg.type = Finished;
        rmsg.id = i;
        {
            unique_lock<mutex> lock(mtx);
            finishedMessages.push(rmsg);
            cv.notify_all();  // Notify the controller
        }
    }
}

void writer(int j) {
    while (true) {
        Message rmsg;
        rmsg.type = WriteRequest;
        rmsg.id = j;
        {
            unique_lock<mutex> lock(mtx);
            writeRequests.push(rmsg);
            cv.notify_all();  // Notify the controller
            cv.wait(lock, [&]() { return rmsg.id == -1; });  // Wait for finished message
        }
        
        // Writing is performed
        cout << "Writer " << j << " is writing..." << endl;
        this_thread::sleep_for(chrono::milliseconds(200));  // Simulate writing
        
        rmsg.type = Finished;
        rmsg.id = j;
        {
            unique_lock<mutex> lock(mtx);
            finishedMessages.push(rmsg);
            cv.notify_all();  // Notify the controller
        }
    }
}

void controller() {
    while (true) {
        unique_lock<mutex> lock(mtx);
        
        if (count > 0) {
            if (!finishedMessages.empty()) {
                Message msg = finishedMessages.front();
                finishedMessages.pop();
                count++;
                lock.unlock();
                cv.notify_all();  // Notify waiting threads
            } else if (!writeRequests.empty()) {
                Message msg = writeRequests.front();
                writeRequests.pop();
                writer_id = msg.id;
                count = count - 100;
            } else if (!readRequests.empty()) {
                Message msg = readRequests.front();
                readRequests.pop();
                count--;
                lock.unlock();
                cv.notify_all();  // Notify waiting threads
                // Simulate sending "OK" back to the reader
                cout << "Sending OK to reader " << msg.id << endl;
                this_thread::sleep_for(chrono::milliseconds(10));
                lock.lock();
            }
        }
        
        if (count == 0) {
            if (writer_id != -1) {
                cout << "Sending OK to writer " << writer_id << endl;
                writer_id = -1;
            }
            if (!finishedMessages.empty()) {
                Message msg = finishedMessages.front();
                finishedMessages.pop();
                count++;
                lock.unlock();
                cv.notify_all();  // Notify waiting threads
            } else {
                lock.unlock();
            }
        }
        
        while (count < 0) {
            Message msg = finishedMessages.front();
            finishedMessages.pop();
            count++;
            lock.unlock();
            cv.notify_all();  // Notify waiting threads
            lock.lock();
        }

        cv.wait(lock);  // Wait for signals
    }
}

int main() {
    thread controllerThread(controller);
    thread readerThreads[5];
    thread writerThreads[3];

    for (int i = 0; i < 5; ++i) {
        readerThreads[i] = thread(reader, i);
    }

    for (int j = 0; j < 3; ++j) {
        writerThreads[j] = thread(writer, j);
    }

    for (int i = 0; i < 5; ++i) {
        readerThreads[i].join();
    }

    for (int j = 0; j < 3; ++j) {
        writerThreads[j].join();
    }

    controllerThread.join();

    return 0;
}

```