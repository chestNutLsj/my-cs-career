---
---
参考论文：[[CARR01.pdf]]
## 竞争条件和信号量
如何准确确定程序中出现的竞争条件有一定难度：
### 问题陈述
假设两个进程 A 和 B，各自都由若干并发执行的线程组成，每个线程都包含一个无限循环，每个循环中有一个要与另一进程中某个线程交换的消息。每个消息由放在共享全局缓冲区的一个整数构成。

由此产生两个需求：
1. 进程 A 中线程 A1 的消息对进程 B 中线程 B1 可用后，A1 只有接收到 B1 的消息后才能进行。类似的，B1 消息对 A1 可用后，也要接收到 A1 的消息才能进行下去；
2. 一旦线程 A1 的消息可用，就必须保证 B 中线程重新获得消息之前，A 中其它线程不能覆盖全局缓冲区。

### err_algo 1：简单握手
```
semaphore a=0,b=0;
int buf_a,buf_b;

thread_A(){
	int var_a;
	...;
	while(1){
		...
		var_a=...;
		semSignal(b);
		semWait(a);
		buf_a=var_a;
		var_a=buf_b;
		...;
	}
}

thread_B(){
	int var_b;
	...
	while(1){
		...
		var_b=...;
		semSignal(a);
		semWait(b);
		buf_b=var_b;
		var_b=buf_a;
		...;
	}
}
```
一种简单的握手协议，当 A 的线程 A1 准备好交换信息时，向 B 的线程发送信号，等待 B 中线程 B1 准备好；一旦 A 执行 semWait(a)得到信号从 B1 返回，就假定 B1 做好了交换准备。不论哪个线程先准备好，交换都会发生。

但是该算法会导致竞争条件，思考如下事件序列：

| Thread A1     | Thread B1     |
| ------------- | ------------- |
| semSignal (b) |               |
| SemWait (a)   |               |
|               | semSignal (a) |
|               | semWait (b)   |
| buf_a=var_a   |               |
| var_a=buf_b   |               |
|               | buf_b=var_b   |
A1 到达 `semWait(a)` 时阻塞，B1 到达 `semWait(b)` 未阻塞，但是在 B1 更新 `buf_b` 之前就会被交换出去，然而此时 A1 想要读取的 `buf_b` 还没有被 B1 更新，这是一个竞争条件。

若 A 和 B 中的两个线程都活跃，那么:

| Thread A1     | Thread A2     | Thread B1     | Thread B2     |
| ------------- | ------------- | ------------- | ------------- |
| semSignal (b) |               |               |               |
| semWait (a)   |               |               |               |
|               |               | semSignal (a) |               |
|               |               | semWait (b)   |               |
|               | semSignal (b) |               |               |
|               | semWait (a)   |               |               |
|               |               | buf_b=var_b1  |               |
|               |               |               | semSignal (a) |
| buf_a=val_a1  |               |               |               |
|               | buf_a=var_a2  |               |               |
A1 和 B1 尝试交换消息并完成合适的信号量发信号指令。但是随着两个 `semWait` 的执行，A2 和 B2 获得信号分别开始执行 `semSignal(b),semWait(a)` 和 `semSignal(a)`。这时 A1 或 A2 都可能更新 buf_a，这就产生了竞争条件。

经验：多线程共享一个变量时，除非使用合适的互斥保护，否则可能发生竞争条件。

### err_algo 2：信号量 mutex 保护临界区
```
semaphore a=0,b=0; mutex=1;
int buf_a,buf_b;

thread_A(){
	int var_a;
	...;
	while(1){
		...
		var_a=...;
		semSignal(b);
		semWait(a);
			semWait(mutex);
				buf_a=var_a;
			semSignal(mutex);
		semSignal(b);
		semWait(a);
			semWait(mutex);
				var_a=buf_b;
			semSignal(mutex);
		...;
	}
}

thread_B(){
	int var_b;
	...
	while(1){
		...
		var_b=...;
		semSignal(a);
		semWait(b);
			semWait(mutex);
				buf_b=var_b;
			semSignal(mutex);
		semSignal(a);
		semWait(b);
			semWait(mutex);
				var_b=buf_a;
			semSignal(mutex);
		...;
	}
}
```

信号量 mutex 保护 buf_a 和 buf_b，试图保证更新以前的数据。但这种保护并不充分，一旦两个线程完成了第一次握手，信号量 a 和 b 的值都是 1，则会发生三种以下情形：
1. A1 和 B1 完成第一次握手后，继续进行第二个阶段的消息交换；
2. 

### err_algo 3

### err_algo 4

### proper_algo

## Barber question
