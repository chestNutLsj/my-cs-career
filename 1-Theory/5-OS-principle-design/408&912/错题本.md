## 文件系统
### read syscall
1. 若一个用户进程通过 read 系统调用读取一个磁盘文件中的数据，则下列说法正误判断：
- 若文件的数据不在内存，则该进程会进入睡眠等待状态；(✅)
- 请求 read 系统调用会导致 CPU 从用户态切换到核心态；(✅)
- read 系统调用的参数应该包括文件名称；(❌)

>[!note] read 系统调用的参数为什么不包括文件名？
>在用户进程通过 `read` 系统调用读取一个磁盘文件的数据时，`read` 系统调用并不直接接受文件名作为参数。实际上，`read` 系统调用是用于从文件描述符（file descriptor）对应的文件中读取数据的。文件描述符是一个非负整数，它在打开文件时由内核分配。
>
>通常的文件读取过程是这样的：
>1. 打开文件：用户进程需要使用 `open` 系统调用来打开文件，此时会得到一个文件描述符。
>2. 读取文件：一旦文件被打开，用户进程可以使用 `read` 系统调用来从文件描述符对应的文件中读取数据。
>
>所以，`read` 系统调用的参数是文件描述符、数据缓冲区和要读取的字节数。函数原型通常如下：
>```c
>ssize_t read (int fd, void *buf, size_t count);
>```
>
>- `fd` 是文件描述符，通过 `open` 系统调用得到。
>- `buf` 是一个指向数据缓冲区的指针，用于存储从文件中读取的数据。
>- `count` 表示要读取的最大字节数。
>
>在调用 `read` 之前，用户进程必须通过 `open` 系统调用打开文件，并且如果读取成功，`read` 系统调用会将数据从文件复制到提供的缓冲区（`buf`）中。
>
>因此，用户进程需要先打开文件获得文件描述符，然后再使用该文件描述符来调用 `read` 系统调用来读取文件的数据，而不是将文件名作为 `read` 系统调用的参数。

