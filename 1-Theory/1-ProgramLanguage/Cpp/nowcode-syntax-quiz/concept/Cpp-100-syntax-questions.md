
## 关于 C++ 的基本概念
### 语言类型
1. C++和Java 都是静态类型的面向对象的编程语言。（✅）
>[! note] 什么是静态、动态类型语言？
>- 动态类型语言是指在运行期间才去做数据类型检查的语言，也就是说，在用动态类型的语言编程时，永远也不用给任何变量指定数据类型，该语言会在你第一次赋值给变量时，在内部将数据类型记录下来。典型语言有：Python、JavaScript
>
>- 静态类型语言与动态类型语言刚好相反，它的数据类型是在编译其间检查的，也就是说在写程序时要声明所有变量的数据类型，C/C++是静态类型语言的典型代表，其他的静态类型语言还有 C#、JAVA 等。

## 变量
### 标识符
1. 标识符命名规则
>[! done] 作为变量名的标识符命名规则
>1. 第一个字符必须是字母或下划线，除此外可以由字符、数字、下划线组成；
>2. 不能是关键词；

### 指针
#### 指针 `this` 的使用
1. 判断下列代码中，四个函数哪个具有隐含 `this` 指针（）
```cpp
int f1();
class T{
	public:    static int f2();
	private:   friend int f3();
	protected: int f4();
};
```

答案是 `f4()`。[[41-Class(II)#The keyword `this`|this pointer]]

>[! note] `this` 指针什么时候会隐含？
>只有类的非静态成员函数才有 `this` 指针，友元、静态函数以及全局函数都没有 this 指针。
>- 静态成员函数属于整个类所有，没有 this 指针；
>- 友元函数不是这个类的成员，没有指针；

#### 常量指针与常指针

>[! note] 口诀——“左常值，右常向”
>1. `const char* p;` - 这是一个指向常量字符的指针。在这种情况下，`p` 是一个指针，指向的字符是不可修改的，也就是说，不能通过 `p` 来修改所指向的字符。但是指针 `p` 本身的值可以修改，也就是可以让 `p` 指向不同的常量字符。
>2. `char* const p;` - 这是一个常量指针。在这种情况下，`p` 是一个指针，指向的字符是可修改的，可以通过 `p` 来修改所指向的字符。但是指针 `p` 本身的值是不可修改的，一旦初始化后，不能让 `p` 指向其他地方。

#### 指针空间大小
1. 判断：在 64 位机上，`char *p= "abcdefghijk";` sizeof (p)大小为 12. (❌)

>[! note] 指针大小与指针所指空间大小无关
>这里将一个字符串字面量赋值给指针 p。在64位机器上，指针的大小仍然是 8 字节（64 位），不管它指向的是什么类型的数据。字符串字面量是以 null 终止的字符数组，该数组的大小是 12（包括终止的 null 字符）。所以 `sizeof(p)` 返回的是指针的大小，而不是所指向的数据大小，因此是 8。

### 位域 (`bit field`)
1. 在 32 位机上，有一个结构体如下，请计算 sizeof (A)的结果。
```
Struct A{ 
	Char t : 4;
	Char k : 4; 
	Unsigned short i : 8; 
	Unsigned long m;
};
```

>[! note]
>在 32 位机上，结构体 A 的 sizeof (A)结果将是 8 字节。
>在结构体 A 中，变量后的 `:` 用来定义位字段（Bit Field），它允许将变量的特定位数用于表示特定的值。
>
>逐步解释计算过程：
>1. `char t : 4;`：这表示变量 t 将占用 4 个位。在 32 位机上，char 类型默认占用 1 字节（8 位），但由于我们指定了 `: 4`，因此 t 将只占用4位。
>2. `char k : 4;`：同样，变量 k 也占用 4个位。
>3. `unsigned short i : 8;`：这表示变量 i 将占用 8 个位，即 1字节。
>4. `unsigned long m;`：这是一个无修饰符的无符号长整型，它在 32 位机上占用 4 字节（32 位）。
> 
>综上所述，将结构体 A 的成员逐个分析并计算其占用空间：
>- 变量 t 占用 4 位，即半个字节；
>- 变量 k 占用 4 位，即半个字节；
>- 变量 i 占用 1字节；
>- 变量 m 占用 4字节。
>
>将这些成员的占用空间直接相加：0.5 字节 + 0.5 字节 + 1 字节 + 4 字节 = 6 字节。
>然而，在 32 位机上，结构体的大小会按照最大基本类型成员的大小进行对齐。因此，在这种情况下，结构体 A 中 t、k、i 总共 2 字节，会被向上取整到 4 字节，以保持与 m 的对齐。
>
>因此，sizeof(A)的结果为8字节。

>[! note] 补充：内存对齐的三个规则
>1. 对于结构体的各个成员，第一个成员的偏移量是 0，排列在后面的成员其当前偏移量必须是当前成员类型的整数倍
>2. 结构体内所有数据成员各自内存对齐后，结构体本身还要进行一次内存对齐，保证整个结构体占用内存大小是结构体内最大数据成员的最小整数倍
>3. 如程序中有#pragma pack(n)预编译指令，则所有成员对齐以n字节为准(即偏移量是n的整数倍)，不再考虑当前类型以及最大结构体内类型

2. 趁热打铁，另一个关于对齐的问题：判断下面语句中 sz 变量的值
```cpp
struct _THUNDER {
	int iVersion;
	char cTag;
	char cAdv;
	int iUser;
	char cEnd;
} Nowcoder;
int sz = sizeof(Nowcoder);
```

答案是：16

![[struct-memory-occupy.png]]

### 字符串
1. 为了将变量 `char buf[]="SH_600570_"` 修改为 `"SH__600570"`，可以使用如下哪些函数语句？
A. `strcpy(buf+3,buf+2);`    ✅
B. `strncpy(buf+3,buf+2,7);` ✅
C. `memcpy(buf+3,buf+2,7);`  ❌

>[! note] 字符串拷贝函数及内存拷贝函数浅析
>- strcpy 是拷贝字符串，在拷贝结束的时候会为字符串添加一个'\0';  
>- strncpy 是拷贝字符，不会再字符串末尾添加'\0'，只按给出的字符个数来拷贝，拷贝完 n 个字符就结束。但是，如果 n 比 src 的长度大，那么空余的部分会被'\0'填充，以保证拷贝 n 个字符。  
>- strcpy 和 strncpy 都只能接受 char*，也就是字符类型的数据，如果是结构体，没办法操作。而且，这两个函数如果遇到 dest 和 src 的内存重叠会导致程序崩溃。  
>- memcpy 是内存拷贝，可以接受数组，整型，结构体，类等任何类型，它实现的是内存的拷贝。  
>- memmove 可以避免内存区域重叠问题。如果出现重叠，则采用反向复制，从后向前复制字符串，如果不重叠，则正向复制，从前向后复制。

### volatile 关键字
1. 判断下列关于 volatile 关键字的说法的正误。

A. 当读取一个非 volatile 修饰的变量时，为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中；以后再取变量值时，就直接从寄存器中取值 ❌
B. 优化器在用到 volatile 变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份 ✅
C. volatile 适用于多线程应用中被几个任务共享的变量 ✅
D. 一个参数不可以既是 const 又是 volatile ❌

>[! note] 关于 volatile
> - volatile 用来声明那些可能在你的程序本身不知道的情况下会发生改变的变量。 
> - 一个定义为 volatile 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。
> - 对于一般变量：为提高存取速度，编译器优化时有时会先把变量读取到一个寄存器中。以后再取变量值时，就直接从寄存器中取值。
> - 一个参数既可以是const也可以是volatile：一个例子是只读的状态寄存器。它是volatile因为它可能被意想不到地改变。它是const因为程序不应该试图去修改它。（简单点就是该程序代码不能试图去修改它，但不排除硬件方面修改了它，我们每次都得重新读取它的值。） 

## 类型转换
### 动态类型转换
[[50-Type-conversions#dynamic_cast|Dynamic_Cast]]

1. 判断下列代码的输出：
```cpp
#include <iostream>
using namespace std;
class Base {
public:
    void virtual Func() {
        cout << "Base" << endl;
    }
};

class Derived : public Base {
public:
    void virtual Func() {
        cout << "Derived " << endl;
    }
};

int main() {
    Base *pBase = new Base();
    pBase->Func();
    Derived *pDerived = (Derived *) pBase;
    pDerived->Func();
    delete pBase;

    pDerived = new Derived();
    pBase = pDerived;
    pBase->Func();

    delete pDerived;
    return 0;
}
```

output: `Base -> Base -> Derived`

由于 func 是一个虚函数，所以将指针赋值给基类或者派生类对象不会对虚函数调用造成影响。pBase 是一个 Base 对象，前两次 func 会调用 Base 对应的 func 函数，输出两次 Base。而 pDerived 是一个 Derived 对象，因此是输出 Derived。B 选项正确。

>[! warning] 强制类型转换与指针
> 强制类型转换时会将 Base 类型的数据所在的内存按照 Derived 类型格式解析和转换。pDerived 解析得到的是 pBase 的虚函数表，相当于 pDerived 的 vtbl 虚函数表指针指向了 pBase 的虚函数表，故得到 Base;
> 
> 但这种强制转换比较危险，当访问某虚函数时子类存在而父类不存在时，就可能导致运行时出现访问错误，程序崩溃，而此时编译是正常的，因为指针的虚函数表是动态链接的。

## 运算符
### sizeof
1. sizeof 与 strlen 的区别？
>[! done] sizeof 是函数吗？
>sizeof 是操作符，在编译阶段就获得结果，strlen 是函数调用，在运行阶段才获得值。

### 运算符重载
1. 调用重载后运算符的方法
>[! done] 调用重载运算符的两种方法
>1. `c = a + b; //implicitly using operator` 这样是隐式地直接使用重载后的运算符
>2. `c = a.operatpr+(b); //explicitly using its function name` 这样是运用运算符函数的调用格式

## 函数
### 返回值

1. 通过 return 语句，函数可以返回一个或多个返回值。（❌）

>[! error] 返回值的个数
>在 C++11 及其后续标准中，函数本身仍然只能返回一个值。但是，可以使用 `std::tuple` 或 `std::pair` 等数据结构来返回多个值，从而实现在函数返回时返回多个参数的效果。

这是一个使用 `std::tuple` 返回多个参数的例子：

```cpp
#include <iostream>
#include <tuple>

std::tuple<int, double> myFunction() {
    int value1 = 42;
    double value2 = 3.14;
    return std::make_tuple(value1, value2);
}

int main() {
    auto result = myFunction();
    int a = std::get<0>(result);
    double b = std::get<1>(result);
    std::cout << "a: " << a << ", b: " << b << std::endl; // 输出：a: 42, b: 3.14
    return 0;
}
```

上述代码使用 `std::tuple` 来将多个值打包在一起并返回，然后在 `main` 函数中使用 `std::get` 来获取每个返回值的具体值。

除了 `std::tuple`，你还可以使用 `std::pair` 或自定义的结构体或类或指针或引用等数据结构来返回多个参数。这些方法都能实现在函数返回时返回多个值的目的。在选择返回多个值的方法时，需要考虑代码的可读性、维护性以及对不同类型返回值的支持。

### 内联函数
1. 内联函数在编译时是否进行参数类型检查？
答：做类型检查。内联函数在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体代替。

[[21-Functions#Inline functions|Inline function]]

>[!note] 内联函数与宏定义的联系与区别
>联系：
>1. 替换代码：宏定义和内联函数都可以将代码直接嵌入到调用处，而不是像普通函数一样进行函数调用。
>2. 编译期间展开：宏定义和内联函数都在编译期间进行展开，避免了函数调用的开销。
>3. 减少函数调用开销：宏定义和内联函数都可以减少函数调用带来的额外开销，如函数调用的栈帧、参数传递等。
>
>区别：
>1. 语法和类型安全：宏定义是基于文本替换，没有语法结构和类型检查，可以操作任意文本。而内联函数在语法上与普通函数相似，可以进行类型检查，并且遵循函数的作用域规则。
>2. 嵌套能力：宏定义可以嵌套使用，而内联函数不具备嵌套能力。
>3. 内联函数可以访问类的成员变量，而宏定义不可以；
>4. 在类中声明同时定义的成员函数，自动转化为内联函数；
>5. 调试和可读性：宏定义展开后的代码难以调试和阅读，而内联函数可以在调试器中进行单步调试，并且提供了更好的可读性。

>[! note] 推荐使用内联函数
>原因如下：
>1. 类型安全：内联函数在语法上与普通函数相似，可以进行类型检查，避免了宏定义可能带来的类型错误。
>2. 调试和可读性：内联函数在调试器中可以进行单步调试，展开后的代码易于阅读和理解。
>3. 作用域和命名空间：内联函数遵循函数的作用域规则和命名空间，可以进行更灵活的代码组织和封装。
>
>然而，内联函数并不是适用于所有情况的最佳选择。内联函数的展开会导致代码膨胀，对于函数体较大或频繁调用的函数，内联可能会导致可执行文件的大小增加和缓存命中率下降，反而降低了性能。因此，对于复杂的函数或频繁调用的函数，需要根据实际情况进行权衡，可能需要使用普通函数或其他优化手段。

>[! note] 内联函数与宏的开销对比
>内联函数的开销比宏略大，耗费在类型检查和其它编译时检查之上，但并不显著；

## 继承
1. 派生类对象不会建立基类的私有数据成员，所以不能访问基类的私有数据成员（❌）

>[!error] 派生类究竟继承了基类的私有成员了吗？
>一开始我以为这个题是个因果逻辑的错误，但是转念一想可以动手实例化两个派生了和基类，分别比较对象的内存占用，这样就能确定是否真正继承了。因此可以编写如下代码，实际验证内存占用：

```cpp 
#include <iostream>

class Base {
private:
    int privateVar;
protected:
    int protectedVar;
public:
    int publicVar;
};

class Derived : public Base {
public:
    int derivedVar;
};

int main() {
    Base baseObj;
    Derived derivedObj;

    std::cout << "Size of Base: " << sizeof(baseObj) << " bytes" << std::endl;
    std::cout << "Size of Derived: " << sizeof(derivedObj) << " bytes" << std::endl;

    return 0;
}
```

运行这段代码，将会输出两个类对象的内存占用大小。如果派生类继承了基类的私有成员，那么派生类的对象的内存大小应该比基类的对象的内存大小要大，因为派生类对象包含了基类的成员。

而运行结果是：
```
Size of Base: 12 bytes
Size of Derived: 16 bytes
```

让我们分析这个结果：

1. `Size of Base: 12 bytes`: 基类 `Base` 包含一个私有成员 `privateVar` 和一个保护成员 `protectedVar`，以及一个公有成员 `publicVar`。由于大多数系统的 `int` 类型占用 4 个字节，这里的大小为 12 字节。
    
2. `Size of Derived: 16 bytes`: 派生类 `Derived` 继承了基类 `Base` 的成员，包括私有成员 `privateVar` 、保护成员 `protectedVar` 和公有成员 `publicVar`，并且还有自己的成员 ` derivedVar `。由于继承了基类的私有成员，导致派生类的对象大小增加。因此，大小为 12 字节（基类的大小） + 4 字节（派生类新增的成员）= 16 字节。
    

这证实了派生类确实继承了基类的私有成员，只是不能直接访问这些私有成员而已。当您在派生类中定义了成员函数或使用基类的公有/保护成员函数来访问基类的私有成员时，您可以间接地操作这些私有成员。

## 文件 IO
1. 使文件指针重新定位到文件读写的首地址的函数是：

`rewind()`：用于将文件内部的位置指针重新指向一个流(数据流/文件)的开头；rewind 单词的本义是：倒带
>[! note] 其它相似函数的功能
>- ftell () 函数用于得到文件位置指针当前位置相对于文件首的偏移字节数；
>- fseek()函数用于设置文件指针的位置；
>- ferror ()函数可以用于检查调用输入输出函数时出现的错误。

实际上 `fseek()` 也可以设置到文件开头，而且对错误处理的扩展性更好，但是使用比较复杂：[[60-IO-files#^9c9960]]

```cpp
#include <iostream>
#include <fstream>

int main() {
    std::fstream file("example.txt", std::ios::in); // 打开文件，以只读方式

    if (file.is_open()) {
        file.seekg(0, std::ios::beg); // 将文件指针移动到文件开头
        // 在这里进行读取操作...
        file.close(); // 关闭文件
    } else {
        std::cout << "Failed to open the file." << std::endl;
    }

    return 0;
}
```

## 内存操作

### `memset()` 函数

1. 判断以下代码的输出：
```cpp
#include <iostream>
#include <cstring> 
using namespace std;
 
class Parent {
public:
    virtual void output();
};
 
void Parent::output() {
    printf("Parent!");
}
 
class Son : public Parent {
public:
    virtual void output();
};
 
void Son::output() {
    printf("Son!");
}
 
int main() {
 
    Son s;
    memset(&s, 0, sizeof(s));
    Parent& p = s;
    p.output();
 
    return 0;
}
```
A. Parent!
B. Son!
C. 编译出错
D. 没有输出结果，程序运行出错

实际结果是 D。现在来分析一下 `memset()` 函数的使用方法：

>[! note] `memset()` 介绍
> `memset()` 是 C/C++ 中的一个库函数，用于将一段内存块设置为指定的值。它的函数原型如下：
> ```cpp
> void *memset (void *ptr, int value, size_t num);
> ```
> 
> - `ptr`: 指向要设置的内存块的指针。
> - `value`: 要设置的值，它以整数形式传递，但会被强制转换为 `unsigned char` 类型来设置到内存块中。
> - `num`: 要设置的字节数，即要设置的内存块的大小。
> 
> `memset()` 函数将 `ptr` 指向的内存块的前 `num` 个字节都设置为 `value` 的值。该函数通常用于将一块内存清零（设置为 0）或设置为其他特定的值。

以下是 `memset()` 的简单使用示例：

```cpp
#include <cstring>
#include <iostream>

int main() {
    int arr[5];
    std::memset(arr, 0, sizeof(arr)); // 将整个数组设置为0

    char str[20];
    std::memset(str, 'A', 10); // 将前10个字符设置为'A'

    // 输出数组和字符串的内容
    for (int i = 0; i < 5; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
    std::cout << str << std::endl;

    return 0;
}
```

来自另一位大佬的详细介绍：

- memset 是以字节为单位，初始化内存块。当初始化一个字节单位的数组时，可以用 memset 把每个数组单元初始化成任何你想要的值，比如，
```
char data[10];
memset(data, 1, sizeof(data));    // right
memset(data, 0, sizeof(data));    // right
```
而在初始化其他基础类型时，则需要注意，比如,
```
int data[10];
memset(data, 0, sizeof(data));    // right
memset(data, -1, sizeof(data));    // right
memset(data, 1, sizeof(data));    // wrong, data[x] would be 0x0101 instead of 1
```

![[memset初始化的异常结果分析#`value` 参数设置为 1 错误的原因]]

- 当结构体类型中包含指针时，在使用 memset 初始化时需要小心。比如如下代码中，
```
struct Parameters {
          int x;
          int* p_x;
};
Parameters par;
par.p_x = new int[10];
memset(&par, 0, sizeof(par));
```
当memset初始化时，并不会初始化p_x指向的int数组单元的值，而会把已经分配过内存的p_x指针本身设置为0，造成内存泄漏。同理，对std::vector等数据类型，显而易见也是不应该使用memset来初始化的。

- 当结构体或类的本身或其基类中存在虚函数时，也需要谨慎使用 memset。这个问题就是在开头题目中发现的问题，如下代码中，
```
class BaseParameters
{
public:
    virtual void reset() {}
};

class MyParameters : public BaseParameters
{
public: 
    int data[3];
    int buf[3];
};

MyParameters my_pars;
memset(&my_pars, 0, sizeof(my_pars));
BaseParameters* pars = &my_pars;

//......

MyParameters* my = dynamic_cast<MyParameters*>(pars);
```
程序运行到 dynamic_cast 时发生异常。原因其实也很容易发现，我们的目的是为了初始化数据结构 MyParameters 里的 data 和 buf，正常来说需要初始化的内存空间是 sizeof(int) * 3 * 2 = 24字节，但是使用 memset 直接初始化 MyParameters 类型的数据结构时，sizeof(my_pars)却是28字节，因为为了实现多态机制，C++对有虚函数的对象会包含一个指向虚函数表(V-Table)的指针，当使用 memset 时，会把该虚函数表的指针也初始化为0，而 dynamic_cast 也使用 RTTI 技术，运行时会使用到 V-Table，**可此时由于与 V-Table 的链接已经被破坏，导致程序发生异常。**

### new 与 malloc
1. 关于 new 与 malloc 的几个说法，判断正误
- 都是用来申请内存的✅
- 都是函数❌
- 都会调用构造函数❌

>[! note] new 与 malloc 的异同
>同：都可以进行内存申请的操作；
>异：
>1. 语法：malloc 是 C 语言中的库函数，需要包含头文件 `<cstdlib>` 并使用 `malloc` 函数来分配内存。而 new 是 C++中的操作符，使用关键字 `new` 进行内存分配。
>2. 类型安全：new 在内存分配的同时会调用构造函数来初始化对象，确保类型安全。而 malloc 只是分配内存，不会自动调用构造函数，需要手动初始化对象。
>3. 返回值：malloc 返回的是 `void*` 类型的指针，需要进行显式的类型转换。new 返回的是相应类型的指针，无需进行类型转换。
>4. 内存分配大小：malloc 的参数是要分配的内存大小（以字节为单位），而 new 的参数是要分配的类型。
>5. 内存分配失败：malloc 在内存分配失败时返回 `nullptr` 或 `NULL`。new 在内存分配失败时会抛出 `std::bad_alloc` 异常。
>6. 内存释放：使用 malloc 分配的内存需要使用 free 函数进行显式的释放。使用 new 分配的内存需要使用 delete 操作符进行释放，以避免内存泄漏。
>7. 底层原理： 
>	- malloc 底层原理实现：当开辟的空间小于 128 k 时，调用 `brk()` 函数，当开辟的空间大于 128 k 时，调用 ` mmap() `，malloc 采用的是内存池的管理方式，先申请大块内存作为堆区，然后将堆区分为多个内存块，当用户申请时，就调出一块合适的给用户;
>	- new 底层原理实现：1，创建一个新的对象；2，将构造函数的作用域赋值给这个新的对象；3，执行构造函数中的代码；4，返回新对象；
>
>总结起来，malloc 和 new 都可以用于动态分配内存，但 new 是 C++的操作符，更类型安全，而 malloc 是 C 语言的函数。在使用时需要注意它们的语法和内存释放方式，并根据实际需求选择适当的操作符。在 C++中，推荐使用 new 和 delete，因为它们提供更好的类型安全性和异常处理机制。


## 类与成员
### 构造函数与析构函数

1. 假设 ClassY: publicX，即类 Y 是类 X 的派生类，则说明一个 Y 类的对象时和删 Y 类对象时，调用构造函数和析构函数的次序分别为（）

>[! done] 构造函数与析构函数在继承中调用顺序
>构造函数：先调用基类构造函数，再调用派生类
>析构函数：先解除派生类构造函数，在解除派生类
>
>类比：相当于建房子，构造：先打基脚，在往上建，析构：从上面往下拆

### 虚函数
>[! note] 辨析虚函数、纯虚函数、非虚函数
>- 纯虚函数：只提供一个接口，具体实现方法需要派生类自己去实现
>- 虚函数：提供接口，并提供默认的实现方法，派生类也可以根据自己需求去重载
>- 非虚函数：提供接口，强制实现方法


1. 包含虚函数的类有 this 指针。（✅）
> [! done] 虚函数的 this 指针
> 包含虚函数的类可以使用 `this` 指针。在 C++ 中，每个非静态成员函数都有一个隐式的指向当前对象的指针，即 `this` 指针。`this` 指针指向调用该成员函数的对象的地址。
> 当你调用一个包含虚函数的类的成员函数时，该函数被绑定到正确的虚函数表中，并且 `this` 指针会被自动传递给该函数，指向调用函数的对象。这样，函数就能正确地操作属于该对象的成员变量和虚函数。

例如，考虑以下包含虚函数的简单类：

```cpp
#include <iostream>

class Base {
public:
    virtual void print() {
        std::cout << "Base::print() called. this = " << this << std::endl;
    }
};

int main() {
    Base obj;
    obj.print();
    return 0;
}
```

输出结果可能类似于：

```
Base::print() called. this = 0x7ffdbf7ca6df
```

在上面的例子中，创建了一个 `Base` 类的对象 `obj` 并调用了 `print()` 成员函数。在 `print()` 函数中，我们打印了 `this` 指针的值，它指向了 `obj` 对象的地址。

所以，包含虚函数的类是支持使用 `this` 指针的，并且这使得类的成员函数能够正确地与对象交互。

### 抽象类
1. 判断关于抽象类说法的正误：

A. 抽象类中可以不存在任何抽象方法  ❌
B. 抽象类可以为 final 的  ❌
C. 抽象类可以被抽象类所继承  ✅
D. 如果一个非抽象类从抽象类中派生，不一定要通过覆盖来实现继承的抽象成员  ❌

>[! note] 抽象类
>A ❌。抽象类必须至少包含一个纯虚函数（抽象方法），否则它就不是抽象类。
>B ❌。因为 final 的类不可以被继承，只能用于生成实例对象；抽象类不能用于生成实例对象，因此，抽象类不能是 final.
>C ✅。如果我们不在派生类中覆盖纯虚函数，那么派生类也会变成抽象类，所以抽象类可以被抽象类继承
>D ❌。同C

### 类的内存空间
1. 关于类占用内存空间的说法正确的是：（B、C）
A 类所占内存的大小是由成员变量（静态变量除外）决定的
B 空类的内存大小是１个字节
C 类中无论有多少个虚函数，只会多占一个虚表指针空间
D 子类的内存大小等于父类的内存大小加上子类独有成员变量的内存大小

>[! note] 影响类所占内存大小的因素
>在 C++中，类所占用的内存空间大小由以下几个因素决定：
>1. 类的成员变量：类的成员变量会占用内存空间。每个成员变量的大小取决于其类型，例如 int、char、指针等。类的内存大小将包括所有成员变量的大小之和。
>2. 对齐（Alignment）：为了提高内存访问的效率，编译器通常会对类的成员进行对齐。对齐规则可以根据编译器、编译选项和平台而有所不同。对齐可能导致填充字节的存在，以确保成员变量按照对齐要求排列。对齐的规则可以通过编译器的指令或者预处理器指令进行调整。
>3. 继承（Inheritance）：如果类继承自其他类，那么它会继承父类的成员变量。继承关系可能会导致额外的内存开销，例如虚函数表指针（在多态情况下）和基类的成员变量。
>4. 虚函数（Virtual Functions）：如果类中存在虚函数（通过 virtual 关键字声明的函数），则通常会有一个指向虚函数表的指针。虚函数表（vtable）存储了类的虚函数的地址，这会增加类的大小。
>
>需要注意的是，以上因素可能受到编译器和平台的影响，不同的编译器和不同的平台可能会产生不同的内存布局和大小。
>
>可以使用 C++中的 sizeof 运算符来获取类的大小，例如 `sizeof(MyClass)` 将返回类 MyClass 的大小（以字节为单位）。
>
>需要注意的是，类的大小不包括类的成员函数。成员函数是共享的，不会在每个类的实例中复制。它们通常在代码段中存储，并不占用类的实例的内存空间。

>[!note] 空类的内存占用
>在 C++中，空类（没有成员变量和成员函数）的大小不会是零，而是一个非零值。这是因为每个类实例在内存中都应该具有唯一的地址，以便于进行区分。
>
>根据 C++标准的规定，空类的大小至少为 1 字节。这样做是为了确保每个实例都具有唯一的地址，以满足内存对齐的要求。
>
>实际上，编译器为了满足对齐要求，有可能在空类中插入一个字节的填充。这样，空类的大小通常是 1 字节，但也可以更大，具体取决于编译器的实现。

>[! note] 虚函数的内存占用
>在 C++中，无论类中有多少个虚函数，通常只会额外占用一个指向虚函数表（vtable）的指针空间。这个指针被称为虚表指针（vptr）。
>
>虚表指针是一个指向虚函数表的指针，虚函数表是一个存储了类中虚函数地址的表格。虚表指针的大小通常是一个机器字（通常为 4 字节或 8 字节），它指向虚函数表，而不是存储实际的函数代码。虚表指针存在于每个类的实例中，用于支持动态绑定（运行时多态性）。
>
>无论类中有多少个虚函数，只会有一个虚表指针。这是因为虚函数表是由类的整个继承层次结构共享的，每个类实例中只需要一个指针来引用虚函数表。
>
>其他的非虚函数和静态函数不会占用额外的内存空间，它们是类的共享成员，不会在每个类的实例中复制。
>
>需要注意的是，虚表指针的存在会增加类的大小，并且虚函数的调用会在运行时进行查找和解析，因此会略微影响性能。但这种开销通常是可以接受的，并且为实现运行时多态性提供了重要的机制。

>[!note] 子类内存占用大小与父类内存大小的关系
>子类的内存大小通常是父类的内存大小加上子类新增的成员变量的大小。这是因为子类会继承父类的成员变量，并在其基础上添加自己的成员变量。
>
>子类继承了父类的成员变量，包括继承过来的私有成员变量。然而，在内存中，子类的实例包含了父类的成员变量的内存空间，而不是简单地引用它们。
>
>在某些情况下，编译器可能对子类的内存布局进行优化，例如通过重排成员变量的顺序来减少内存空间的浪费。这意味着子类的内存大小可能不等于父类的内存大小加上子类新增成员变量的大小。
>
>此外，如果子类重写了父类的虚函数，并且父类中的虚函数使用了虚表指针（vptr），那么子类实例中也会存在一个指向子类的虚函数表的虚表指针。这会增加子类的内存大小
>
>总结起来，子类的内存大小不仅取决于新增的成员变量的大小，还可能受到编译器的优化和虚函数表指针的影响。因此，简单地将子类的内存大小定义为父类的内存大小加上子类新增成员变量的大小是不准确的。在实际情况中，子类的内存大小可能会有所变化。

### 静态成员
1. 下列关于静态成员的描述正误性判断：
- 静态成员不属于对象，是类的共享成员 (❌)
- Cpp 11 之前，非 const 的静态数据成员要在类外定义和初始化 (✅)
- 静态成员函数不拥有 this 指针，需要通过类参数访问对象成员 (✅)
- 只有静态成员函数可以操作静态数据成员 (❌)   _当然不是，静态数据成员属于类，非静态成员函数也可以访问_

![[Cpp 11前后 静态成员的定义与初始化问题#为什么非要在类外定义和初始化？]]

![[Cpp 11前后 静态成员的定义与初始化问题#Cpp 11 修改了什么？]]



## 数据结构

### 堆、栈
1. Cpp 中关于堆栈说法的正误判断：

A. 堆的大小仅受操作系统的限制，栈的大小一般一般较小  ✅
B. 在堆上频繁的调用 new/delete 容易产生内存碎片，栈没有这个问题 ✅
C. 堆和栈都可以静态分配 ❌
D. 堆和栈都可以动态分配 ✅

>[! note] 堆栈的内存分配
>选 C，静态分配是指在编译阶段就能确定大小，由编译器进行分配，堆不可以进行静态分配，堆的申请都是在执行过程中进行的。 
>
>A，堆和栈的大小都可以设置，栈一般只有几 KB。堆的大小通常受限于计算机的可用物理内存（RAM）和操作系统的设置。
>- 当程序请求从堆中分配内存（例如，通过动态内存分配函数如 C++ 中的 `malloc` 或 `new`），操作系统会从可用的 RAM 中分配内存。如果没有足够的空闲内存，堆分配可能失败。
>- 栈是用于存储局部变量、函数调用信息和其他执行相关数据的内存区域。程序中的每个线程通常有自己的栈。栈的大小通常是固定的，并由操作系统或编译器定义，通常比堆小。由于栈用于跟踪函数调用和局部变量，其大小必须受限，以防止过多的内存消耗和栈溢出问题。当调用函数时，其局部变量和一些管理信息被分配到栈上。如果超过了栈的大小，将导致栈溢出，可能导致程序崩溃。
>
>B，堆在动态分配时，要申请连续的内存空间，释放后会产生碎片。 
>
>D，堆是使用 malloc ()、calloc ()、realloc ()等函数动态分配的，而使用 alloca ()函数可以动态分配栈的内存空间，释放的时候由编译器自己释放。

### 链表
1. 如何在下列链表中取得值为 7 的表达式？
```cpp
struct st
{
    int n;
    struct st *next;
} a[3]= {5, &a[1], 7, &a [2], 9, NULL}，*p=a;
```

A. p->n        ❌
B. (p->n)++    ❌
C. (++p)->n    ✅ (可以但不建议)
D. p->next->n  ✅

*首先，让我们解释一下数组 a 的初始化：*

```cpp
struct st a[3] = {5, &a[1], 7, &a[2], 9, NULL};

// 等价于

struct st a[3]= {{5,&a[1]},{7,&a[2]},{9,NULL}}
```

*这是一个包含 3 个元素的 struct st 类型数组 a。每个元素都是一个结构体对象，结构体 st 的定义如下：*

```c
struct st {
    int n;
    struct st *next;
};
```

*现在我们解释一下数组 a 的初始化过程：* 

1. 第一个元素：`5, &a[1]`
   - `n` 成员被初始化为 5。
   - `next` 成员被初始化为 `&a[1]`，也就是指向数组中的第二个元素。
2. 第二个元素：`7, &a[2]`
   - `n` 成员被初始化为 7。
   - `next` 成员被初始化为 `&a[2]`，也就是指向数组中的第三个元素。
3. 第三个元素：`9, NULL`
   - `n` 成员被初始化为 9。
   - `next` 成员被初始化为 NULL，表示链表的最后一个节点。

*现在让我们回到你的问题：如何使用指针 p 获得值为7？*

在初始化数组后，指针 `p` 被赋值为 `&a[0]`，即指向数组 a 的第一个元素。
为了获得值为 7，我们需要沿着链表找到指向值为 7 的节点。链表的遍历可以通过使用指针的 `p->next` 来实现。

```c
struct st *p = a; // 指针p指向数组a的第一个元素

// 遍历链表直到找到值为7的节点
while (p != NULL) {
    if (p->n == 7) {
        // 找到值为7的节点，p指向该节点
        break;
    }
    p = p->next; // 移动到下一个节点
}

if (p != NULL) {
    // p指向值为7的节点，可以访问值为7的成员
    printf("Found the node with value 7: %d\n", p->n);
} else {
    printf("Node with value 7 not found.\n");
}
```

*为什么不建议使用 `(++p)->n `?*

在 Cpp 14、Clang++环境下，测试结果也是可以访问到值 7 的，但这并不是因为 Cpp 已经智能到可以自动推断链表的指针，而是因为这个结构体变量 a 是个数组，数组的地址自然是线性递增的：
```cpp
# include "iostream"

using namespace std;
struct st {
    int n;
    struct st *next;
} a[3] = {5, &a[1], 7, &a[2], 9, NULL}, *p = a;

int main(){
    st * node1 = new st;
    st * node2 = new st;
    st * node3 = new st;

    node1->n=5;
    node1->next=node2;
    node2->n=7;
    node2->next=node3;
    node3->n=9;
    node3->next= nullptr;

    st * p1 = node1;

    cout<<(++p)->n<<endl;
//    cout<<(++p1)->n<<endl;
//    cout<<p->next->n<<endl;
    cout<<p1->next->n<<endl;
}
```
