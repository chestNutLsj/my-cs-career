容器适配器是一个封装了序列容器的类模板，它在一般序列容器的基础上提供了一些不同的功能。之所以称作适配器类，是因为它可以通过适配容器现有的接口来提供不同的功能。  
  
本章将介绍 3 种容器适配器，分别是 stack、queue、priority_queue：

1. stack\<T\>：是一个封装了 deque\<T\> 容器的适配器类模板，默认实现的是一个后入先出（Last-In-First-Out，LIFO）的压入栈。stack\<T\> 模板定义在头文件 stack 中。
2. queue\<T\>：是一个封装了 deque\<T\> 容器的适配器类模板，默认实现的是一个先入先出（First-In-First-Out，LIFO）的队列。可以为它指定一个符合确定条件的基础容器。queue\<T\> 模板定义在头文件 queue 中。
3. priority_queue\<T\>：是一个封装了 vector\<T\> 容器的适配器类模板，默认实现的是一个会对元素排序，从而保证最大元素总在队列最前面的队列。priority_queue\<T\> 模板定义在头文件 queue 中。

  
适配器类在基础序列容器的基础上实现了一些自己的操作，显然也可以添加一些自己的操作。它们提供的优势是简化了公共接口，而且提高了代码的可读性。本章我们会详细地探讨这些适配器的应用。

## 理解容器适配器

在详解什么是容器适配器之前，初学者首先要理解适配器的含义。

其实，容器适配器中的 “适配器”，和生活中常见的电源适配器中“适配器” 的含义非常接近。我们知道，无论是电脑、手机还是其它电器，充电时都无法直接使用 220 V 的交流电，为了方便用户使用，各个电器厂商都会提供一个适用于自己产品的电源线，它可以将 220 V 的交流电转换成适合电器使用的低压直流电。

从用户的角度看，电源线扮演的角色就是将原本不适用的交流电变得适用，因此其又被称为电源适配器。

再举一个例子，假设一个代码模块 A，它的构成如下所示：

```
class A{
public:
    void f1(){}
    void f2(){}
    void f3(){}
    void f4(){}
};
```

现在我们需要设计一个模板 B，但发现，其实只需要组合一下模块 A 中的 f1 ()、f2 ()、f3 ()，就可以实现模板 B 需要的功能。其中 f1 () 单独使用即可，而 f2 () 和 f3 () 需要组合起来使用，如下所示：

```
class B{
private:
    A * a;
public:
    void g1(){
        a->f1();
    }
    void g2(){
        a->f2();
        a->f3();
    }
};
```

可以看到，就如同是电源适配器将不适用的交流电变得适用一样，模板 B 将不适合直接拿来用的模板 A 变得适用了，因此我们可以将模板 B 称为 B 适配器。

容器适配器也是同样的道理，简单的理解容器适配器，其就是将不适用的序列式容器（包括 vector、deque 和 list）变得适用。容器适配器的底层实现和模板 A、B 的关系是完全相同的，即通过封装某个序列式容器，并重新组合该容器中包含的成员函数，使其满足某些特定场景的需要。

> **容器适配器本质上还是容器，只不过此容器模板类的实现，利用了大量其它基础容器模板类中已经写好的成员函数**。当然，如果必要的话，容器适配器中也可以自创新的成员函数。

需要注意的是，STL 中的容器适配器，其内部使用的基础容器并不是固定的，用户可以在满足特定条件的多个基础容器中自由选择。

### STL 容器适配器的种类
------------

STL 提供了 3 种容器适配器，分别为 stack 栈适配器、queue 队列适配器以及 priority_queue 优先权队列适配器。其中，各适配器所使用的默认基础容器以及可供用户选择的基础容器，如下表所示。

| 容器适配器          | 基础容器筛选条件                                                                                   | 默认使用的基础容器 |
|----------------|--------------------------------------------------------------------------------------------|-----------|
| stack&nbsp;    | 基础容器需包含以下成员函数：empty () size () back () push_back () pop_back ()满足条件的基础容器有 vector、deque、list。   | deque     |
| queue          | 基础容器需包含以下成员函数：empty () size () front () back () push_back () pop_front ()满足条件的基础容器有 deque、list。 | deque     |
| priority_queue | 基础容器需包含以下成员函数：empty () size () front () push_back () pop_back ()满足条件的基础容器有 vector、deque。       | vector    |

不同场景下，由于不同的序列式容器其底层采用的数据结构不同，因此容器适配器的执行效率也不尽相同。但通常情况下，使用默认的基础容器即可。当然，我们也可以手动修改，具体的修改容器适配器基础容器的方法，后续讲解具体的容器适配器会详细介绍。

## 理解迭代器适配器