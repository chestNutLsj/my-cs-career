## 3-10 插入排序性能分析
**背景**：序列中 n 个元素的数值为独立均匀地随机分布。证明：

1. ==列表的插入排序算法平均做 (n^2)/4=O (n^2)次元素比较操作==
首先，平均意义下的比较操作次数，也就是概率意义下比较操作的期望次数。
该算法共需执行O(n)步迭代，故根据期望值的线性律（linearity of expectation），比较操作总次数的期望值，应该等于各步迭代中比较操作次数的期望值之和。

该算法中的比较操作，主要消耗于对有序子列表的search()查找过程。
由3.4.2节的分析结论，search()接口具有线性的平均复杂度。这就意味着，各步迭代内的search()过程所涉及的比较操作次数，应从0到n - 1按算术级数线性递增，故其总和应为：
$$
\sum\limits_{k=0}^{n-1}(\frac{k}{2})=\frac{n\cdot(n-1)}{4}=O(n^{2})
$$


2. ==向量插入排序算法平均做 (n^2)/4=O (n^2)次元素移动操作==
与列表不同，向量的插入排序中 search()查找接口可以采用二分查找之类的算法，从而使其复杂度从线性降低至O(logn)。
然而另一方面，在确定适当位置之后为将新元素插入已排序的子序列，尽管列表只需 O(1)时间，但向量在最坏情况下我们不得移动 O(n)个节点，而且平均而言亦是如此。故与 1) 同理，总体而言，平均共需执行 O(n^2)次元素移动操作。

由这个例子，可清楚地看出两种数据访问方式各自的长处：循秩访问的方式更适宜于静态的查找操作，但在频繁动态修改的场合却显得效率低下；循位置访问的方式更适宜于动态修改，却不能高效地支持静态查找。


3. ==序列的插入排序算法过程中平均有 expected-O (logn)个元素无需移动==
同样地，既然该算法由多步迭代构成，故其间无需移动的元素的期望数目，就应该等于各步迭代中，待插入元素无需移动的概率总和。
根据该算法的原理，对于任意 $k \in [0, n)$，在第 k 步迭代启动之初，当前元素 A\[k\]的 k 个前驱应该业已构成一个有序的子序列 A\[0, k\)。不难看出，若 A\[k\]无需移动即使得 A\[0, k\]仍为有序子序列，则其充要条件是，A\[k\]在 A\[0, k\]中为最大元素。

既然假定所有元素都符合独立且均匀的随机分布，故作为前 k + 1个输入元素中的普通一员，A\[k\]在其中为最大元素的概率应与其它元素均等，都是1/(k +1)。于是，这一概率的总和即为：
$$
\sum\limits_{k=0}^{n-1} \frac{1}{k+1}=\sum\limits_{k=1}^{n} \frac{1}{k}=\Theta(\log n)
$$

## 3-11