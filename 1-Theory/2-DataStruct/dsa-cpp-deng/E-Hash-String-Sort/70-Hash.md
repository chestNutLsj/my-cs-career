## Dictionary ADT
```
template <typename K, typename V> //key、value
struct Dictionary {
	virtual Rank size() = 0;
	virtual bool put( K, V ) = 0;
	virtual V* get( K ) = 0;
	virtual bool remove( K ) = 0;
};

```

词典中的词条只需支持判等/比对操作。

词条 entry=(key, value)，词条的集合作为 Map/Dictionary，并且关键码 key 有雷同性限制。

关键码 key 可以是任何类型，因此未必支持大小比较。

## 散列
数组存放数据的查询效率很高，可以达到 O(1)。但是所有空间常常不能占满，例如以电话号码为例：
- 可能的电话号种数=R=10^11
- 实际可用的电话号种数=N=25000
- 因此实际的空间复杂度= O (R+N)，效率=25K/10^5M=0.000025%

为了提高空间利用率，又保证查找速度，可以使用散列法：
![[70-Hash-hashing.png]]
- 桶 bucket：直接存放或间接指向一个词条；
- Bucket array ~ Hashtable：容量 M (N<M<<R)，使得空间复杂度 O (N+M)=O (2N+C)=O (N)
- 定址：根据词条的 key，直接（实际是通过散列函数和冲突解决策略）确定散列表的入口
- 散列函数：hash (): key-->&entry
- “直接”：expected-O (1) ，而不是 O (1)

## 冲突
指不同的 key，在经过 hash 函数运算后得到相同的结果：
![[70-Hash-synonym.png]]

考虑装填因子 load factor: λ=N/M
- λ越大，空间利用率越高，但相应的发生冲突的概率越高。
- 通过降低 λ，即增加桶的容量 M，可以改善冲突程度，但只要 M<<R 这一条件存在，冲突就不可能杜绝。

### 完美散列
数据集已知且固定时，可实现完美散列（perfect hashing） 
- 采用两级散列模式
- 仅需 O(n)空间 
- 关键码之间互不冲突
- 最坏情况下的查找时间也不过 O (1) 
- 不过在一般情况下，完美散列可期不可求...
![[70-Hash-perfect-hash.png]]

### 生日悖论
将在座同学（对应的词条）按生日（月/日）做散列存储，散列表长 M = 365，装填因子 = 在场人数 N / 365 

冲突（至少有两位同学生日相同）的可能性 P365(n) = ？ 
P365(1) = 0, P365(2) = 1/365, ..., P365(22) = 47.6%, P365(23) = 50.7%, ... 

100人的集会：1 - P365(100) = 0.000,031% 

因此，在装填因子确定之后，散列策略的选取将至关重要，同时，发生冲突时尽快、高效地排解也非常重要。

## 散列函数
