## 判断

1. 即便 $f(n)=O(g(n))$，也未必有 $2^{f(n)}=O(2^{g(n)})$ 

> ❌

2. 不存在 CBA 式算法，能够经过少于 2n-3 次比较操作，从 n 个整数中找出最大和次大者。

> ✅ 最好情况，第一个和第二个整数正好是最大和次大，那么比较次数的下界为 n-1+n-2=2n-3

3. 存在 CBA 式算法，能够在 $O (n)$ 时间内从 n 个无序整数中找出最大的 10%

> ❌

4. 起泡排序过程中，每经过一趟扫描交换，相邻的逆序对必然减少。

> ❌  2  3  1  4

5. 即便借助二分查找确定每个元素的插入位置，向量的插入排序最坏情况下仍需 $\Omega(n^2)$ 的时间

> ✅

6. 带权重的最优 PFC 编码树不仅未必唯一、拓扑结构未必相同，甚至树高也可能不等。

> ✅

## 多重选择

1. 若每一递归实例本身仅需常数时间和空间，则（   ）函数的渐进时间复杂度等于渐进空间复杂度
A. 尾递归
B. 线性递归
C. 二分递归
D. 多分支递归

2. 使用二分查找 C 版本在有序向量{1,3,5,7,..., 2013}中查找，目标为独立均匀分布于{0,2014}内的整数。若平均失败查找长度为 F，则平均成功查找长度 S 应为：
A. $\frac{1008F}{1007}+1$ 
B. $\frac{1008F}{1007}-1$ 
C. $\frac{1008(F-1)}{1007}+1$ 
D. $\frac{1008(F+1)}{1007}-1$ 

3. 设图灵机在初始状态下，只有读写头所对单元格为 `'0'`，其余均为 `'#'`；此后连续地执行 increase ()算法 2014 次，在此期间读写头累计移动的次数（就相对误差率而言）最接近于（     ）
A. 2000
B. 4000
C. 8000
D. 16000
E. 32000

4. 字符串 `"123XY"` 在经栈混洗后，可以得到（    ）个合法的 C++变量名

5. 

## 填空

## 计算

## 证明

## 算法