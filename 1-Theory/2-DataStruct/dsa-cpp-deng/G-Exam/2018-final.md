## B-tree

## 理想随机
本课程所介绍的一些算法不数据结构，乃是针对实际应用中普遍存在的非随机数据集而设计的；反过来，只要 数据集是理想随机的，则大可丌必采用。试举三个这样的案例，列出讲义页码，并作简要说明（各丌超过两行）

1. BST 如果理想随机，就没有必要平衡化
2. 除余法中如果 key 足够理想随机，那么 hash 表长就没有必要必须是质数；
3. 如果文本串和模式串出现的概率足够随机，那么 KMP 算法的效率和暴力算法一致。

## 判断
1. 某节点被删除后 AVL 树的高度即便下降了，这次操作期间也未必经过旋转调整。

> ✅

2. 图的 DFS 算法中的 default 分支，将 `dTime(v)<dTime(u)` 改为 `dTime(v)<fTime(u)` 同样可行。

> ❌

3. 有向图经 DFS 后若共有 k 条边被标记为 BACKWARD，则应该恰有 k 个环路。

> ❌

4. 左式堆中每一对兄弟节点的高度尽管未必左大右小，但左兄弟至少不低于右兄弟的一半。

> ✅

5. 对于同一无向图，起始于顶点 s 的 DFS 尽管可能得到结构不同的 DFS 树，但 s 在树中的度数必然固定。

> ❌

6. 采用 Crane 算法将左式堆 A 与 B 合并为左式堆 H，则 H 右侧链上的节点未必都来自 A 或 B 的右侧链。

> ✅

7. 采用单向平方试探策略的散列表，只要长度 M 不是素数，则每一组同义词在表中都不会超过 $\lfloor M/2\rfloor$。

> ✅