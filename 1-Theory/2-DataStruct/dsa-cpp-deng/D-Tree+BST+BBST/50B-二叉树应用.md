## 图/树的直径、偏心率、半径、中心
![[50-Tree-app.png]]
- Diameter: 直径是指图中任意两个节点之间的最长路径的长度。
	- 换句话说，它是连接图中任意两个节点的最长边的长度。
	- 直径反映了图或树的整体大小。
- Eccentricity: 对于每个节点来说，其偏心率是指从该节点到图中所有其他节点的最长路径的长度中的最大值。
	- 偏心率衡量了一个节点到图中其他节点的距离，偏心率最小的节点被称为图的中心。
- Radius: 图或树的半径是指所有节点偏心率中的最小值。
	- 换句话说，它是图中所有节点到离它最远的节点的最短距离中的最小值。
	- 半径反映了图或树的紧凑程度，越小表示越紧凑。
- Center: 图或树的中心是指具有最小偏心率的节点集合。
	- 这些节点是离图中其他节点最近的节点，通常是半径的节点。
	- 中心是图或树的"核心"部分。

## 树的半径与BFS
![[50-Tree-diameter.png]]
- BFS 遍历是计算树直径的一种常用方法之一。
- 树的直径是指树中任意两个节点之间的最长路径的长度。通过 BFS 遍历，可以轻松地找到树的直径，以下是一个简单的步骤：
	1. 选择树中的任意节点作为起始节点。
	2. 使用 BFS 从选定的起始节点开始，一层一层地探索树的节点。在每一层中，记录最后一个被访问的节点。
	3. 当 BFS 完成后，最后一个被访问的节点就是树的直径的一个端点。
	4. 重新选择刚才找到的端点作为新的起始节点，再次进行 BFS。
	5. 最后一次 BFS 访问的节点将是树的直径的另一个端点。
	6. 最长路径就是这两个端点之间的路径，其长度即为树的直径。

BFS 遍历保证了从树的一侧到达另一侧，因此，通过上述过程，能够找到树的直径。BFS 的时间复杂度是 O(V + E)，其中 V 是节点数，E 是边数，对于树结构，E = V - 1，因此该方法的时间复杂度为 O(V)。

## 圆桌骑士问题
![[50-Tree-knights-of-round-table.png]]
[365. 圆桌骑士 - AcWing题库](https://www.acwing.com/problem/content/description/367/)
国王有时会在圆桌上召开骑士会议。
由于骑士的数量很多，所以每个骑士都前来参与会议的情况非常少见。
通常只会有一部分骑士前来参与会议，而其余的骑士则忙着在全国各地做英勇事迹。
骑士们都争强好胜，好勇斗狠，经常在会议中大打出手，影响会议的正常进行。
现在已知有若干对骑士之间互相憎恨。

为了会议能够顺利的召开，每次开会都必须满足如下要求：
1. 相互憎恨的两个骑士不能坐在相邻的两个位置。
2. 为了让投票表决议题时都能有结果（不平票），出席会议的骑士数必须是奇数。
3. 参与会议的骑士数量不能只有 1 名。

如果前来参加会议的骑士，不能同时满足以上三个要求，会议会被取消。
如果有某个骑士无法出席任何会议，则国王会为了世界和平把他踢出骑士团。

现在给定骑士总数 n，以及 m 对相互憎恨的关系，求至少要踢掉多少个骑士。

### 输入格式

输入包含多组测试用例。

对于每个用例，第一行包含两个整数 n 和 m。

接下来 m 行，每行包含两个整数 a 和 b，表示骑士 a 和骑士 b 相互憎恨。

当遇到某行为 `0 0` 时表示输入终止。

### 输出格式

每个测试用例输出一个整数，表示结果。

每个结果占一行。

### 数据范围

n≤1000,m≤106

## 旅行骑士问题
![[50-Tree-traveling-knight.png]]
这个问题涉及到象棋中的骑士棋子，目标是找到一种方式，使得骑士按照象棋规则（骑士按“日”字格走），恰好访问棋盘上的每个格子一次，并最终回到起始位置。

这个问题通常被用来考察图论和搜索算法的性能，它涉及到数据结构，特别是用于存储骑士在棋盘上移动的数据结构。通常，这个问题可以使用图或矩阵来建模，其中每个格子是一个节点，骑士的合法移动是边，然后可以使用深度优先搜索（DFS）或其他搜索算法来找到解决方案。
