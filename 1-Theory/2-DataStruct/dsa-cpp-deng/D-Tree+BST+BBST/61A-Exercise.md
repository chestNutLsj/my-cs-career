## 7-1 证明 BST 的中序遍历序列单调非降
考查二叉搜索树中的任一节点 r。按照中序遍历的约定，r 左（右）子树中的节点（若存在）均应先于（后于）r接受访问。
按照二叉搜索树的定义，r左（右）子树中的节点（若存在）均不大于（不小于）r，故中序遍历序列必然在r处单调非降；反之亦然。
鉴于以上所取r的任意性，题中命题应在二叉搜索树中处处成立。

由此题亦可看出，二叉搜索树的定义不能更改为“任意节点 r 的左（右）孩子（若存在）均不大于（不小于）r”——相当于将原定义中的“左（右）后代”，替换为“左（右）孩子”。
为强化印象，读者不妨构造一个符合这一“定义”，但却不是二叉搜索树的具体实例。
![[60A-Binary_Search_Tree#^d29fb9]]

## 7-2 互异 BST 的数量
我们将 n 个互异节点所能组成二叉搜索树的总数，记作 T(n)。 由上题结论，==尽管由同一组节点组成的二叉搜索树不尽相同，但它们的中序遍历序列却必然相同==，不妨记作： 
$x_0 x_1 x_2 ... x_{k-1} x_{k} x_{k+1} x_{k+2} ... x_{n-1}$ 

根据所取树根节点的不同，所有搜索树可以分为 n 类。如上所示，对于其中以 $x_k$ 为根者而言，左、右子树必然分别由{ $x_0, x_1, x_2, ..., x_{k-1}$ }和{ $x_{k+1}, x_{k+2}, ..., x_{n-1}$ }组成。 

如此，可得边界条件和递推式如下：
T (0)=T (1)=1
$T(n)=\sum\limits_{k=1}^{n}T(k-1)\cdot T(n-k)=catalan(n)=\frac{(2n)!}{(n+1)!\cdot n!}$ 
这是典型的 Catalan 数式递推关系，解之即得题中结论。

## 7-3 证明 n 个节点的二叉树最低 $\lfloor \log_{2}(n)\rfloor$ ——即完全二叉树的树高
实际上不难证明，若高度为 h 的二叉树共含 n 个节点，则必有： 
n <= 2^(h+1) - 1 

这里的等号成立，当且仅当是满树。于是有： 
h >= log2(n + 1) - 1 
h >= $\lceil \log_{2}(n+1)\rceil-1$ = $\lfloor \log_{2}(n)\rfloor$

## 7-5 证明 insert 在 BST 中插入节点 v 后的高度问题
1. ==除 v 的历代祖先外，其余节点的高度无需更新==；
节点的高度仅取决于其后代更确切地，等于该节点与其最深后代之间的距离。 因此在插入节点 v 之后，节点 a 的高度可能发生变化（增加），当且仅当 v 是 a 的后代，或反过来 等价地，a 是 v 的祖先。

2. ==祖先高度不会降低，但至多+1==
插入节点 v 之后，所有节点的后代集不致缩小。而正如前述，高度取决于后代深度的最大值，故不致下降。 另一方面，假定节点 a 的高度由 h 增加至 h'。若将 v 的父节点记作 p，则 a 到 p 的距离不大于 a 在此之前的高度 h，于是必有：
h' <= |ap| + 1 <= h + 1

3. ==一旦某个祖先高度不变，更高的祖先也必然高度不变==
对于任意节点 p，若将其左、右孩子分别记作 l 和 r（可能是空），则必有： height(p) = 1 + max( height(l), height(r) ) 

在插入节点 v 之后，在 l 和 r 之间，至多其一可能会（作为 v 的祖先而）有所变化。一旦该节点的高度不变，p 以及更高层祖先（如果存在的话）的高度亦保持不变。

## 7-6 remove 删除 x 的影响
1. ==除 x 的历代祖先外，其余节点的高度无需更新==
同样地，节点的高度仅取决于其后代——更确切地，等于该节点与其最深后代之间的距离。 因此在删除节点 x 之后，节点 a 的高度可能发生变化（下降），当且仅当 x 是 a 的后代，或反过来 等价地，a 是 x 的祖先。

2. ==祖先高度不会增加，但至多减一==
假设在删除节点 x 之后，祖先节点 a 的高度由 h 变化为 h'。现在，我们假想式地将 x 重新插回树中，于是自然地，a 的高度应该从 h'恢复至 h。
由7-5题的结论 2) ，必有： h <= h' + 1 亦即： h' >= h - 1

3. ==一旦某个祖先高度不变，更高的祖先高度也必然不变==
反证，假设在删除节点 x 之后，祖先节点的高度会间隔地下降和不变。
仿照上一问的思路，假想着将 x 重新插回树中。于是，所有节点的高度均应复原，而祖先节点的高度则必然会间隔地上升和不变。这与7-5 题的结论3)相悖。

## 7-9 removeAt 中随机选取 succ 和 pred 以减少倾侧
**描述**：BinTree::removeAt()算法的执行过程中，当目标节点同时拥有左、右孩子时，总是固定地选取直接后继与之交换。于是，从二叉搜索树的整个生命期来看，左子树将越来越倾向高于右子树，从而加剧整体的不平衡性。 一种简捷且行之有效的改金策略是，除直接后继外还同时考虑直接前驱，并在二者之间随机选取。

![[60A-Binary_Search_Tree#^e2a6fa]]

==试基二习题 5-14 扩展的 pred()接口，实现这一策略==；

针对这一问题，实现随机选取的一种简明方法是： 
==调用 rand()取（伪）随机数，根据其奇偶，相应地调用 succ()或 pred()接口 ==

从理论上讲，如此可以保证各有50%的概率使用直接后继或直接前驱，从而在很大程度上消 除题中指出的“天然”不均衡性。 BinTree::removeAt()算法的其余部分，无需任何修改。

## 7-10 扩充 searchAll(e)接口
![[60A-Binary_Search_Tree#^dc6a84]]
1. ==扩充 searchAll (e)接口以适应 BST 支持多个相等数据项并存的情况，要求时间复杂度不超过 O (h+k)==(h is BST height, k is nums of e)
从后面第8.4.1节所介绍范围查询的角度来看，从二叉搜索树中找出所有数值等于 e 的节点，完全等效于针对区间(e - ε, e + ε)的范围查找，其中ε为某一足够小的正数。

因此，自然可以套用第8.4.1节所给的算法框架：
- 针对 e - ε和 e + ε各做一次查找，并确定查找路径终点的最低公共祖先；
- 在从公共祖先通往这两个终点的路径上，自上而下地根据各层的分支方向，相应地忽略整个分支，或者将整个分支悉数报告出来。
- 整个算法所拣出的分支，==在每一层不超过两个，故总共不会超过 O (h)个==。借助（任何一种 常规的）遍历算法，都可在线性时间内枚举出每个分支中的所有节点；而对所有分支的遍历，累计耗时亦不过 O (k)。

需要特别说明的是，这里既不便于也不需要显式地确定ε的具体数值。实际上，我们只需要对比较器做适当的调整：针对 e - ε（e + ε）的查找过程，与针对 e 的查找过程基本相同，只是在遇到数值为 e 的节点时，统一约定向左（右）侧深入。

2. ==改进原有的 search 接口，使之总是返回最早插入的节点 e——FIFO==
在中序遍历序列中，所有数值为 e 的雷同节点，必然依次紧邻地构成一个区间。为实现“先进先出”的规范，需要进一步地要求它们在此区间内按插入次序排列。

为此可以统一约定：在BST::insert(e)内的查找定位过程中，**凡遇到数值相同的节点，均优先向右侧深入**；而在BST::search(e)的查找过程中，凡遇到数值相同的节点，均向左侧深入。 当然，将以上约定的左、右次序颠倒过来，亦同样可行。

## 7-12 高度 h 的 AVL 树任一叶节点深度均不小于 $\lceil \frac{h}{2}\rceil$
对树高 h 做数学归纳。作为归纳基，h = 1时的情况显然。假设以上命题对高度小于 h 的 AVL 树均成立，以下考查高度为 h 的 AVL 树。
![[61-Exercise-shallowest-node-in-avl.png]]

根据 AVL 树的性质，如图 x7.1所示，此时左、右子树的高度至多为 h - 1，至少为 h - 2。 由归纳假设，在高度为 h - 1的子树内部，叶节点深度不小于： $\lceil \frac{h-1}{2}\rceil \ge \lceil \frac{h}{2}\rceil-1$ 

而在高度为 h - 2的子树内部，叶节点深度也不小于： $\lceil \frac{h}{2}\rceil-1$

因此在全树中，任何叶节点深度都不致小于： $1+(\lceil \frac{h}{2}\rceil-1)=\lceil \frac{h}{2}\rceil$

## 7-13 证明 AVL 树插入节点后失衡的祖先数可能多达Ω(logn)个
首先，引入一类特殊的 AVL 树，它们符合以下条件：其中每个内部节点的左子树，都比右子树在高度上少一。这也就是所谓的 Fib-AVL 树（Fibonaccian AVL tree）。 
![[61-Exercise-fib-avl.png]]

如图 x7.2(a~d)所示，即为高度分别为1、2、3和4的 Fib-AVL 树。通过数学归纳法不难证明， 此类 AVL 树的高度若为 h，则其规模必然是 fib(h + 3) - 1，故此得名。实际上，Fib-AVL 树也是在高度固定的前提下，节点总数最少的 AVL 树。

考查其中数值最大（中序遍历序列中最靠后）的节点 M。该节点共计 h 个祖先，而且它们的平衡因子均为-1。现在，假设需要将一个词条插入其中，而且该词条大于节点 M。按照二叉搜索树的插入算法，必然会相应地在节点 M 之下，新建一个右孩子 x。此时，==节点 M 所有祖先的平衡因子都会更新为-2，从而出现失衡现象==。

失衡节点的总数为： $h = fib^{-1} (n + 1) - 3 = \log_{\Phi}n = O(\log n)$ 
其中， Φ = (√5 + 1) / 2 = 1.618

## 7-13-b 证明 AVL 中删除一个节点后失衡祖先至多 1 个
节点的失衡与否，取决于其左、右子树高度之差。因此反过来，只要子树的高度不变，则节点不可能失衡。

在删除节点之后自底而上逐层核对平衡因子的过程中，一旦遇到一个失衡节点 v，则被删除节点必然来自 v 原本更低的一棵子树，而 v 的高度必然由其另一更高的子树确定，故 v 的高度必然保持不变。由以上分析结论，除了 v 本身，其祖先节点必然不可能失衡。

## 7-15 证明 BST 在 n-1 次旋转内可以等价变换为左侧链
为此，需要回顾迭代式先序遍历算法，并对该算法的流程略作改动。
![[50-Tree#^871d4f]]
![[图05-32.先序遍历过程：先沿左侧通路自顶而下访问沿途节点，再自底而上依次遍历这些节点的右子树.png]]

考查二叉搜索树的最左侧通路。从该通路的末端节点 $L_d$ 开始，我们将逐步迭代地延长该路径，直至不能继续延长。每次迭代，无非两种情况：
- 其一，若 $L_k$ 的右子树为空，则可令 $L_k$ 上移一层，转至其父节点。
- 其二，若 $L_k$ 的右孩子 $R_k$ 存在，则可以 $L_k$ 为轴，做一次 zag 旋转调整。如此，$R_k$ 将（作为 $L_k$ 的 父亲）纳入最左侧通路中。

不难看出，整个迭代过程的不变性为：
1) 当前节点 $L_k$ 来自最左侧通路
2) $L_k$ 的左子树（由不大于 $L_k$ 的所有节点组成）已不含任何右向分支

另外，整个迭代过程也满足如下单调性：**最左侧通路的长度，严格单调地增加**故该算法必然终止，且最终所得的二叉搜索树不再含有任何右向分支。

```
//通过zag旋转调整，将子树x拉伸成最左侧通路
template <typename T> void stretchByZag ( BinNodePosi(T) & x ) {
	int h = 0;
	BinNodePosi(T) p = x;
	while ( p->rc ) p = p->rc; //最大节点，必是子树最终的根
	while ( x->lc ) x = x->lc; 
	x->height = h++; //转至初始最左侧通路的末端
	for ( ; x != p; x = x->parent, x->height = h++ ) { //若x右子树已空，则上升一局
		while ( x->rc ) //否则，反复地
			x->zag(); //以x为轴做zag旋转
	} //直到抵达子树的根
}

```
可见，每做一次 zag 旋转调整，总有一个节点归入最左侧通路中，后者的长度也同时加一。**最坏情况下，除原根节点外，其余节点均各自对应于一次旋转，累计不过 n - 1次**。

通过进一步的观察不难看出： **任一节点需要通过一次旋转归入最左侧通路，当且仅当它最初不在最左侧通路上** 

故若原最左侧通路的长度为 s，则上述算法所做的旋转调整，恰好共计 n - s - 1次。 其中特别地，s = 0（根节点的左子树为空），当且仅当需做 n - 1 次旋转——这也是最坏情况的充要条件。

## 7-15-b 规模 n 的任何两棵等价 BST 至多 2n-2 次调整就可彼此转换
既然每棵二叉搜索树经过至多 n - 1次旋转调整，总能等价变换为最左侧通路，故反之亦然。因此，对于任何两棵二叉搜索树，都可按照上述方法，经至多 n - 1次旋转调整，==先将其一等价变换为最左侧通路；然后同理，可再经至多 n - 1次旋转调整，从最左侧通路等价变换至另一棵二叉搜索树==。

## 7-15-补 证明对等价 BBST 不能在 O (logn)时间内互相转换
结论：**即使不要求转换过程中保持是 BBST 也不能在 O (logn)次旋转内转换**

方法一：考虑势能 Phi = ∑log|n_L| - ∑log|n_R|，其中 n_L 和 n_R 是每个节点左右子树的规模，容易证明每次旋转对势能的影响是 O (logn)的，但是向左侧倾斜的 Fib-AVL 树的势能是 Theta(n)的，所以不能在 O (logn)次旋转里做完。

方法二：每次旋转可以选择的旋转方法是 O (n)的，如果一共旋转 O (logn)次，那么所有的旋转序列数量大约是 O (n^logn)，但是 AVL 树的数量是指数的（O (2^n)），就算每个旋转序列得到的树都不相同也不能遍历所有的 AVL 树

>[! note] AVL 树的种类
>参考论文：Some new methods and results in tree enumeration, A. M. Odlyzko, Congressus Numerantium, 42 (1984), pp. 27-52.
>
>其中：
>![[AVL-nums.png]]

## 7-16 在 AVL 树中的 searchAll 接口的时间复杂度
原理及方法均与习题7-10完全相同。
性能方面，通过遍历枚举所有命中子树中的节点，仍可以在线性的 O(k)时间内完成；因为 AVL 树可以保持适度平衡，故所涉及的查找可以更快完成，累计耗时不超过 O(logn)。

## 7-17 证明对于规模 n 的 AVL 树删除一节点后最多需要Ω(logn)次旋转才能恢复平衡
首先，考查习题7-13所引入的 Fib-AVL 树。
![[61-Exercise-fib-avl.png]]

若从该树中删除最小的节点（亦即中序遍历序列中的首节点） m，则首先会导致 m 的父节点 p 失衡。

在树高 h 为奇数时，m 虽不是叶节点，但按照二叉搜索树的删除算法，在实际摘除 m 之前，必然已经将 m 与其直接后继（此时亦即其右孩子）交换，从而等效于 删除其右孩子。

不难验证，在父节点 p 恢复平衡之后，其高度必然减一，从而造成 m 祖父节点 g 的失衡。同样地，尽管节点 g 可以恢复平衡，但其高度必然减一，从而造成更高层祖先的失衡。这种现象，可以一直传播至树根。

仿照习题7-12的分析方法不难证明，在高度为 h 的 Fib-AVL 树中，节点 m 的深度为 $\lfloor \frac{h}{2}\rfloor$。 因此，上述重平衡过程所涉及的节点旋转次数应不少于：

$\lfloor \frac{h}{2}\rfloor= \lfloor \frac{fib^{-1}(n+1)-3}{2}\rfloor=\frac{\log_{\Phi}n}{2}=\Omega(\log n)$

其中， Φ = (√5 + 1) / 2 = 1.618 

实际上，只需对以上 Fib-AVL 树的结构做进一步的调整，完全可以使得每个节点的重平衡都属于双旋形式，从而使得总体的旋转次数加倍至： $\lfloor \frac{h}{2}\rfloor\cdot2\approx h$ 

当然，从渐进的角度看，以上结论并未有实质的改进。尽管以上方法仅适用于规模为 n = fib(h + 3) - 1的 AVL 树，但其原理及方法并不难推广至一般性的 n。

## 7-19 AVL 树中删除一个节点且调整后某祖先 g(x) 复平衡，是否可以停止上溯？
实际上，此时若停止上溯，则有可能会遗漏更高层的失衡祖先节点AVL 树节点删除操作 的这一性质，与节点插入操作完全不同。 考查如图 x7.3(a)所示的实例，只需注意逐一核对各节点的平衡因子，不难验证这的确是一 棵 AVL 树，且高度为5。其中，左子树高度为3，右子树高度为4，但鉴于其具体结构组成无所谓， 故未予详细绘出。

![[61-Exercise-7-19.png]]

现在，若从中删除节点 x，则首先按照二叉搜索树的算法，将其直接摘除。此时应如图(b) 所示，全树唯一的失衡节点只有 g。于是接下来按照 AVL-树的重平衡算法，经双旋调整即可恢复 这一局部的平衡。 此时，考查 g 原先的父节点 k。如图(c)所示，尽管节点 k 的平衡因子由+1降至0，却依然不失 平衡。然而，自底而上的调整过程不能就此终止。我们注意到，此时节点 k 的高度已由3降至2， 于是对于更高层的祖先节点 r 而言，平衡因子由-1进一步降至-2，从而导致失衡。 由上可见，仅仅通过平衡性，并不足以确定可否及时终止自底而上的重平衡过程。然而，并 非没有办法实现这种优化。实际上，只要转而通过核对重平衡后节点的高度，即可及时判定是否 可以立即终止上溯过程。请读者按照这一提示和思路，独立给出改进的方法。 由此反观 AVL-树的插入操作，之所以能够在首次重平衡之后随即终止上溯，原因在于此时 不仅局部子树的平衡性能够恢复，而且局部子树的高度亦必然同时恢复。

## 7-20 证明递增插入 2^(n+1)-1 个关键码到空 AVL 树中必然得到高度 h 的满树
首先，考察 AVL 的右侧分支。对照 AVL 树的重平衡算法不难发现，在这样的插入过程中，该 分支上沿途上各节点 v 始终满足以下不变性： 1) v 的左子树必为满树； 2) height(rc(v)) - 1  height(lc(v))  height(rc(v)) 实际上，在这一系列的插入操作过程中出现的每一次失衡，都可以通过 zag 单旋予以修复。 如教材196页图7.15(a)所示，若 T0、T1和 T2都是满树，则旋转之后应如图(b)所示，节点 g 与 T0 和 T1必然也构成一棵（增高一层的）满树。 为更加细致地展示这一演变过程并证明以上结论，以下不妨对树高做数学归纳。作为归纳基， 以上命题自然对高度为0（单节点）的 AVL 树成立。假设以上命题对高度不超过 h 的 AVL 树均成立， 现考查高度为 h + 1的情况。
![[61-Exercise-7-20.png]]
如图 x7.4所示，我们不妨将关键码[0, 2h+2 - 1)的插入过程，分为四个阶段： a） 首先插入关键码[0, 2 h+1 - 1) 由归纳假设，应得到一棵高度为 h 的满树。 以 h = 3为例，在将关键码[0, 15)依次插入初始为空的 AVL 树后，应如图(a)所示，得到一 棵高度为3、规模为15的满树。 b） 继续插入关键码[2 h+1 - 1, 3∙2 h - 1) 这一阶段的插入对树根的左子树没有影响，其效果等同于将这些关键码单调地插入右子树。 因此亦由归纳假设，右子树必然成为一棵高度为 h 的满树。

继续以上实例。在接下来依次插入关键码[15, 22)之后，该AVL树应如图(b)所示，根节点 的左子树与右子树分别是一棵高度为2和3的满树。 c） 再插入关键码[3∙2 h - 1] 如此，必将引起树根节点的失衡，并在以根为轴做zag单旋之后恢复平衡。此后，根节点的 左子树是高度为h的满树；右子树高度亦为h，但最底层只有一个关键码新插入的[3∙2 h - 1]。 仍然继续上例。在接下来再插入关键码[23]之后，该AVL树应如图(c)所示，根节点的左子 树是一棵高度为3的满树；右子树高度亦为3，但最底层仅有一个关键码[23]。 d） 最后，插入关键码[3∙2 h , 2h+2 - 1) 同样地，这些关键码的插入并不影响树根的左子树，其效果等同于将这些关键码单调地插入 右子树。故由归纳假设，右子树必然成为一棵高度为h的满树。至此，整体得到一棵高度为h + 1 的满树。 仍然继续上例。在接下来再插入关键码[24, 32)之后，该AVL树应如图(d)所示，根节点的 左子树和右子树都是高度为3的满树，整体构成一棵高度为4的满树。
