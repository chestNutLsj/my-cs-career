## 8-2 Splay Tree 操作的分摊时间复杂度为 O (logn)
关于伸展树可在任意情况下均保持良好的操作效率，教材208页图8.7的实例还不足以作为 严格的证明。事实上，伸展树单次操作所需的时间量 T 起伏极大，并不能始终保证控制在 O(logn) 以内。故需沿用教材2.4.4节的方法，从分摊的角度做一分析和评判。具体地，可将实际可能连 续发生的一系列操作视作一个整体过程，将总体所需计算时间分摊至其间的每一操作，如此即可 得到其单次操作的分摊复杂度 A，并依此评判伸展树的整体性能。 当然，就具体的某次操作而言，实际执行时间 T 与分摊执行时间 A 往往并不一致，如何弥合 二者之间的差异呢？ 实际上，分摊分析法在教材中已经而且将会多次出现，比如此前第2.4.4节的可扩充向量、 第5.4节的各种迭代式遍历算法以及后面第11.3.7节的 KMP 串匹配算法等。相对而言，伸展树的 性能分析更为复杂，以下将采用势能分析法（potential analysis）。 仿照物理学的思想和概念，这里可假想式地认为，每棵伸展树 S 都具有一定量（非负）的势 能（potential），记作(S)。于是，若经过某一操作并相应地通过旋转完成伸展之后 S 演化为 另一伸展树 S'，则对应的势能变化为：  = (S') - (S) 推而广之，考查对某伸展树 S0连续实施 m >> n 次操作的过程。将第 i 次操作后的伸展树记作 Si，则有： i = (Si) - (Si-1), 1  i  m 而从该过程的整体来看，应有  = i=1 m [(Si) - (Si-1)] = (Sm) - (S0) 也就是说，整体的势能变化量仅取决于最初和最终状态这与物理学中势能场的规律吻 合。势能函数与物理学中势能的另一相似之处在于，它也可以被看作是能量（计算成本）的一种 存在形式。比如，当某一步计算实际所需的时间小于分摊复杂度时，则可理解为通过势能的增加

将提前支出的计算成本存储起来；反之，在前者大于后者时，则可从此前积累的势能中支取相应 量用于支付超出的计算成本。 以下，若将第 i 次操作的分摊复杂度取作实际复杂度与势能变化量之和，即 A = Ti + i 则有 i=1 m Ai = i=1 m Ti + [(Sm) - (S0)] 如此，总体的实际运行时间i=1 m Ti，将不会超过总体的分摊运行时间i=1 m Ai，故后者可以视作 前者的一个上界。 比如，R. E. Tarjan[42]使用如下势能函数： (S) = vS log|v|, 其中|v| = 节点 v 的后代数目 证明了伸展树单次操作的分摊时间复杂度为 O(logn)。为此，以下将分三种情况（其余情况不过 是它们的对称形式）证明： 在对节点 v 的伸展过程中，每一步调整所需时间均不超过 v 的势能变化的3倍，即： 3∙['(v) - (v)] 情况 A) zig 如教材第8.1.3节所述，这种情况在伸展树的每次操作中至多发生一次，而且只能是伸展调 整过程的最后一步。作为单旋，这一步调整实际所需时间为 T = O(1)。同时由教材207页图8.5， 这步调整过程中只有节点 v 和 p 的势能有所变化，且 v（p）后代增加（减少）势能必上升（下降）， 故对应的分摊复杂度为： A = T +  = 1 + (p) + (v)  1 + ['(v) - (v)] 情况 B) zig-zag 作为双旋的组合，这一调整实际所需时间为 T = O(2)。于是由教材206页图8.4可知： A = T +  = 2 + (v) + (p) + (g) = 2 + '(g) - (g) + '(p) - (p) + '(v) - (v) = 2 + '(g) + '(p) - (p) - (v)........... （∵ '(v) = (g)）  2 + '(g) + '(p) - 2∙(v) ................. （∵ (v) < (p)）  2 + 2∙'(v) - 2 - 2∙(v) .. （∵ '(g) + '(p)  2∙'(v) - 2） = 2∙['(v) - (v)] 这里的最后一步放大，需利用对数函数 f(x) = log2x 的性质，即该函数属于凹函数（concave function），因此必有：

log2a + log2b 2  log2 a + b 2 亦即： log2a + log2b  2∙log2 a + b 2 = 2∙[log2(a + b) - 1] < 2∙(log2c - 1) 情况C) zig-zig 作为双旋的组合，这一调整实际所需时间也为T = O(2)。于是由教材206页图8.3可知 A = T +  = 2 + (v) + (p) + (g) = 2 + '(g) - (g) + '(p) - (p) + '(v) - (v) = 2 + '(g) + '(p) - (p) - (v)........... （∵ '(v) = (g)）  2 + '(g) + '(p) - 2∙(v) ................. （∵ (v) < (p)）  2 + '(g) + '(v) - 2∙(v) ............... （∵ '(p) < '(v)）  3∙['(v) - (v)] ............ （∵ '(g) + (v)  2∙'(v) - 2） 同样地，其中最后一步放大也需利用对数函数的凹性。 综合以上各种情况可知，无论具体过程如何，伸展操作的每一步至多需要3∙['(v) - (v)] 时间。因此，若在对伸展树的某次操作中，节点v经过一连串这样的调整上升成为根节点r，则整 趟伸展操作总体所需的分摊时间为： A  1 + 3∙[(r) - (v)]  1 + 3∙(r) = O(1 + logn) = O(logn)